{"version":3,"sources":["../../src/baseEvmAdapter.ts","../../src/metamaskAdapter.ts"],"names":["BaseEvmAdapter","authenticateUser","provider","chainConfig","chainId","WalletLoginError","notConnectedError","chainNamespace","status","ADAPTER_STATUS","CONNECTED","request","method","accounts","length","existingToken","getSavedToken","name","checkIfTokenIsExpired","idToken","payload","domain","window","location","origin","uri","href","address","parseInt","version","nonce","Math","random","toString","slice","issuedAt","Date","toISOString","signChallenge","challenge","params","signedMessage","verifySignedChallenge","sessionTime","saveToken","disconnect","disconnectionError","clearToken","BaseAdapter","MetamaskAdapter","constructor","adapterOptions","ADAPTER_NAMESPACES","EIP155","CHAIN_NAMESPACES","ADAPTER_CATEGORY","EXTERNAL","WALLET_ADAPTERS","METAMASK","NOT_READY","metamaskProvider","_","Error","init","options","detectEthereumProvider","mustBeMetaMask","WalletInitializationError","notInstalled","log","READY","emit","ADAPTER_EVENTS","debug","autoConnect","rehydrated","connect","ERRORED","setAdapterSettings","getChainConfig","CONNECTING","adapter","switchChain","this","once","reconnected","connectionError","cleanup","removeAllListeners","DISCONNECTED","getUserInfo","switchError","code","chainName","displayName","rpcUrls","rpcTarget"],"mappings":"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","file":"static/js/19.6d8d7a26.chunk.js","sourcesContent":["import { BaseAdapter, WalletLoginError, ADAPTER_STATUS, getSavedToken, checkIfTokenIsExpired, signChallenge, verifySignedChallenge, saveToken, clearToken } from '@web3auth/base';\n\nclass BaseEvmAdapter extends BaseAdapter {\n  async authenticateUser() {\n    var _this$chainConfig;\n\n    if (!this.provider || !((_this$chainConfig = this.chainConfig) !== null && _this$chainConfig !== void 0 && _this$chainConfig.chainId)) throw WalletLoginError.notConnectedError();\n    const {\n      chainNamespace,\n      chainId\n    } = this.chainConfig;\n    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.notConnectedError(\"Not connected with wallet, Please login/connect first\");\n    const accounts = await this.provider.request({\n      method: \"eth_accounts\"\n    });\n\n    if (accounts && accounts.length > 0) {\n      const existingToken = getSavedToken(accounts[0], this.name);\n\n      if (existingToken) {\n        const isExpired = checkIfTokenIsExpired(existingToken);\n\n        if (!isExpired) {\n          return {\n            idToken: existingToken\n          };\n        }\n      }\n\n      const payload = {\n        domain: window.location.origin,\n        uri: window.location.href,\n        address: accounts[0],\n        chainId: parseInt(chainId, 16),\n        version: \"1\",\n        nonce: Math.random().toString(36).slice(2),\n        issuedAt: new Date().toISOString()\n      };\n      const challenge = await signChallenge(payload, chainNamespace);\n      const signedMessage = await this.provider.request({\n        method: \"personal_sign\",\n        params: [challenge, accounts[0]]\n      });\n      const idToken = await verifySignedChallenge(chainNamespace, signedMessage, challenge, this.name, this.sessionTime);\n      saveToken(accounts[0], this.name, idToken);\n      return {\n        idToken\n      };\n    }\n\n    throw WalletLoginError.notConnectedError(\"Not connected with wallet, Please login/connect first\");\n  }\n\n  async disconnect() {\n    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.disconnectionError(\"Not connected with wallet\");\n    const accounts = await this.provider.request({\n      method: \"eth_accounts\"\n    });\n\n    if (accounts && accounts.length > 0) {\n      clearToken(accounts[0], this.name);\n    }\n  }\n\n}\n\nexport { BaseEvmAdapter };\n//# sourceMappingURL=baseEvmAdapter.esm.js.map\n","import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport detectEthereumProvider from '@metamask/detect-provider';\nimport { ADAPTER_NAMESPACES, CHAIN_NAMESPACES, ADAPTER_CATEGORY, WALLET_ADAPTERS, ADAPTER_STATUS, WalletInitializationError, ADAPTER_EVENTS, log, getChainConfig, WalletLoginError } from '@web3auth/base';\nimport { BaseEvmAdapter } from '@web3auth/base-evm-adapter';\n\nclass MetamaskAdapter extends BaseEvmAdapter {\n  constructor() {\n    let adapterOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n\n    _defineProperty(this, \"adapterNamespace\", ADAPTER_NAMESPACES.EIP155);\n\n    _defineProperty(this, \"currentChainNamespace\", CHAIN_NAMESPACES.EIP155);\n\n    _defineProperty(this, \"type\", ADAPTER_CATEGORY.EXTERNAL);\n\n    _defineProperty(this, \"name\", WALLET_ADAPTERS.METAMASK);\n\n    _defineProperty(this, \"status\", ADAPTER_STATUS.NOT_READY);\n\n    _defineProperty(this, \"rehydrated\", false);\n\n    _defineProperty(this, \"metamaskProvider\", null);\n\n    this.chainConfig = adapterOptions.chainConfig || null;\n    this.sessionTime = adapterOptions.sessionTime || 86400;\n  }\n\n  get provider() {\n    if (this.status === ADAPTER_STATUS.CONNECTED && this.metamaskProvider) {\n      return this.metamaskProvider;\n    }\n\n    return null;\n  }\n\n  set provider(_) {\n    throw new Error(\"Not implemented\");\n  }\n\n  async init(options) {\n    super.checkInitializationRequirements();\n    this.metamaskProvider = await detectEthereumProvider({\n      mustBeMetaMask: true\n    });\n    if (!this.metamaskProvider) throw WalletInitializationError.notInstalled(\"Metamask extension is not installed\");\n    this.status = ADAPTER_STATUS.READY;\n    this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.METAMASK);\n\n    try {\n      log.debug(\"initializing metamask adapter\");\n\n      if (options.autoConnect) {\n        this.rehydrated = true;\n        await this.connect();\n      }\n    } catch (error) {\n      this.emit(ADAPTER_EVENTS.ERRORED, error);\n    }\n  }\n\n  setAdapterSettings(options) {\n    if (this.status === ADAPTER_STATUS.READY) return;\n\n    if (options !== null && options !== void 0 && options.sessionTime) {\n      this.sessionTime = options.sessionTime;\n    }\n  }\n\n  async connect() {\n    super.checkConnectionRequirements(); // set default to mainnet\n\n    if (!this.chainConfig) this.chainConfig = getChainConfig(CHAIN_NAMESPACES.EIP155, 1);\n    this.status = ADAPTER_STATUS.CONNECTING;\n    this.emit(ADAPTER_EVENTS.CONNECTING, {\n      adapter: WALLET_ADAPTERS.METAMASK\n    });\n    if (!this.metamaskProvider) throw WalletLoginError.notConnectedError(\"Not able to connect with metamask\");\n\n    try {\n      await this.metamaskProvider.request({\n        method: \"eth_requestAccounts\"\n      });\n      const {\n        chainId\n      } = this.metamaskProvider;\n\n      if (chainId !== this.chainConfig.chainId) {\n        await this.switchChain(this.chainConfig);\n      }\n\n      this.status = ADAPTER_STATUS.CONNECTED;\n      if (!this.provider) throw WalletLoginError.notConnectedError(\"Failed to connect with provider\");\n      this.provider.once(\"disconnect\", () => {\n        // ready to be connected again\n        this.disconnect();\n      });\n      this.emit(ADAPTER_EVENTS.CONNECTED, {\n        adapter: WALLET_ADAPTERS.METAMASK,\n        reconnected: this.rehydrated\n      });\n      return this.provider;\n    } catch (error) {\n      // ready again to be connected\n      this.status = ADAPTER_STATUS.READY;\n      this.rehydrated = false;\n      this.emit(ADAPTER_EVENTS.ERRORED, error);\n      throw WalletLoginError.connectionError(\"Failed to login with metamask wallet\");\n    }\n  }\n\n  async disconnect() {\n    var _this$provider;\n\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      cleanup: false\n    };\n    await super.disconnect();\n    (_this$provider = this.provider) === null || _this$provider === void 0 ? void 0 : _this$provider.removeAllListeners();\n\n    if (options.cleanup) {\n      this.status = ADAPTER_STATUS.NOT_READY;\n      this.metamaskProvider = null;\n    } else {\n      // ready to be connected again\n      this.status = ADAPTER_STATUS.READY;\n    }\n\n    this.rehydrated = false;\n    this.emit(ADAPTER_EVENTS.DISCONNECTED);\n  }\n\n  async getUserInfo() {\n    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.notConnectedError(\"Not connected with wallet, Please login/connect first\");\n    return {};\n  }\n\n  async switchChain(chainConfig) {\n    if (!this.metamaskProvider) throw WalletLoginError.notConnectedError(\"Not connected with wallet\");\n\n    try {\n      await this.metamaskProvider.request({\n        method: \"wallet_switchEthereumChain\",\n        params: [{\n          chainId: chainConfig.chainId\n        }]\n      });\n    } catch (switchError) {\n      // This error code indicates that the chain has not been added to MetaMask.\n      if (switchError.code === 4902) {\n        await this.metamaskProvider.request({\n          method: \"wallet_addEthereumChain\",\n          params: [{\n            chainId: chainConfig.chainId,\n            chainName: chainConfig.displayName,\n            rpcUrls: [chainConfig.rpcTarget]\n          }]\n        });\n      } else {\n        throw switchError;\n      }\n    }\n  }\n\n}\n\nexport { MetamaskAdapter };\n//# sourceMappingURL=metamaskAdapter.esm.js.map\n"],"sourceRoot":""}