{"version":3,"sources":["../node_modules/fast-deep-equal/index.js","../node_modules/is-stream/index.js","../node_modules/@toruslabs/solana-embed/node_modules/loglevel/lib/loglevel.js","../../src/baseSolanaAdapter.ts","../node_modules/bs58/index.js","../node_modules/base-x/src/index.js","../../src/basePostMessageStream.ts","../../src/safeEventEmitter.ts","../../src/serializableError.ts","../../src/jrpc.ts","../../src/jrpcEngine.ts","../../src/substream.ts","../../src/mux.ts","../../src/index.ts","../../src/BaseController.ts","../../src/createEventEmitterProxy.ts","../../src/Network/INetworkController.ts","../../src/enums.ts","../../src/Embed/CommunicationWindowManager.ts","../../src/utils/utils.ts","../../src/Network/createFetchMiddleware.ts","../../src/Preferences/BasePreferencesController.ts","../../src/Transaction/ITransactionController.ts","../node_modules/@web3auth/torus-solana-adapter/node_modules/loglevel/lib/loglevel.js","../../src/messages.ts","../../src/interfaces.ts","../../src/config.ts","../../src/loglevel.ts","../../src/utils.ts","../../src/baseProvider.ts","../../src/embedUtils.ts","../../src/PopupHandler.ts","../../src/communicationProvider.ts","../../src/inPageProvider.ts","../../src/siteMetadata.ts","../../src/embed.ts","../../src/Network/createLoggerMiddleware.ts","../../src/rpc/JrpcClient.ts","../../src/rpc/solanaRpcMiddlewares.ts","../../src/providers/injectedProviders/base/baseInjectedProvider.ts","../../src/providers/injectedProviders/injectedProviderProxy.ts","../../src/providers/injectedProviders/torus/providerHandlers.ts","../../src/providers/injectedProviders/torus/torusInjectedProvider.ts","../../src/providers/privateKeyProvider/solanaPrivateKeyUtils.ts","../../src/providers/privateKeyProvider/solanaPrivateKeyProvider.ts","../../src/commonPrivateKeyProvider.ts","../node_modules/@web3auth/torus-solana-adapter/node_modules/bs58/index.js","../node_modules/@web3auth/torus-solana-adapter/node_modules/base-x/src/index.js","../../src/solanaWalletAdapter.ts"],"names":["module","exports","equal","a","b","constructor","length","i","keys","Array","isArray","RegExp","source","flags","valueOf","Object","prototype","toString","hasOwnProperty","call","key","isStream","stream","pipe","writable","_write","_writableState","readable","_read","_readableState","duplex","transform","_transform","root","definition","define","noop","undefinedType","isIE","window","navigator","test","userAgent","logMethods","bindMethod","obj","methodName","method","bind","Function","e","apply","arguments","traceForIE","console","log","trace","realMethod","undefined","replaceLoggingMethods","level","loggerName","this","methodFactory","debug","enableLoggingWhenConsoleArrives","defaultMethodFactory","Logger","name","defaultLevel","factory","currentLevel","self","storageKey","persistLevelIfPossible","levelNum","levelName","toUpperCase","localStorage","ignore","document","cookie","encodeURIComponent","getPersistedLevel","storedLevel","location","indexOf","exec","slice","levels","clearPersistedLevel","removeItem","getLevel","setLevel","persist","SILENT","setDefaultLevel","resetLevel","enableAll","TRACE","disableAll","initialLevel","defaultLogger","_loggersByName","getLogger","TypeError","logger","_log","noConflict","getLoggers","BaseSolanaAdapter","authenticateUser","provider","chainConfig","chainId","WalletLoginError","notConnectedError","chainNamespace","status","ADAPTER_STATUS","CONNECTED","request","accounts","existingToken","getSavedToken","checkIfTokenIsExpired","idToken","payload","domain","origin","uri","href","address","parseInt","version","nonce","Math","random","issuedAt","Date","toISOString","signChallenge","challenge","encodedMessage","TextEncoder","encode","params","message","display","signedMessage","verifySignedChallenge","bs58","sessionTime","saveToken","disconnect","disconnectionError","clearToken","BaseAdapter","basex","require","ALPHABET","BASE_MAP","Uint8Array","j","x","charAt","xc","charCodeAt","BASE","LEADER","FACTOR","iFACTOR","decodeUnsafe","psz","zeroes","size","b256","carry","it3","Error","it4","vch","ArrayBuffer","isView","buffer","byteOffset","byteLength","from","pbegin","pend","b58","it1","it2","str","repeat","decode","string","ACK","Duplex","safeApply","handler","context","args","Reflect","err","setTimeout","arrayClone","arr","n","copy","SafeEventEmitter","type","doError","events","_events","error","er","len","listeners","EventEmitter","SerializableError","code","data","Number","isInteger","stringify","stack","createScaffoldMiddleware","handlers","req","res","next","end","result","createAsyncMiddleware","asyncMiddleware","nextPromise","Promise","resolve","resolveNextPromise","returnHandlerCallback","nextWasCalled","asyncNext","runReturnHandlersCallback","JRPCEngine","_middleware","middleware","push","cb","_handleBatch","_handle","_promiseHandle","_runAllMiddleware","middlewareError","isComplete","returnHandlers","_runReturnHandlers","handlerCallback","reqs","all","map","responses","_err","callerReq","id","jsonrpc","_processRequest","serializeError","_checkForCompletion","middlewareStack","_runMiddleware","reverse","returnHandler","reject","mergeMiddleware","engine","forEach","asMiddleware","Substream","parent","objectMode","_parent","_name","chunk","_encoding","callback","IGNORE_SUBSTREAM","Symbol","BasePostMessageStream","target","targetWindow","targetOrigin","_init","_haveSyn","_target","_targetWindow","_targetOrigin","_onMessage","onMessage","_synIntervalId","addEventListener","_handShake","cork","_break","emit","uncork","originConstraint","postMessage","event","_onData","_","_postMessage","removeEventListener","getRpcPromiseCallback","unwrapResult","response","createStreamMiddleware","idMap","read","write","processNotification","assign","processResponse","createIdRemapMiddleware","_end","originalId","newId","randomId","done","ObjectMultiplex","opts","_substreams","substream","_cb","once","eos","anyStreamEnd","_error","destroy","warn","logLevel","INFO","apiKey","embedHost","sentry","tracingOrigins","tracingPaths","setAPIKey","apiKey_","fetchAndTrace","url","init","_url","URL","includes","pathname","transaction","startTransaction","span","startChild","op","fetch","finish","getApiKeyHeaders","headers","debugLogResponse","info","statusText","promiseTimeout","ms","promise","timeout","clearTimeout","race","get","options_","customOptions","defaultOptions","mode","useAPIKey","options","merge","ok","json","post","isUrlEncodedData","body","JSON","then","patch","remove","BaseController","config","state","defaultConfig","defaultState","initialState","initialConfig","internalConfig","internalState","configure","overwrite","fullUpdate","update","initialize","filterNoop","internalEvents","externalEventFilter","createEventEmitterProxy","initialTarget","eventFilter","setTarget","newTarget","oldTarget","eventNames","filter","eventEmitter","rawListeners","getRawListeners","on","removeAllListeners","Proxy","set","value","createRandomId","getCreateRandomId","providerFromEngine","sendAsync","handle","fallbackError","ethErrors","rpc","internal","send","COMMUNICATION_JRPC_METHODS","RETRIABLE_ERRORS","checkForHttpErrors","fetchRes","methodNotFound","duration","parseResponse","createFetchConfigFromReq","rpcTarget","originHttpHeaderKey","parsedUrl","originDomain","fetchParams","Accept","fetchUrl","createFetchMiddleware","_next","maxAttempts","retryInterval","attempt","fetchBody","errMsg","some","phrase","TransactionStatus","disconnected","permanentlyDisconnected","unsupportedSync","invalidDuplexStream","invalidOptions","maxEventListeners","invalidRequestArgs","invalidRequestMethod","invalidRequestParams","invalidLoggerObject","invalidLoggerMethod","connected","TORUS_BUILD_ENV","BUTTON_POSITION","supportedVerifierList","api","translations","en","embed","continue","actionRequired","pendingAction","cookiesRequired","enableCookies","clickHere","de","ja","ko","zh","prodTorusUrl","localStorageKey","hostname","loglevel","getWindowId","getTorusUrl","buildEnv","torusUrl","FEATURES_PROVIDER_CHANGE_WINDOW","height","width","FEATURES_DEFAULT_WALLET_WINDOW","FEATURES_DEFAULT_POPUP_WINDOW","FEATURES_CONFIRM_WINDOW","getPopupFeatures","w","h","dualScreenLeft","screenLeft","screenX","dualScreenTop","screenTop","screenY","innerWidth","documentElement","clientWidth","screen","innerHeight","clientHeight","left","abs","top","BaseProvider","jsonRpcStreamName","isDuplexStream","connectionStream","messages","isTorus","setMaxListeners","_handleConnect","_handleDisconnect","_handleStreamDisconnect","_rpcRequest","_initializeState","mux","pump","ignoreStream","jsonRpcConnection","createStream","rpcEngine","invalidRequest","createLoggerMiddleware","_rpcEngine","jsonRpcConnectionEvents","streamName","remoteLabel","emitter","warningMsg","listenerCount","logStreamDisconnectWarning","handleEvent","eventName","handlerArgs","handlerWrapper","documentReady","readyState","htmlToElement","html","template","createElement","trimmedHtml","trim","innerHTML","content","firstChild","PopupHandler","features","windowTimer","iClosedWindow","_setupTimer","setInterval","closed","clearInterval","open","focus","close","redirect","locationReplaceOnRedirect","replace","TorusCommunicationProvider","_state","_defaultState","dappStorageKey","languageTranslations","configuration","userLanguage","language","userLanguages","split","getUserLanguage","embedTranslations","windowRefs","isConnected","COMMUNICATION_NOTIFICATIONS","IFRAME_STATUS","isFullScreen","rid","_displayIframe","isFull","CREATE_WINDOW","windowId","_createPopupBlockAlert","CLOSE_WINDOW","_handleCloseWindow","USER_LOGGED_IN","currentLoginProvider","isLoggedIn","USER_LOGGED_OUT","isIFrameFullScreen","torusAlertContainer","torusIframe","GET_PROVIDER_STATE","initialized","_handleWindow","finalUrl","hash","handledWindow","OPENED_WINDOW","CLOSED_WINDOW","style","right","bottom","torusWidgetVisibility","buttonPosition","hideTorusButton","showTorusButton","_payload","tryWindowHandle","isRecoverable","errorMessage","isPermanentlyDisconnected","EthereumRpcError","logoUrl","getLogoUrl","torusAlert","successAlert","btnContainer","appendChild","bindOnLoad","children","attachOnLoad","hasEmittedConnection","TorusInPageProvider","selectedAddress","_handleAccountsChanged","_handleChainChanged","_handleUnlockStateChanged","PROVIDER_NOTIFICATIONS","ACCOUNTS_CHANGED","UNLOCK_STATE_CHANGED","CHAIN_CHANGED","PROVIDER_JRPC_METHODS","isUnlocked","isInternal","isEthAccounts","finalAccounts","account","dequal","imgExists","img","onload","onerror","src","getSiteName","siteName","querySelector","metaTitle","title","getSiteIcon","icon","querySelectorAll","find","_icon","Boolean","getSiteMetadata","PROVIDER_UNSAFE_METHODS","COMMUNICATION_UNSAFE_METHODS","SET_PROVIDER","isLocalStorageAvailable","storage","setItem","storageAvailable","torusIframeHtml","crossOrigin","rel","relList","supports","head","Torus","modalZIndex","isInitialized","requestedLoginProvider","alertZIndex","communicationProvider","enableLogging","network","useLocalStorage","extraParams","handleDappStorageKey","torusIframeUrl","endsWith","hashParams","URLSearchParams","append","styleLink","handleSetup","dappMetadata","contentWindow","_setupWeb3","torus","login","loginProvider","login_hint","loginWithPrivateKey","loginParams","userInfo","privateKey","success","logout","LOGOUT","cleanUp","clearInit","isElement","element","Element","Document","contains","setProvider","showWallet","path","WALLET_INSTANCE_ID","instanceId","finalPath","searchParams","walletWindow","getUserInfo","USER_INFO","userInfoResponse","initiateTopup","TOPUP","topupResponse","getAccounts","sendTransaction","serialize","requireAllSignatures","signTransaction","serializeMessage","messageOnly","parsed","parse","signature","publicKey","PublicKey","Buffer","addSignature","signAllTransactions","transactions","tx","signatures","item","idx","signMessage","getGaslessPublicKey","storedKey","getItem","generatedKey","providerParams","providerStream","communicationStream","inPageProvider","detectAccountRequestPrototypeModifier","m","originalMethod","catch","proxiedInPageProvider","deleteProperty","proxiedCommunicationProvider","LOGIN_WITH_PRIVATE_KEY","isTorusInternal","createChainIdMiddleware","createProviderConfigMiddleware","providerConfig","createConfigMiddleware","createJsonRpcClient","fetchMiddleware","networkMiddleware","requestAccounts","targetMethod","createSolanaMiddleware","providerHandlers","signAndSendTransaction","getPrivateKey","getSecretKey","createRequestAccountsMiddleware","createGetAccountsMiddleware","createGenericJRPCMiddleware","createInjectedProviderProxyMiddleware","getTorusHandlers","injectedProvider","methodNotSupported","invalidParams","txMessage","TorusInjectedProvider","CHAIN_NAMESPACES","SOLANA","switchChain","setupProvider","handleInjectedProviderUpdate","setupEngine","lookupNetwork","custom","connectedChainId","connectedHexChainId","isHexStrict","WalletInitializationError","rpcConnectionError","solanaMiddleware","injectedProviderProxy","updateProviderEngineProxy","_objectSpread","getProviderHandlers","privKey","getProviderEngineProxy","keyPairGenerator","Keypair","fromSecretKey","keyPair","toBase58","secretKey","partialSign","signedMsg","nacl","sign","detached","_providerEngineProxy","sig","txns","SolanaPrivateKeyProvider","enable","getChainSwitchMiddleware","getAccountMiddleware","updateAccount","getChainConfig","health","chainSwitchHandlers","addNewChainConfig","nativeCurrency","chainName","rpcUrls","blockExplorerUrls","addChain","ticker","symbol","tickerName","displayName","blockExplorer","switchSolanaChain","createChainSwitchMiddleware","accountHandlers","updatePrivatekey","createAccountMiddleware","providerFactory","invalidProviderConfigError","networks","providerEngineProxy","CommonPrivateKeyProvider","privKeyMiddleware","getPrivKeyMiddleware","getPrivatekey","createPrivKeyMiddleware","private_key","_Buffer","alloc","allocUnsafe","fill","isBuffer","SolanaWalletAdapter","WALLET_ADAPTERS","TORUS_SOLANA","ADAPTER_NAMESPACES","ADAPTER_CATEGORY","EXTERNAL","NOT_READY","torusWalletOptions","adapterSettings","initParams","loginSettings","solanaProvider","blockExplorerUrl","logo","torusInstance","READY","ADAPTER_EVENTS","autoConnect","rehydrated","connect","ERRORED","notReady","CONNECTING","adapter","torusInpageProvider","Web3AuthError","reconnected","connectionError","cleanup","DISCONNECTED","setAdapterSettings"],"mappings":"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","file":"static/js/9.df33dc19.chunk.js","sourcesContent":["'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n","'use strict';\n\nconst isStream = stream =>\n\tstream !== null &&\n\ttypeof stream === 'object' &&\n\ttypeof stream.pipe === 'function';\n\nisStream.writable = stream =>\n\tisStream(stream) &&\n\tstream.writable !== false &&\n\ttypeof stream._write === 'function' &&\n\ttypeof stream._writableState === 'object';\n\nisStream.readable = stream =>\n\tisStream(stream) &&\n\tstream.readable !== false &&\n\ttypeof stream._read === 'function' &&\n\ttypeof stream._readableState === 'object';\n\nisStream.duplex = stream =>\n\tisStream.writable(stream) &&\n\tisStream.readable(stream);\n\nisStream.transform = stream =>\n\tisStream.duplex(stream) &&\n\ttypeof stream._transform === 'function';\n\nmodule.exports = isStream;\n","/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (root, definition) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        define(definition);\n    } else if (typeof module === 'object' && module.exports) {\n        module.exports = definition();\n    } else {\n        root.log = definition();\n    }\n}(this, function () {\n    \"use strict\";\n\n    // Slightly dubious tricks to cut down minimized file size\n    var noop = function() {};\n    var undefinedType = \"undefined\";\n    var isIE = (typeof window !== undefinedType) && (typeof window.navigator !== undefinedType) && (\n        /Trident\\/|MSIE /.test(window.navigator.userAgent)\n    );\n\n    var logMethods = [\n        \"trace\",\n        \"debug\",\n        \"info\",\n        \"warn\",\n        \"error\"\n    ];\n\n    // Cross-browser bind equivalent that works at least back to IE6\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === 'function') {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\n                };\n            }\n        }\n    }\n\n    // Trace() doesn't print the message in IE, so for that case we need to wrap it\n    function traceForIE() {\n        if (console.log) {\n            if (console.log.apply) {\n                console.log.apply(console, arguments);\n            } else {\n                // In old IE, native console methods themselves don't have apply().\n                Function.prototype.apply.apply(console.log, [console, arguments]);\n            }\n        }\n        if (console.trace) console.trace();\n    }\n\n    // Build the best logging method possible for this env\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\n    function realMethod(methodName) {\n        if (methodName === 'debug') {\n            methodName = 'log';\n        }\n\n        if (typeof console === undefinedType) {\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (methodName === 'trace' && isIE) {\n            return traceForIE;\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, 'log');\n        } else {\n            return noop;\n        }\n    }\n\n    // These private functions always need `this` to be set properly\n\n    function replaceLoggingMethods(level, loggerName) {\n        /*jshint validthis:true */\n        for (var i = 0; i < logMethods.length; i++) {\n            var methodName = logMethods[i];\n            this[methodName] = (i < level) ?\n                noop :\n                this.methodFactory(methodName, level, loggerName);\n        }\n\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n    }\n\n    // In old IE versions, the console isn't present until you first open it.\n    // We build realMethod() replacements here that regenerate logging methods\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n        return function () {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this, level, loggerName);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n\n    // By default, we use closely bound real methods wherever possible, and\n    // otherwise we wait for a console to appear, and then try again.\n    function defaultMethodFactory(methodName, level, loggerName) {\n        /*jshint validthis:true */\n        return realMethod(methodName) ||\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n\n    function Logger(name, defaultLevel, factory) {\n      var self = this;\n      var currentLevel;\n      defaultLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\n\n      var storageKey = \"loglevel\";\n      if (typeof name === \"string\") {\n        storageKey += \":\" + name;\n      } else if (typeof name === \"symbol\") {\n        storageKey = undefined;\n      }\n\n      function persistLevelIfPossible(levelNum) {\n          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n\n          if (typeof window === undefinedType || !storageKey) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage[storageKey] = levelName;\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n          } catch (ignore) {}\n      }\n\n      function getPersistedLevel() {\n          var storedLevel;\n\n          if (typeof window === undefinedType || !storageKey) return;\n\n          try {\n              storedLevel = window.localStorage[storageKey];\n          } catch (ignore) {}\n\n          // Fallback to cookies if local storage gives us nothing\n          if (typeof storedLevel === undefinedType) {\n              try {\n                  var cookie = window.document.cookie;\n                  var location = cookie.indexOf(\n                      encodeURIComponent(storageKey) + \"=\");\n                  if (location !== -1) {\n                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n                  }\n              } catch (ignore) {}\n          }\n\n          // If the stored level is not valid, treat it as if nothing was stored.\n          if (self.levels[storedLevel] === undefined) {\n              storedLevel = undefined;\n          }\n\n          return storedLevel;\n      }\n\n      function clearPersistedLevel() {\n          if (typeof window === undefinedType || !storageKey) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage.removeItem(storageKey);\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC\";\n          } catch (ignore) {}\n      }\n\n      /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */\n\n      self.name = name;\n\n      self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\n          \"ERROR\": 4, \"SILENT\": 5};\n\n      self.methodFactory = factory || defaultMethodFactory;\n\n      self.getLevel = function () {\n          return currentLevel;\n      };\n\n      self.setLevel = function (level, persist) {\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n              level = self.levels[level.toUpperCase()];\n          }\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n              currentLevel = level;\n              if (persist !== false) {  // defaults to true\n                  persistLevelIfPossible(level);\n              }\n              replaceLoggingMethods.call(self, level, name);\n              if (typeof console === undefinedType && level < self.levels.SILENT) {\n                  return \"No console available for logging\";\n              }\n          } else {\n              throw \"log.setLevel() called with invalid level: \" + level;\n          }\n      };\n\n      self.setDefaultLevel = function (level) {\n          defaultLevel = level;\n          if (!getPersistedLevel()) {\n              self.setLevel(level, false);\n          }\n      };\n\n      self.resetLevel = function () {\n          self.setLevel(defaultLevel, false);\n          clearPersistedLevel();\n      };\n\n      self.enableAll = function(persist) {\n          self.setLevel(self.levels.TRACE, persist);\n      };\n\n      self.disableAll = function(persist) {\n          self.setLevel(self.levels.SILENT, persist);\n      };\n\n      // Initialize with the right level\n      var initialLevel = getPersistedLevel();\n      if (initialLevel == null) {\n          initialLevel = defaultLevel;\n      }\n      self.setLevel(initialLevel, false);\n    }\n\n    /*\n     *\n     * Top-level API\n     *\n     */\n\n    var defaultLogger = new Logger();\n\n    var _loggersByName = {};\n    defaultLogger.getLogger = function getLogger(name) {\n        if ((typeof name !== \"symbol\" && typeof name !== \"string\") || name === \"\") {\n          throw new TypeError(\"You must supply a name when creating a logger.\");\n        }\n\n        var logger = _loggersByName[name];\n        if (!logger) {\n          logger = _loggersByName[name] = new Logger(\n            name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n        }\n        return logger;\n    };\n\n    // Grab the current global log variable in case of overwrite\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if (typeof window !== undefinedType &&\n               window.log === defaultLogger) {\n            window.log = _log;\n        }\n\n        return defaultLogger;\n    };\n\n    defaultLogger.getLoggers = function getLoggers() {\n        return _loggersByName;\n    };\n\n    // ES6 default export, for compatibility\n    defaultLogger['default'] = defaultLogger;\n\n    return defaultLogger;\n}));\n","import { BaseAdapter, WalletLoginError, ADAPTER_STATUS, getSavedToken, checkIfTokenIsExpired, signChallenge, verifySignedChallenge, saveToken, clearToken } from '@web3auth/base';\nimport bs58 from 'bs58';\n\nclass BaseSolanaAdapter extends BaseAdapter {\n  async authenticateUser() {\n    var _this$chainConfig;\n\n    if (!this.provider || !((_this$chainConfig = this.chainConfig) !== null && _this$chainConfig !== void 0 && _this$chainConfig.chainId)) throw WalletLoginError.notConnectedError();\n    const {\n      chainNamespace,\n      chainId\n    } = this.chainConfig;\n    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.notConnectedError(\"Not connected with wallet, Please login/connect first\");\n    const accounts = await this.provider.request({\n      method: \"getAccounts\"\n    });\n\n    if (accounts && accounts.length > 0) {\n      const existingToken = getSavedToken(accounts[0], this.name);\n\n      if (existingToken) {\n        const isExpired = checkIfTokenIsExpired(existingToken);\n\n        if (!isExpired) {\n          return {\n            idToken: existingToken\n          };\n        }\n      }\n\n      const payload = {\n        domain: window.location.origin,\n        uri: window.location.href,\n        address: accounts[0],\n        chainId: parseInt(chainId, 16),\n        version: \"1\",\n        nonce: Math.random().toString(36).slice(2),\n        issuedAt: new Date().toISOString()\n      };\n      const challenge = await signChallenge(payload, chainNamespace);\n      const encodedMessage = new TextEncoder().encode(challenge);\n      const signedMessage = await this.provider.request({\n        method: \"signMessage\",\n        params: {\n          message: encodedMessage,\n          display: \"utf8\"\n        }\n      });\n      const idToken = await verifySignedChallenge(chainNamespace, bs58.encode(signedMessage), challenge, this.name, this.sessionTime);\n      saveToken(accounts[0], this.name, idToken);\n      return {\n        idToken\n      };\n    }\n\n    throw WalletLoginError.notConnectedError(\"Not connected with wallet, Please login/connect first\");\n  }\n\n  async disconnect() {\n    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.disconnectionError(\"Not connected with wallet\");\n    const accounts = await this.provider.request({\n      method: \"getAccounts\"\n    });\n\n    if (accounts && accounts.length > 0) {\n      clearToken(accounts[0], this.name);\n    }\n  }\n\n}\n\nexport { BaseSolanaAdapter };\n//# sourceMappingURL=baseSolanaAdapter.esm.js.map\n","const basex = require('base-x')\nconst ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\nmodule.exports = basex(ALPHABET)\n","'use strict'\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256)\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i)\n    var xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  var BASE = ALPHABET.length\n  var LEADER = ALPHABET.charAt(0)\n  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (source instanceof Uint8Array) {\n    } else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength)\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source)\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0\n    var length = 0\n    var pbegin = 0\n    var pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    var b58 = new Uint8Array(size)\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin]\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0\n        // Skip and count leading '1's.\n    var zeroes = 0\n    var length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size)\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)]\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n        // Skip leading zeroes in b256.\n    var it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    var vch = new Uint8Array(zeroes + (size - it4))\n    var j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nmodule.exports = base\n","import _typeof from '@babel/runtime/helpers/typeof';\nimport _classCallCheck from '@babel/runtime/helpers/classCallCheck';\nimport _createClass from '@babel/runtime/helpers/createClass';\nimport _assertThisInitialized from '@babel/runtime/helpers/assertThisInitialized';\nimport _inherits from '@babel/runtime/helpers/inherits';\nimport _possibleConstructorReturn from '@babel/runtime/helpers/possibleConstructorReturn';\nimport _getPrototypeOf from '@babel/runtime/helpers/getPrototypeOf';\nimport _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { Duplex } from 'readable-stream';\nimport _asyncToGenerator from '@babel/runtime/helpers/asyncToGenerator';\nimport _regeneratorRuntime from '@babel/runtime/regenerator';\nimport { randomId } from '@toruslabs/openlogin-utils';\nimport { EventEmitter } from 'events';\nimport _wrapNativeSuper from '@babel/runtime/helpers/wrapNativeSuper';\nimport stringify from 'fast-safe-stringify';\nimport _slicedToArray from '@babel/runtime/helpers/slicedToArray';\nimport { serializeError } from 'eth-rpc-errors';\nimport eos from 'end-of-stream';\nimport once from 'once';\nimport pump from 'pump';\n\nfunction _createSuper$6(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$6(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$6() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction noop() {\n  return undefined;\n}\nvar SYN = \"SYN\";\nvar ACK = \"ACK\";\nvar BRK = \"BRK\";\nvar BasePostMessageStream = /*#__PURE__*/function (_Duplex) {\n  _inherits(BasePostMessageStream, _Duplex);\n  var _super = _createSuper$6(BasePostMessageStream);\n  function BasePostMessageStream(_ref) {\n    var _this;\n    var name = _ref.name,\n      target = _ref.target,\n      _ref$targetWindow = _ref.targetWindow,\n      targetWindow = _ref$targetWindow === void 0 ? window : _ref$targetWindow,\n      _ref$targetOrigin = _ref.targetOrigin,\n      targetOrigin = _ref$targetOrigin === void 0 ? \"*\" : _ref$targetOrigin;\n    _classCallCheck(this, BasePostMessageStream);\n    _this = _super.call(this, {\n      objectMode: true\n    });\n    _defineProperty(_assertThisInitialized(_this), \"_init\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"_haveSyn\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"_name\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"_target\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"_targetWindow\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"_targetOrigin\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"_onMessage\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"_synIntervalId\", void 0);\n    if (!name || !target) {\n      throw new Error(\"Invalid input.\");\n    }\n    _this._init = false;\n    _this._haveSyn = false;\n    _this._name = name;\n    _this._target = target; // target origin\n    _this._targetWindow = targetWindow;\n    _this._targetOrigin = targetOrigin;\n    _this._onMessage = _this.onMessage.bind(_assertThisInitialized(_this));\n    _this._synIntervalId = null;\n    window.addEventListener(\"message\", _this._onMessage, false);\n    _this._handShake();\n    return _this;\n  }\n  _createClass(BasePostMessageStream, [{\n    key: \"_break\",\n    value: function _break() {\n      this.cork();\n      this._write(BRK, null, noop);\n      this._haveSyn = false;\n      this._init = false;\n    }\n  }, {\n    key: \"_handShake\",\n    value: function _handShake() {\n      this._write(SYN, null, noop);\n      this.cork();\n    }\n  }, {\n    key: \"_onData\",\n    value: function _onData(data) {\n      if (!this._init) {\n        // listen for handshake\n        if (data === SYN) {\n          this._haveSyn = true;\n          this._write(ACK, null, noop);\n        } else if (data === ACK) {\n          this._init = true;\n          if (!this._haveSyn) {\n            this._write(ACK, null, noop);\n          }\n          this.uncork();\n        }\n      } else if (data === BRK) {\n        this._break();\n      } else {\n        // forward message\n        try {\n          this.push(data);\n        } catch (err) {\n          this.emit(\"error\", err);\n        }\n      }\n    }\n  }, {\n    key: \"_postMessage\",\n    value: function _postMessage(data) {\n      var originConstraint = this._targetOrigin;\n      this._targetWindow.postMessage({\n        target: this._target,\n        data: data\n      }, originConstraint);\n    }\n  }, {\n    key: \"onMessage\",\n    value: function onMessage(event) {\n      var message = event.data;\n      // validate message\n      if (this._targetOrigin !== \"*\" && event.origin !== this._targetOrigin || event.source !== this._targetWindow || _typeof(message) !== \"object\" || message.target !== this._name || !message.data) {\n        return;\n      }\n      this._onData(message.data);\n    }\n  }, {\n    key: \"_read\",\n    value: function _read() {\n      return undefined;\n    }\n  }, {\n    key: \"_write\",\n    value: function _write(data, _, cb) {\n      this._postMessage(data);\n      cb();\n    }\n  }, {\n    key: \"_destroy\",\n    value: function _destroy() {\n      window.removeEventListener(\"message\", this._onMessage, false);\n    }\n  }]);\n  return BasePostMessageStream;\n}(Duplex);\n\nfunction _createSuper$5(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$5(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$5() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction safeApply(handler, context, args) {\n  try {\n    Reflect.apply(handler, context, args);\n  } catch (err) {\n    // Throw error after timeout so as not to interrupt the stack\n    setTimeout(function () {\n      throw err;\n    });\n  }\n}\nfunction arrayClone(arr) {\n  var n = arr.length;\n  var copy = new Array(n);\n  for (var i = 0; i < n; i += 1) {\n    copy[i] = arr[i];\n  }\n  return copy;\n}\nvar SafeEventEmitter = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(SafeEventEmitter, _EventEmitter);\n  var _super = _createSuper$5(SafeEventEmitter);\n  function SafeEventEmitter() {\n    _classCallCheck(this, SafeEventEmitter);\n    return _super.apply(this, arguments);\n  }\n  _createClass(SafeEventEmitter, [{\n    key: \"emit\",\n    value: function emit(type) {\n      var doError = type === \"error\";\n      var events = this._events;\n      if (events !== undefined) {\n        doError = doError && events.error === undefined;\n      } else if (!doError) {\n        return false;\n      }\n      // If there is no 'error' event listener then throw.\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n      if (doError) {\n        var er;\n        if (args.length > 0) {\n          er = args[0];\n        }\n        if (er instanceof Error) {\n          // Note: The comments on the `throw` lines are intentional, they show\n          // up in Node's output if this results in an unhandled exception.\n          throw er; // Unhandled 'error' event\n        }\n        // At least give some kind of context to the user\n        var err = new Error(\"Unhandled error.\".concat(er ? \" (\".concat(er.message, \")\") : \"\"));\n        err.context = er;\n        throw err; // Unhandled 'error' event\n      }\n\n      var handler = events[type];\n      if (handler === undefined) {\n        return false;\n      }\n      if (typeof handler === \"function\") {\n        safeApply(handler, this, args);\n      } else {\n        var len = handler.length;\n        var listeners = arrayClone(handler);\n        for (var i = 0; i < len; i += 1) {\n          safeApply(listeners[i], this, args);\n        }\n      }\n      return true;\n    }\n  }]);\n  return SafeEventEmitter;\n}(EventEmitter);\n\nfunction _createSuper$4(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$4(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$4() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nvar SerializableError = /*#__PURE__*/function (_Error) {\n  _inherits(SerializableError, _Error);\n  var _super = _createSuper$4(SerializableError);\n  function SerializableError(_ref) {\n    var _this;\n    var code = _ref.code,\n      message = _ref.message,\n      data = _ref.data;\n    _classCallCheck(this, SerializableError);\n    if (!Number.isInteger(code)) {\n      throw new Error(\"code must be an integer\");\n    }\n    if (!message || typeof message !== \"string\") {\n      throw new Error(\"message must be string\");\n    }\n    _this = _super.call(this, message);\n    _defineProperty(_assertThisInitialized(_this), \"code\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"data\", void 0);\n    _this.code = code;\n    if (data !== undefined) {\n      _this.data = data;\n    }\n    return _this;\n  }\n  _createClass(SerializableError, [{\n    key: \"toString\",\n    value: function toString() {\n      return stringify({\n        code: this.code,\n        message: this.message,\n        data: this.data,\n        stack: this.stack\n      });\n    }\n  }]);\n  return SerializableError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar getRpcPromiseCallback = function getRpcPromiseCallback(resolve, reject) {\n  var unwrapResult = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  return function (error, response) {\n    if (error || response.error) {\n      reject(error || response.error);\n    } else if (!unwrapResult || Array.isArray(response)) {\n      resolve(response);\n    } else {\n      resolve(response.result);\n    }\n  };\n};\nfunction createErrorMiddleware(log) {\n  return function (req, res, next, end) {\n    try {\n      // json-rpc-engine will terminate the request when it notices this error\n      if (typeof req.method !== \"string\" || !req.method) {\n        res.error = new SerializableError({\n          code: -32603,\n          message: \"invalid method\"\n        });\n        end();\n        return;\n      }\n      next(function (done) {\n        var error = res.error;\n        if (!error) {\n          return done();\n        }\n        log.error(\"OpenLogin - RPC Error: \".concat(error.message), error);\n        return done();\n      });\n    } catch (error) {\n      log.error(\"OpenLogin - RPC Error thrown: \".concat(error.message), error);\n      res.error = new SerializableError({\n        code: -32603,\n        message: error.message\n      });\n      end();\n    }\n  };\n}\nfunction createStreamMiddleware() {\n  var idMap = {};\n  function readNoop() {\n    return false;\n  }\n  var events = new SafeEventEmitter();\n  function processResponse(res) {\n    var context = idMap[res.id];\n    if (!context) {\n      throw new Error(\"StreamMiddleware - Unknown response id \\\"\".concat(res.id, \"\\\"\"));\n    }\n    delete idMap[res.id];\n    // copy whole res onto original res\n    Object.assign(context.res, res);\n    // run callback on empty stack,\n    // prevent internal stream-handler from catching errors\n    setTimeout(context.end);\n  }\n  function processNotification(res) {\n    events.emit(\"notification\", res);\n  }\n  function processMessage(res, _encoding, cb) {\n    var err;\n    try {\n      var isNotification = !res.id;\n      if (isNotification) {\n        processNotification(res);\n      } else {\n        processResponse(res);\n      }\n    } catch (_err) {\n      err = _err;\n    }\n    // continue processing stream\n    cb(err);\n  }\n  var stream = new Duplex({\n    objectMode: true,\n    read: readNoop,\n    write: processMessage\n  });\n  var middleware = function middleware(req, res, next, end) {\n    // write req to stream\n    stream.push(req);\n    // register request on id map\n    idMap[req.id] = {\n      req: req,\n      res: res,\n      next: next,\n      end: end\n    };\n  };\n  return {\n    events: events,\n    middleware: middleware,\n    stream: stream\n  };\n}\nfunction createScaffoldMiddleware(handlers) {\n  return function (req, res, next, end) {\n    var handler = handlers[req.method];\n    // if no handler, return\n    if (handler === undefined) {\n      return next();\n    }\n    // if handler is fn, call as middleware\n    if (typeof handler === \"function\") {\n      return handler(req, res, next, end);\n    }\n    // if handler is some other value, use as result\n    res.result = handler;\n    return end();\n  };\n}\nfunction createIdRemapMiddleware() {\n  return function (req, res, next, _end) {\n    var originalId = req.id;\n    var newId = randomId();\n    req.id = newId;\n    res.id = newId;\n    next(function (done) {\n      req.id = originalId;\n      res.id = originalId;\n      done();\n    });\n  };\n}\nfunction createLoggerMiddleware(logger) {\n  return function (req, res, next, _) {\n    logger.debug(\"REQ\", req, \"RES\", res);\n    next();\n  };\n}\nfunction createAsyncMiddleware(asyncMiddleware) {\n  return /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(req, res, next, end) {\n      var resolveNextPromise, nextPromise, returnHandlerCallback, nextWasCalled, asyncNext;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              // nextPromise is the key to the implementation\n              // it is resolved by the return handler passed to the\n              // \"next\" function\n              nextPromise = new Promise(function (resolve) {\n                resolveNextPromise = resolve;\n              });\n              returnHandlerCallback = null;\n              nextWasCalled = false; // This will be called by the consumer's async middleware.\n              asyncNext = /*#__PURE__*/function () {\n                var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n                  return _regeneratorRuntime.wrap(function _callee$(_context) {\n                    while (1) {\n                      switch (_context.prev = _context.next) {\n                        case 0:\n                          nextWasCalled = true;\n                          // We pass a return handler to next(). When it is called by the engine,\n                          // the consumer's async middleware will resume executing.\n                          next(function (runReturnHandlersCallback) {\n                            // This callback comes from JRPCEngine._runReturnHandlers\n                            returnHandlerCallback = runReturnHandlersCallback;\n                            resolveNextPromise();\n                          });\n                          _context.next = 4;\n                          return nextPromise;\n                        case 4:\n                        case \"end\":\n                          return _context.stop();\n                      }\n                    }\n                  }, _callee);\n                }));\n                return function asyncNext() {\n                  return _ref2.apply(this, arguments);\n                };\n              }();\n              _context2.prev = 4;\n              _context2.next = 7;\n              return asyncMiddleware(req, res, asyncNext);\n            case 7:\n              if (!nextWasCalled) {\n                _context2.next = 13;\n                break;\n              }\n              _context2.next = 10;\n              return nextPromise;\n            case 10:\n              // we must wait until the return handler is called\n              returnHandlerCallback(null);\n              _context2.next = 14;\n              break;\n            case 13:\n              end(null);\n            case 14:\n              _context2.next = 19;\n              break;\n            case 16:\n              _context2.prev = 16;\n              _context2.t0 = _context2[\"catch\"](4);\n              if (returnHandlerCallback) {\n                returnHandlerCallback(_context2.t0);\n              } else {\n                end(_context2.t0);\n              }\n            case 19:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, null, [[4, 16]]);\n    }));\n    return function (_x, _x2, _x3, _x4) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _createSuper$3(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$3(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$3() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n/**\n * A JSON-RPC request and response processor.\n * Give it a stack of middleware, pass it requests, and get back responses.\n */\nvar JRPCEngine = /*#__PURE__*/function (_SafeEventEmitter) {\n  _inherits(JRPCEngine, _SafeEventEmitter);\n  var _super = _createSuper$3(JRPCEngine);\n  function JRPCEngine() {\n    var _this;\n    _classCallCheck(this, JRPCEngine);\n    _this = _super.call(this);\n    _defineProperty(_assertThisInitialized(_this), \"_middleware\", void 0);\n    _this._middleware = [];\n    return _this;\n  }\n  /**\n   * Serially executes the given stack of middleware.\n   *\n   * @returns An array of any error encountered during middleware execution,\n   * a boolean indicating whether the request was completed, and an array of\n   * middleware-defined return handlers.\n   */\n  _createClass(JRPCEngine, [{\n    key: \"push\",\n    value:\n    /**\n     * Add a middleware function to the engine's middleware stack.\n     *\n     * @param middleware - The middleware function to add.\n     */\n    function push(middleware) {\n      this._middleware.push(middleware);\n    }\n  }, {\n    key: \"handle\",\n    value: function handle(req, cb) {\n      if (cb && typeof cb !== \"function\") {\n        throw new Error('\"callback\" must be a function if provided.');\n      }\n      if (Array.isArray(req)) {\n        if (cb) {\n          return this._handleBatch(req, cb);\n        }\n        return this._handleBatch(req);\n      }\n      if (cb) {\n        return this._handle(req, cb);\n      }\n      return this._promiseHandle(req);\n    }\n    /**\n     * Returns this engine as a middleware function that can be pushed to other\n     * engines.\n     *\n     * @returns This engine as a middleware function.\n     */\n  }, {\n    key: \"asMiddleware\",\n    value: function asMiddleware() {\n      var _this2 = this;\n      return /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(req, res, next, end) {\n          var _yield$JRPCEngine$_ru, _yield$JRPCEngine$_ru2, middlewareError, isComplete, returnHandlers;\n          return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  _context2.prev = 0;\n                  _context2.next = 3;\n                  return JRPCEngine._runAllMiddleware(req, res, _this2._middleware);\n                case 3:\n                  _yield$JRPCEngine$_ru = _context2.sent;\n                  _yield$JRPCEngine$_ru2 = _slicedToArray(_yield$JRPCEngine$_ru, 3);\n                  middlewareError = _yield$JRPCEngine$_ru2[0];\n                  isComplete = _yield$JRPCEngine$_ru2[1];\n                  returnHandlers = _yield$JRPCEngine$_ru2[2];\n                  if (!isComplete) {\n                    _context2.next = 12;\n                    break;\n                  }\n                  _context2.next = 11;\n                  return JRPCEngine._runReturnHandlers(returnHandlers);\n                case 11:\n                  return _context2.abrupt(\"return\", end(middlewareError));\n                case 12:\n                  return _context2.abrupt(\"return\", next( /*#__PURE__*/function () {\n                    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(handlerCallback) {\n                      return _regeneratorRuntime.wrap(function _callee$(_context) {\n                        while (1) {\n                          switch (_context.prev = _context.next) {\n                            case 0:\n                              _context.prev = 0;\n                              _context.next = 3;\n                              return JRPCEngine._runReturnHandlers(returnHandlers);\n                            case 3:\n                              _context.next = 8;\n                              break;\n                            case 5:\n                              _context.prev = 5;\n                              _context.t0 = _context[\"catch\"](0);\n                              return _context.abrupt(\"return\", handlerCallback(_context.t0));\n                            case 8:\n                              return _context.abrupt(\"return\", handlerCallback());\n                            case 9:\n                            case \"end\":\n                              return _context.stop();\n                          }\n                        }\n                      }, _callee, null, [[0, 5]]);\n                    }));\n                    return function (_x5) {\n                      return _ref2.apply(this, arguments);\n                    };\n                  }()));\n                case 15:\n                  _context2.prev = 15;\n                  _context2.t0 = _context2[\"catch\"](0);\n                  return _context2.abrupt(\"return\", end(_context2.t0));\n                case 18:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2, null, [[0, 15]]);\n        }));\n        return function (_x, _x2, _x3, _x4) {\n          return _ref.apply(this, arguments);\n        };\n      }();\n    }\n  }, {\n    key: \"_handleBatch\",\n    value: function () {\n      var _handleBatch2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(reqs, cb) {\n        var responses;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.prev = 0;\n                _context3.next = 3;\n                return Promise.all(\n                // 1. Begin executing each request in the order received\n                reqs.map(this._promiseHandle.bind(this)));\n              case 3:\n                responses = _context3.sent;\n                if (!cb) {\n                  _context3.next = 6;\n                  break;\n                }\n                return _context3.abrupt(\"return\", cb(null, responses));\n              case 6:\n                return _context3.abrupt(\"return\", responses);\n              case 9:\n                _context3.prev = 9;\n                _context3.t0 = _context3[\"catch\"](0);\n                if (!cb) {\n                  _context3.next = 13;\n                  break;\n                }\n                return _context3.abrupt(\"return\", cb(_context3.t0));\n              case 13:\n                throw _context3.t0;\n              case 14:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[0, 9]]);\n      }));\n      function _handleBatch(_x6, _x7) {\n        return _handleBatch2.apply(this, arguments);\n      }\n      return _handleBatch;\n    }()\n    /**\n     * A promise-wrapped _handle.\n     */\n  }, {\n    key: \"_promiseHandle\",\n    value: function _promiseHandle(req) {\n      var _this3 = this;\n      return new Promise(function (resolve) {\n        _this3._handle(req, function (_err, res) {\n          // There will always be a response, and it will always have any error\n          // that is caught and propagated.\n          resolve(res);\n        });\n      });\n    }\n    /**\n     * Ensures that the request object is valid, processes it, and passes any\n     * error and the response object to the given callback.\n     *\n     * Does not reject.\n     */\n  }, {\n    key: \"_handle\",\n    value: function () {\n      var _handle2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(callerReq, cb) {\n        var _error2, _error3, req, res, error;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!(!callerReq || Array.isArray(callerReq) || _typeof(callerReq) !== \"object\")) {\n                  _context4.next = 3;\n                  break;\n                }\n                _error2 = new SerializableError({\n                  code: -32603,\n                  message: \"request must be plain object\"\n                });\n                return _context4.abrupt(\"return\", cb(_error2, {\n                  id: undefined,\n                  jsonrpc: \"2.0\",\n                  error: _error2\n                }));\n              case 3:\n                if (!(typeof callerReq.method !== \"string\")) {\n                  _context4.next = 6;\n                  break;\n                }\n                _error3 = new SerializableError({\n                  code: -32603,\n                  message: \"method must be string\"\n                });\n                return _context4.abrupt(\"return\", cb(_error3, {\n                  id: callerReq.id,\n                  jsonrpc: \"2.0\",\n                  error: _error3\n                }));\n              case 6:\n                req = _objectSpread$1({}, callerReq);\n                res = {\n                  id: req.id,\n                  jsonrpc: req.jsonrpc\n                };\n                error = null;\n                _context4.prev = 9;\n                _context4.next = 12;\n                return this._processRequest(req, res);\n              case 12:\n                _context4.next = 17;\n                break;\n              case 14:\n                _context4.prev = 14;\n                _context4.t0 = _context4[\"catch\"](9);\n                // A request handler error, a re-thrown middleware error, or something\n                // unexpected.\n                error = _context4.t0;\n              case 17:\n                if (error) {\n                  // Ensure no result is present on an errored response\n                  delete res.result;\n                  if (!res.error) {\n                    res.error = serializeError(error);\n                  }\n                }\n                return _context4.abrupt(\"return\", cb(error, res));\n              case 19:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[9, 14]]);\n      }));\n      function _handle(_x8, _x9) {\n        return _handle2.apply(this, arguments);\n      }\n      return _handle;\n    }()\n    /**\n     * For the given request and response, runs all middleware and their return\n     * handlers, if any, and ensures that internal request processing semantics\n     * are satisfied.\n     */\n  }, {\n    key: \"_processRequest\",\n    value: function () {\n      var _processRequest2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(req, res) {\n        var _yield$JRPCEngine$_ru3, _yield$JRPCEngine$_ru4, error, isComplete, returnHandlers;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return JRPCEngine._runAllMiddleware(req, res, this._middleware);\n              case 2:\n                _yield$JRPCEngine$_ru3 = _context5.sent;\n                _yield$JRPCEngine$_ru4 = _slicedToArray(_yield$JRPCEngine$_ru3, 3);\n                error = _yield$JRPCEngine$_ru4[0];\n                isComplete = _yield$JRPCEngine$_ru4[1];\n                returnHandlers = _yield$JRPCEngine$_ru4[2];\n                // Throw if \"end\" was not called, or if the response has neither a result\n                // nor an error.\n                JRPCEngine._checkForCompletion(req, res, isComplete);\n                // The return handlers should run even if an error was encountered during\n                // middleware processing.\n                _context5.next = 10;\n                return JRPCEngine._runReturnHandlers(returnHandlers);\n              case 10:\n                if (!error) {\n                  _context5.next = 12;\n                  break;\n                }\n                throw error;\n              case 12:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n      function _processRequest(_x10, _x11) {\n        return _processRequest2.apply(this, arguments);\n      }\n      return _processRequest;\n    }()\n  }], [{\n    key: \"_runAllMiddleware\",\n    value: function () {\n      var _runAllMiddleware2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(req, res, middlewareStack) {\n        var returnHandlers, error, isComplete, _iterator, _step, middleware, _yield$JRPCEngine$_ru5, _yield$JRPCEngine$_ru6;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                returnHandlers = [];\n                error = null;\n                isComplete = false; // Go down stack of middleware, call and collect optional returnHandlers\n                _iterator = _createForOfIteratorHelper(middlewareStack);\n                _context6.prev = 4;\n                _iterator.s();\n              case 6:\n                if ((_step = _iterator.n()).done) {\n                  _context6.next = 18;\n                  break;\n                }\n                middleware = _step.value;\n                _context6.next = 10;\n                return JRPCEngine._runMiddleware(req, res, middleware, returnHandlers);\n              case 10:\n                _yield$JRPCEngine$_ru5 = _context6.sent;\n                _yield$JRPCEngine$_ru6 = _slicedToArray(_yield$JRPCEngine$_ru5, 2);\n                error = _yield$JRPCEngine$_ru6[0];\n                isComplete = _yield$JRPCEngine$_ru6[1];\n                if (!isComplete) {\n                  _context6.next = 16;\n                  break;\n                }\n                return _context6.abrupt(\"break\", 18);\n              case 16:\n                _context6.next = 6;\n                break;\n              case 18:\n                _context6.next = 23;\n                break;\n              case 20:\n                _context6.prev = 20;\n                _context6.t0 = _context6[\"catch\"](4);\n                _iterator.e(_context6.t0);\n              case 23:\n                _context6.prev = 23;\n                _iterator.f();\n                return _context6.finish(23);\n              case 26:\n                return _context6.abrupt(\"return\", [error, isComplete, returnHandlers.reverse()]);\n              case 27:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, null, [[4, 20, 23, 26]]);\n      }));\n      function _runAllMiddleware(_x12, _x13, _x14) {\n        return _runAllMiddleware2.apply(this, arguments);\n      }\n      return _runAllMiddleware;\n    }()\n    /**\n     * Runs an individual middleware.\n     *\n     * @returns An array of any error encountered during middleware exection,\n     * and a boolean indicating whether the request should end.\n     */\n  }, {\n    key: \"_runMiddleware\",\n    value: function _runMiddleware(req, res, middleware, returnHandlers) {\n      return new Promise(function (resolve) {\n        var end = function end(err) {\n          var error = err || res.error;\n          if (error) {\n            res.error = serializeError(error);\n          }\n          // True indicates that the request should end\n          resolve([error, true]);\n        };\n        var next = function next(returnHandler) {\n          if (res.error) {\n            end(res.error);\n          } else {\n            if (returnHandler) {\n              if (typeof returnHandler !== \"function\") {\n                end(new SerializableError({\n                  code: -32603,\n                  message: \"JRPCEngine: 'next' return handlers must be functions\"\n                }));\n              }\n              returnHandlers.push(returnHandler);\n            }\n            // False indicates that the request should not end\n            resolve([null, false]);\n          }\n        };\n        try {\n          middleware(req, res, next, end);\n        } catch (error) {\n          end(error);\n        }\n      });\n    }\n    /**\n     * Serially executes array of return handlers. The request and response are\n     * assumed to be in their scope.\n     */\n  }, {\n    key: \"_runReturnHandlers\",\n    value: function () {\n      var _runReturnHandlers2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(handlers) {\n        var _iterator2, _step2, _loop;\n        return _regeneratorRuntime.wrap(function _callee7$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _iterator2 = _createForOfIteratorHelper(handlers);\n                _context8.prev = 1;\n                _loop = /*#__PURE__*/_regeneratorRuntime.mark(function _loop() {\n                  var handler;\n                  return _regeneratorRuntime.wrap(function _loop$(_context7) {\n                    while (1) {\n                      switch (_context7.prev = _context7.next) {\n                        case 0:\n                          handler = _step2.value;\n                          _context7.next = 3;\n                          return new Promise(function (resolve, reject) {\n                            handler(function (err) {\n                              return err ? reject(err) : resolve();\n                            });\n                          });\n                        case 3:\n                        case \"end\":\n                          return _context7.stop();\n                      }\n                    }\n                  }, _loop);\n                });\n                _iterator2.s();\n              case 4:\n                if ((_step2 = _iterator2.n()).done) {\n                  _context8.next = 8;\n                  break;\n                }\n                return _context8.delegateYield(_loop(), \"t0\", 6);\n              case 6:\n                _context8.next = 4;\n                break;\n              case 8:\n                _context8.next = 13;\n                break;\n              case 10:\n                _context8.prev = 10;\n                _context8.t1 = _context8[\"catch\"](1);\n                _iterator2.e(_context8.t1);\n              case 13:\n                _context8.prev = 13;\n                _iterator2.f();\n                return _context8.finish(13);\n              case 16:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee7, null, [[1, 10, 13, 16]]);\n      }));\n      function _runReturnHandlers(_x15) {\n        return _runReturnHandlers2.apply(this, arguments);\n      }\n      return _runReturnHandlers;\n    }()\n    /**\n     * Throws an error if the response has neither a result nor an error, or if\n     * the \"isComplete\" flag is falsy.\n     */\n  }, {\n    key: \"_checkForCompletion\",\n    value: function _checkForCompletion(req, res, isComplete) {\n      if (!(\"result\" in res) && !(\"error\" in res)) {\n        throw new SerializableError({\n          code: -32603,\n          message: \"Response has no error or result for request\"\n        });\n      }\n      if (!isComplete) {\n        throw new SerializableError({\n          code: -32603,\n          message: \"Nothing ended request\"\n        });\n      }\n    }\n  }]);\n  return JRPCEngine;\n}(SafeEventEmitter);\nfunction mergeMiddleware(middlewareStack) {\n  var engine = new JRPCEngine();\n  middlewareStack.forEach(function (middleware) {\n    return engine.push(middleware);\n  });\n  return engine.asMiddleware();\n}\nfunction createEngineStream(opts) {\n  if (!opts || !opts.engine) {\n    throw new Error(\"Missing engine parameter!\");\n  }\n  var engine = opts.engine;\n  // eslint-disable-next-line prefer-const\n  var stream;\n  function read() {\n    return undefined;\n  }\n  function write(req, _encoding, cb) {\n    engine.handle(req, function (_err, res) {\n      stream.push(res);\n    });\n    cb();\n  }\n  stream = new Duplex({\n    objectMode: true,\n    read: read,\n    write: write\n  });\n  // forward notifications\n  if (engine.on) {\n    engine.on(\"notification\", function (message) {\n      stream.push(message);\n    });\n  }\n  return stream;\n}\n\nfunction _createSuper$2(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$2(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$2() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nvar Substream = /*#__PURE__*/function (_Duplex) {\n  _inherits(Substream, _Duplex);\n  var _super = _createSuper$2(Substream);\n  function Substream(_ref) {\n    var _this;\n    var parent = _ref.parent,\n      name = _ref.name;\n    _classCallCheck(this, Substream);\n    _this = _super.call(this, {\n      objectMode: true\n    });\n    _defineProperty(_assertThisInitialized(_this), \"_parent\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"_name\", void 0);\n    _this._parent = parent;\n    _this._name = name;\n    return _this;\n  }\n  /**\n   * Explicitly sets read operations to a no-op.\n   */\n  _createClass(Substream, [{\n    key: \"_read\",\n    value: function _read() {\n      return undefined;\n    }\n    /**\n     * Called when data should be written to this writable stream.\n     *\n     * @param chunk - Arbitrary object to write\n     * @param encoding - Encoding to use when writing payload\n     * @param callback - Called when writing is complete or an error occurs\n     */\n  }, {\n    key: \"_write\",\n    value: function _write(chunk, _encoding, callback) {\n      this._parent.push({\n        name: this._name,\n        data: chunk\n      });\n      callback();\n    }\n  }]);\n  return Substream;\n}(Duplex);\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$1() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nvar IGNORE_SUBSTREAM = Symbol(\"IGNORE_SUBSTREAM\");\nvar ObjectMultiplex = /*#__PURE__*/function (_Duplex) {\n  _inherits(ObjectMultiplex, _Duplex);\n  var _super = _createSuper$1(ObjectMultiplex);\n  function ObjectMultiplex() {\n    var _this;\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, ObjectMultiplex);\n    _this = _super.call(this, _objectSpread(_objectSpread({}, opts), {}, {\n      objectMode: true\n    }));\n    _defineProperty(_assertThisInitialized(_this), \"_substreams\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"getStream\", void 0);\n    _this._substreams = {};\n    return _this;\n  }\n  _createClass(ObjectMultiplex, [{\n    key: \"createStream\",\n    value: function createStream(name) {\n      // validate name\n      if (!name) {\n        throw new Error(\"ObjectMultiplex - name must not be empty\");\n      }\n      if (this._substreams[name]) {\n        throw new Error(\"ObjectMultiplex - Substream for name \\\"\".concat(name, \"\\\" already exists\"));\n      }\n      // create substream\n      var substream = new Substream({\n        parent: this,\n        name: name\n      });\n      this._substreams[name] = substream;\n      // listen for parent stream to end\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      anyStreamEnd(this, function (_error) {\n        return substream.destroy(_error || undefined);\n      });\n      return substream;\n    }\n    // ignore streams (dont display orphaned data warning)\n  }, {\n    key: \"ignoreStream\",\n    value: function ignoreStream(name) {\n      // validate name\n      if (!name) {\n        throw new Error(\"ObjectMultiplex - name must not be empty\");\n      }\n      if (this._substreams[name]) {\n        throw new Error(\"ObjectMultiplex - Substream for name \\\"\".concat(name, \"\\\" already exists\"));\n      }\n      // set\n      this._substreams[name] = IGNORE_SUBSTREAM;\n    }\n  }, {\n    key: \"_read\",\n    value: function _read() {\n      return undefined;\n    }\n  }, {\n    key: \"_write\",\n    value: function _write(chunk, _encoding, callback) {\n      var name = chunk.name,\n        data = chunk.data;\n      if (!name) {\n        window.console.warn(\"ObjectMultiplex - malformed chunk without name \\\"\".concat(chunk, \"\\\"\"));\n        return callback();\n      }\n      // get corresponding substream\n      var substream = this._substreams[name];\n      if (!substream) {\n        window.console.warn(\"ObjectMultiplex - orphaned data for stream \\\"\".concat(name, \"\\\"\"));\n        return callback();\n      }\n      // push data into substream\n      if (substream !== IGNORE_SUBSTREAM) {\n        substream.push(data);\n      }\n      return callback();\n    }\n  }]);\n  return ObjectMultiplex;\n}(Duplex);\n// util\nfunction anyStreamEnd(stream, _cb) {\n  var cb = once(_cb);\n  eos(stream, {\n    readable: false\n  }, cb);\n  eos(stream, {\n    writable: false\n  }, cb);\n}\nfunction setupMultiplex(stream) {\n  var mux = new ObjectMultiplex();\n  mux.getStream = function streamHelper(name) {\n    if (this._substreams[name]) {\n      return this._substreams[name];\n    }\n    return this.createStream(name);\n  };\n  pump(stream, mux, stream, function (err) {\n    if (err) window.console.error(err);\n  });\n  return mux;\n}\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nvar PostMessageStream = /*#__PURE__*/function (_BasePostMessageStrea) {\n  _inherits(PostMessageStream, _BasePostMessageStrea);\n  var _super = _createSuper(PostMessageStream);\n  function PostMessageStream() {\n    _classCallCheck(this, PostMessageStream);\n    return _super.apply(this, arguments);\n  }\n  _createClass(PostMessageStream, [{\n    key: \"_postMessage\",\n    value: function _postMessage(data) {\n      var originConstraint = this._targetOrigin;\n      if (_typeof(data) === \"object\") {\n        var dataObj = data;\n        if (_typeof(dataObj.data) === \"object\") {\n          var dataObjData = dataObj.data;\n          if (Array.isArray(dataObjData.params) && dataObjData.params.length > 0) {\n            var dataObjDataParam = dataObjData.params[0];\n            if (dataObjDataParam._origin) {\n              originConstraint = dataObjDataParam._origin;\n            }\n            // add a constraint for the response\n            dataObjDataParam._origin = window.location.origin;\n          }\n        }\n      }\n      this._targetWindow.postMessage({\n        target: this._target,\n        data: data\n      }, originConstraint);\n    }\n  }]);\n  return PostMessageStream;\n}(BasePostMessageStream);\n\nexport { BasePostMessageStream, IGNORE_SUBSTREAM, JRPCEngine, ObjectMultiplex, PostMessageStream, SafeEventEmitter, SerializableError, Substream, createAsyncMiddleware, createEngineStream, createErrorMiddleware, createIdRemapMiddleware, createLoggerMiddleware, createScaffoldMiddleware, createStreamMiddleware, getRpcPromiseCallback, mergeMiddleware, setupMultiplex };\n//# sourceMappingURL=openloginJrpc.esm.js.map\n",null,null,null,null,null,null,"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport merge from 'lodash.merge';\nimport logLevel, { levels } from 'loglevel';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nconst log = logLevel.getLogger(\"http-helpers\");\nlog.setLevel(levels.INFO);\nlet apiKey = \"torus-default\";\nlet embedHost = \"\"; // #region API Keys\n\nconst gatewayAuthHeader = \"x-api-key\";\nconst gatewayEmbedHostHeader = \"x-embed-host\";\nlet sentry = null;\nconst tracingOrigins = [];\nconst tracingPaths = [];\nfunction enableSentryTracing(_sentry, _tracingOrigins, _tracingPaths) {\n  sentry = _sentry;\n  tracingOrigins.push(..._tracingOrigins);\n  tracingPaths.push(..._tracingPaths);\n}\nfunction setEmbedHost(embedHost_) {\n  embedHost = embedHost_;\n}\nfunction clearEmbedHost() {\n  embedHost = \"\";\n}\nfunction getEmbedHost() {\n  return embedHost;\n}\nfunction setAPIKey(apiKey_) {\n  apiKey = apiKey_;\n}\nfunction clearAPIKey() {\n  apiKey = \"torus-default\";\n}\nfunction getAPIKey() {\n  return apiKey;\n} // #endregion\n\nfunction setLogLevel(level) {\n  log.setLevel(level);\n}\n\nasync function fetchAndTrace(url, init) {\n  let _url = null;\n\n  try {\n    _url = new URL(url);\n  } catch (error) {}\n\n  if (sentry && _url && (tracingOrigins.includes(_url.origin) || tracingPaths.includes(_url.pathname))) {\n    const transaction = sentry.startTransaction({\n      name: url\n    });\n    const span = transaction.startChild({\n      op: \"http\"\n    }); // This function returns a Span\n\n    const response = await fetch(url, init);\n    span.finish(); // Remember that only finished spans will be sent with the transaction\n\n    transaction.finish(); // Finishing the transaction will send it to Sentry\n\n    return response;\n  }\n\n  return fetch(url, init);\n}\n\nfunction getApiKeyHeaders() {\n  const headers = {};\n  if (apiKey) headers[gatewayAuthHeader] = apiKey;\n  if (embedHost) headers[gatewayEmbedHostHeader] = embedHost;\n  return headers;\n}\n\nfunction debugLogResponse(response) {\n  log.info(\"Response: \".concat(response.status, \" \").concat(response.statusText));\n  log.info(\"Url: \".concat(response.url));\n}\n\nconst promiseTimeout = (ms, promise) => {\n  const timeout = new Promise((resolve, reject) => {\n    const id = setTimeout(() => {\n      clearTimeout(id);\n      reject(new Error(\"Timed out in \".concat(ms, \"ms\")));\n    }, ms);\n  });\n  return Promise.race([promise, timeout]);\n};\nconst get = async function (url) {\n  let options_ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let customOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const defaultOptions = {\n    mode: \"cors\",\n    headers: {}\n  };\n\n  if (customOptions.useAPIKey) {\n    defaultOptions.headers = _objectSpread(_objectSpread({}, defaultOptions.headers), getApiKeyHeaders());\n  }\n\n  const options = merge(defaultOptions, options_, {\n    method: \"GET\"\n  });\n  const response = await fetchAndTrace(url, options);\n\n  if (response.ok) {\n    return response.json();\n  }\n\n  debugLogResponse(response);\n  throw response;\n};\nconst post = function (url) {\n  let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let options_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let customOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const defaultOptions = {\n    mode: \"cors\",\n    headers: {\n      \"Content-Type\": \"application/json; charset=utf-8\"\n    }\n  };\n\n  if (customOptions.useAPIKey) {\n    defaultOptions.headers = _objectSpread(_objectSpread({}, defaultOptions.headers), getApiKeyHeaders());\n  }\n\n  const options = merge(defaultOptions, options_, {\n    method: \"POST\"\n  }); // deep merge changes the structure of form data and url encoded data ,\n  // so we should not deepmerge body data\n\n  if (customOptions.isUrlEncodedData) {\n    // for multipart request browser/client will add multipart content type\n    // along with multipart boundary , so for multipart request send\n    // content-type: undefined or send with multipart boundary if already known\n    options.body = data; // If url encoded data, this must not be the content type\n\n    if (options.headers[\"Content-Type\"] === \"application/json; charset=utf-8\") delete options.headers[\"Content-Type\"];\n  } else {\n    options.body = JSON.stringify(data);\n  }\n\n  return promiseTimeout(customOptions.timeout || 60000, fetchAndTrace(url, options).then(response => {\n    if (response.ok) {\n      return response.json();\n    }\n\n    debugLogResponse(response);\n    throw response;\n  }));\n};\nconst patch = async function (url) {\n  let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let options_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let customOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const defaultOptions = {\n    mode: \"cors\",\n    headers: {\n      \"Content-Type\": \"application/json; charset=utf-8\"\n    }\n  }; // for multipart request browser/client will add multipart content type\n  // along with multipart boundary , so for multipart request send\n  // content-type: undefined or send with multipart boundary if already known\n\n  if (customOptions.useAPIKey) {\n    defaultOptions.headers = _objectSpread(_objectSpread({}, defaultOptions.headers), getApiKeyHeaders());\n  }\n\n  const options = merge(defaultOptions, options_, {\n    method: \"PATCH\"\n  }); // deep merge changes the structure of form data and url encoded data ,\n  // so we should not deepmerge body data\n\n  if (customOptions.isUrlEncodedData) {\n    // for multipart request browser/client will add multipart content type\n    // along with multipart boundary , so for multipart request send\n    // content-type: undefined or send with multipart boundary if already known\n    options.body = data; // If url encoded data, this must not be the content type\n\n    if (options.headers[\"Content-Type\"] === \"application/json; charset=utf-8\") delete options.headers[\"Content-Type\"];\n  } else {\n    options.body = JSON.stringify(data);\n  }\n\n  const response = await fetchAndTrace(url, options);\n\n  if (response.ok) {\n    return response.json();\n  }\n\n  debugLogResponse(response);\n  throw response;\n};\nconst put = async function (url) {\n  let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let options_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let customOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const defaultOptions = {\n    mode: \"cors\",\n    headers: {\n      \"Content-Type\": \"application/json; charset=utf-8\"\n    }\n  }; // for multipart request browser/client will add multipart content type\n  // along with multipart boundary , so for multipart request send\n  // content-type: undefined or send with multipart boundary if already known\n\n  if (customOptions.useAPIKey) {\n    defaultOptions.headers = _objectSpread(_objectSpread({}, defaultOptions.headers), getApiKeyHeaders());\n  }\n\n  const options = merge(defaultOptions, options_, {\n    method: \"PUT\"\n  }); // deep merge changes the structure of form data and url encoded data ,\n  // so we should not deepmerge body data\n\n  if (customOptions.isUrlEncodedData) {\n    // for multipart request browser/client will add multipart content type\n    // along with multipart boundary , so for multipart request send\n    // content-type: undefined or send with multipart boundary if already known\n    options.body = data; // If url encoded data, this must not be the content type\n\n    if (options.headers[\"Content-Type\"] === \"application/json; charset=utf-8\") delete options.headers[\"Content-Type\"];\n  } else {\n    options.body = JSON.stringify(data);\n  }\n\n  const response = await fetchAndTrace(url, options);\n\n  if (response.ok) {\n    return response.json();\n  }\n\n  debugLogResponse(response);\n  throw response;\n};\nconst remove = async function (url) {\n  let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let options_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let customOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const defaultOptions = {\n    mode: \"cors\",\n    headers: {\n      \"Content-Type\": \"application/json; charset=utf-8\"\n    }\n  }; // for multipart request browser/client will add multipart content type\n  // along with multipart boundary , so for multipart request send\n  // content-type: undefined or send with multipart boundary if already known\n\n  if (customOptions.useAPIKey) {\n    defaultOptions.headers = _objectSpread(_objectSpread({}, defaultOptions.headers), getApiKeyHeaders());\n  }\n\n  const options = merge(defaultOptions, options_, {\n    method: \"DELETE\"\n  });\n\n  if (customOptions.isUrlEncodedData) {\n    // for multipart request browser/client will add multipart content type\n    // along with multipart boundary , so for multipart request send\n    // content-type: undefined or send with multipart boundary if already known\n    options.body = data; // If url encoded data, this must not be the content type\n\n    if (options.headers[\"Content-Type\"] === \"application/json; charset=utf-8\") delete options.headers[\"Content-Type\"];\n  } else {\n    options.body = JSON.stringify(data);\n  }\n\n  const response = await fetchAndTrace(url, options);\n\n  if (response.ok) {\n    return response.json();\n  }\n\n  debugLogResponse(response);\n  throw response;\n};\nconst generateJsonRPCObject = (method, parameters) => ({\n  jsonrpc: \"2.0\",\n  method,\n  id: 10,\n  params: parameters\n});\nconst promiseRace = function (url, options) {\n  let timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 60000;\n  return Promise.race([get(url, options), new Promise((resolve, reject) => {\n    setTimeout(() => {\n      reject(new Error(\"timed out\"));\n    }, timeout);\n  })]);\n};\n\nexport { clearAPIKey, clearEmbedHost, enableSentryTracing, gatewayAuthHeader, gatewayEmbedHostHeader, generateJsonRPCObject, get, getAPIKey, getEmbedHost, patch, post, promiseRace, promiseTimeout, put, remove, setAPIKey, setEmbedHost, setLogLevel };\n//# sourceMappingURL=httpHelpers.esm.js.map\n","import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { SafeEventEmitter, JRPCEngine, createAsyncMiddleware, mergeMiddleware, createScaffoldMiddleware } from '@toruslabs/openlogin-jrpc';\nimport { serializeError, ethErrors } from 'eth-rpc-errors';\nimport getCreateRandomId from 'json-rpc-random-id';\nimport { BigNumber } from 'bignumber.js';\nimport { fromSigned, bufferToInt, toUnsigned, stripHexPrefix, addHexPrefix, hashPersonalMessage, ecsign, intToBuffer } from 'ethereumjs-util';\nimport log from 'loglevel';\nimport { BroadcastChannel } from '@toruslabs/broadcast-channel';\nimport { get, post, patch, remove } from '@toruslabs/http-helpers';\nimport bowser from 'bowser';\nimport { cloneDeep, pickBy, omitBy } from 'lodash';\n\nfunction ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$3(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n/**\n * Controller class that provides configuration, state management, and subscriptions\n */\n\nclass BaseController extends SafeEventEmitter {\n  /**\n   * Default options used to configure this controller\n   */\n\n  /**\n   * Default state set on this controller\n   */\n\n  /**\n   * Determines if listeners are notified of state changes\n   */\n\n  /**\n   * Name of this controller used during composition\n   */\n\n  /**\n   * Creates a BaseController instance. Both initial state and initial\n   * configuration options are merged with defaults upon initialization.\n   *\n   * @param config - Initial options used to configure this controller\n   * @param state - Initial state to set on this controller\n   */\n  constructor(_ref) {\n    let {\n      config = {},\n      state = {}\n    } = _ref;\n    super(); // Use assign since generics can't be spread: https://git.io/vpRhY\n\n    _defineProperty(this, \"defaultConfig\", {});\n\n    _defineProperty(this, \"defaultState\", {});\n\n    _defineProperty(this, \"disabled\", false);\n\n    _defineProperty(this, \"name\", \"BaseController\");\n\n    _defineProperty(this, \"initialConfig\", void 0);\n\n    _defineProperty(this, \"initialState\", void 0);\n\n    _defineProperty(this, \"internalConfig\", this.defaultConfig);\n\n    _defineProperty(this, \"internalState\", this.defaultState);\n\n    this.initialState = state;\n    this.initialConfig = config;\n  }\n  /**\n   * Retrieves current controller configuration options\n   *\n   * @returns - Current configuration\n   */\n\n\n  get config() {\n    return this.internalConfig;\n  }\n  /**\n   * Retrieves current controller state\n   *\n   * @returns - Current state\n   */\n\n\n  get state() {\n    return this.internalState;\n  }\n  /**\n   * Updates controller configuration\n   *\n   * @param config - New configuration options\n   * @param overwrite - Overwrite config instead of merging\n   * @param fullUpdate - Boolean that defines if the update is partial or not\n   */\n\n\n  configure(config) {\n    let overwrite = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let fullUpdate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n    if (fullUpdate) {\n      this.internalConfig = overwrite ? config : Object.assign(this.internalConfig, config);\n\n      for (const key in this.internalConfig) {\n        if (typeof this.internalConfig[key] !== \"undefined\") {\n          this[key] = this.internalConfig[key];\n        }\n      }\n    } else {\n      for (const key in config) {\n        /* istanbul ignore else */\n        if (typeof this.internalConfig[key] !== \"undefined\") {\n          this.internalConfig[key] = config[key];\n          this[key] = config[key];\n        }\n      }\n    }\n  }\n  /**\n   * Updates controller state\n   *\n   * @param state - New state\n   * @param overwrite - Overwrite state instead of merging\n   */\n\n\n  update(state) {\n    let overwrite = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    this.internalState = overwrite ? _objectSpread$3({}, state) : _objectSpread$3(_objectSpread$3({}, this.internalState), state);\n    this.emit(\"store\", this.internalState);\n  }\n  /**\n   * Enables the controller. This sets each config option as a member\n   * variable on this instance and triggers any defined setters. This\n   * also sets initial state and triggers any listeners.\n   *\n   * @returns - This controller instance\n   */\n\n\n  initialize() {\n    this.internalState = this.defaultState;\n    this.internalConfig = this.defaultConfig;\n    this.configure(this.initialConfig);\n    this.update(this.initialState);\n    return this;\n  }\n\n}\n\nconst sec = 1000;\n\nconst calculateSum = (accumulator, currentValue) => accumulator + currentValue;\n\nconst blockTrackerEvents = [\"sync\", \"latest\"];\nclass BaseBlockTracker extends BaseController {\n  constructor(_ref) {\n    let {\n      config = {},\n      state = {}\n    } = _ref;\n    super({\n      config,\n      state\n    }); // config\n\n    _defineProperty(this, \"name\", \"BaseBlockTracker\");\n\n    _defineProperty(this, \"_blockResetTimeout\", void 0);\n\n    this.defaultState = {\n      _currentBlock: {\n        idempotencyKey: \"\"\n      },\n      _isRunning: false\n    };\n    this.defaultConfig = {\n      blockResetDuration: 20 * sec\n    };\n    this.initialize(); // bind functions for internal use\n\n    this._onNewListener = this._onNewListener.bind(this);\n    this._onRemoveListener = this._onRemoveListener.bind(this);\n    this._resetCurrentBlock = this._resetCurrentBlock.bind(this); // listen for handler changes\n\n    this._setupInternalEvents();\n  }\n\n  isRunning() {\n    return this.state._isRunning;\n  }\n\n  getCurrentBlock() {\n    return this.state._currentBlock;\n  }\n\n  async getLatestBlock() {\n    // return if available\n    if (this.state._currentBlock) {\n      return this.state._currentBlock;\n    } // wait for a new latest block\n\n\n    const latestBlock = await new Promise(resolve => this.once(\"latest\", newState => {\n      if (newState._currentBlock) {\n        resolve(newState._currentBlock);\n      }\n    })); // return newly set current block\n\n    return latestBlock;\n  } // dont allow module consumer to remove our internal event listeners\n\n\n  removeAllListeners(eventName) {\n    if (eventName) {\n      super.removeAllListeners(eventName);\n    } else {\n      super.removeAllListeners();\n    } // re-add internal events\n\n\n    this._setupInternalEvents(); // trigger stop check just in case\n\n\n    this._onRemoveListener();\n\n    return this;\n  }\n  /**\n   * To be implemented in subclass.\n   */\n\n\n  _start() {// default behavior is noop\n  }\n  /**\n   * To be implemented in subclass.\n   */\n\n\n  _end() {// default behavior is noop\n  }\n\n  _newPotentialLatest(newBlock) {\n    const currentBlock = this.state._currentBlock; // only update if blok number is higher\n\n    if (currentBlock && newBlock.idempotencyKey === currentBlock.idempotencyKey) {\n      return;\n    }\n\n    this._setCurrentBlock(newBlock);\n  }\n\n  _setupInternalEvents() {\n    // first remove listeners for idempotency\n    this.removeListener(\"newListener\", this._onNewListener);\n    this.removeListener(\"removeListener\", this._onRemoveListener); // then add them\n\n    this.on(\"removeListener\", this._onRemoveListener);\n    this.on(\"newListener\", this._onNewListener);\n  }\n\n  _onNewListener() {\n    this._maybeStart();\n  }\n\n  _onRemoveListener() {\n    // `removeListener` is called *after* the listener is removed\n    if (this._getBlockTrackerEventCount() > 0) {\n      return;\n    }\n\n    this._maybeEnd();\n  }\n\n  _maybeStart() {\n    if (this.state._isRunning) {\n      return;\n    }\n\n    this.state._isRunning = true; // cancel setting latest block to stale\n\n    this._cancelBlockResetTimeout();\n\n    this._start();\n  }\n\n  _maybeEnd() {\n    if (!this.state._isRunning) {\n      return;\n    }\n\n    this.state._isRunning = false;\n\n    this._setupBlockResetTimeout();\n\n    this._end();\n  }\n\n  _getBlockTrackerEventCount() {\n    return blockTrackerEvents.map(eventName => this.listenerCount(eventName)).reduce(calculateSum);\n  }\n\n  _setCurrentBlock(newBlock) {\n    const oldBlock = this.state._currentBlock;\n    this.update({\n      _currentBlock: newBlock\n    });\n    this.emit(\"latest\", newBlock);\n    this.emit(\"sync\", {\n      oldBlock,\n      newBlock\n    });\n  }\n\n  _setupBlockResetTimeout() {\n    // clear any existing timeout\n    this._cancelBlockResetTimeout(); // clear latest block when stale\n\n\n    this._blockResetTimeout = setTimeout(this._resetCurrentBlock, this.config.blockResetDuration); // nodejs - dont hold process open\n\n    if (this._blockResetTimeout.unref) {\n      this._blockResetTimeout.unref();\n    }\n  }\n\n  _cancelBlockResetTimeout() {\n    if (this._blockResetTimeout) {\n      clearTimeout(this._blockResetTimeout);\n    }\n  }\n\n  _resetCurrentBlock() {\n    this.update({\n      _currentBlock: {\n        idempotencyKey: \"\"\n      }\n    });\n  }\n\n}\n\nconst filterNoop = () => true;\n\nconst internalEvents = [\"newListener\", \"removeListener\"];\n\nconst externalEventFilter = name => !internalEvents.includes(name);\n\nfunction getRawListeners(eventEmitter, name) {\n  // prefer native\n  return eventEmitter.rawListeners(name);\n}\n\nfunction createEventEmitterProxy(initialTarget, opts) {\n  // parse options\n  const finalOpts = opts || {};\n  let eventFilter = finalOpts.eventFilter || filterNoop;\n  if (typeof eventFilter === \"string\" && eventFilter === \"skipInternal\") eventFilter = externalEventFilter;\n  if (typeof eventFilter !== \"function\") throw new Error(\"createEventEmitterProxy - Invalid eventFilter\");\n  let target = initialTarget;\n\n  let setTarget = newTarget => {\n    const oldTarget = target;\n    target = newTarget;\n    oldTarget.eventNames().filter(eventFilter).forEach(name => {\n      getRawListeners(oldTarget, name).forEach(handler => newTarget.on(name, handler));\n    }); // remove old listeners\n\n    oldTarget.removeAllListeners();\n  };\n\n  const proxy = new Proxy({}, {\n    get: (_, name) => {\n      // override `setTarget` access\n      if (name === \"setTarget\") return setTarget;\n      return target[name];\n    },\n    set: (_, name, value) => {\n      // allow `setTarget` overrides\n      if (name === \"setTarget\") {\n        setTarget = value;\n        return true;\n      }\n\n      target[name] = value;\n      return true;\n    }\n  });\n  return proxy;\n}\n\nfunction createSwappableProxy(initialTarget) {\n  let target = initialTarget;\n\n  let setTarget = newTarget => {\n    target = newTarget;\n  };\n\n  const proxy = new Proxy({}, {\n    get: (_, name) => {\n      // override `setTarget` access\n      if (name === \"setTarget\") return setTarget;\n      return target[name];\n    },\n    set: (_, name, value) => {\n      // allow `setTarget` overrides\n      if (name === \"setTarget\") {\n        setTarget = value;\n        return true;\n      }\n\n      target[name] = value;\n      return true;\n    }\n  });\n  return proxy;\n}\n\nconst POLLING_INTERVAL = 600000;\nclass BaseCurrencyController extends BaseController {\n  constructor(_ref) {\n    let {\n      config = {},\n      state\n    } = _ref;\n    super({\n      config,\n      state\n    });\n    this.defaultState = {\n      currentCurrency: \"usd\",\n      conversionRate: 0,\n      conversionDate: \"N/A\",\n      nativeCurrency: \"ETH\"\n    };\n    this.defaultConfig = {\n      pollInterval: POLLING_INTERVAL\n    };\n    this.initialize();\n  } //\n  // PUBLIC METHODS\n  //\n\n\n  getNativeCurrency() {\n    return this.state.nativeCurrency;\n  }\n\n  setNativeCurrency(nativeCurrency) {\n    this.update({\n      nativeCurrency,\n      ticker: nativeCurrency\n    });\n  }\n\n  getCurrentCurrency() {\n    return this.state.currentCurrency;\n  }\n\n  setCurrentCurrency(currentCurrency) {\n    this.update({\n      currentCurrency\n    });\n  }\n  /**\n   * A getter for the conversionRate property\n   *\n   * @returns The conversion rate from ETH to the selected currency.\n   *\n   */\n\n\n  getConversionRate() {\n    return this.state.conversionRate;\n  }\n\n  setConversionRate(conversionRate) {\n    this.update({\n      conversionRate\n    });\n  }\n  /**\n   * A getter for the conversionDate property\n   *\n   * @returns The date at which the conversion rate was set. Expressed in milliseconds since midnight of\n   * January 1, 1970\n   *\n   */\n\n\n  getConversionDate() {\n    return this.state.conversionDate;\n  }\n\n  setConversionDate(conversionDate) {\n    this.update({\n      conversionDate\n    });\n  }\n\n}\n\nfunction ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nconst createRandomId = getCreateRandomId();\nfunction providerFromEngine(engine) {\n  const provider = new SafeEventEmitter(); // handle both rpc send methods\n\n  provider.sendAsync = async req => {\n    const res = await engine.handle(req);\n\n    if (res.error) {\n      var _res$error, _res$error2;\n\n      const err = serializeError(res.error, {\n        fallbackError: {\n          message: ((_res$error = res.error) === null || _res$error === void 0 ? void 0 : _res$error.message) || res.error.toString(),\n          code: ((_res$error2 = res.error) === null || _res$error2 === void 0 ? void 0 : _res$error2.code) || -32603\n        }\n      });\n      throw ethErrors.rpc.internal(err);\n    }\n\n    return res.result;\n  }; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  provider.send = (req, callback) => {\n    if (typeof callback !== \"function\") {\n      throw new Error('Must provide callback to \"send\" method.');\n    }\n\n    engine.handle(req, callback);\n  }; // forward notifications\n\n\n  if (engine.on) {\n    engine.on(\"notification\", message => {\n      provider.emit(\"data\", null, message);\n    });\n  }\n\n  provider.request = async args => {\n    const req = _objectSpread$2(_objectSpread$2({}, args), {}, {\n      id: createRandomId(),\n      jsonrpc: \"2.0\"\n    });\n\n    const res = await provider.sendAsync(req);\n    return res;\n  };\n\n  return provider;\n}\nfunction providerFromMiddleware(middleware) {\n  const engine = new JRPCEngine();\n  engine.push(middleware);\n  const provider = providerFromEngine(engine);\n  return provider;\n}\nfunction providerAsMiddleware(provider) {\n  return async (req, res, _next, end) => {\n    // send request to provider\n    try {\n      const providerRes = await provider.sendAsync(req);\n      res.result = providerRes;\n      return end();\n    } catch (error) {\n      return end(error.message);\n    }\n  };\n}\n\nconst FEATURES_PROVIDER_CHANGE_WINDOW = {\n  height: 660,\n  width: 375\n};\nconst FEATURES_DEFAULT_WALLET_WINDOW = {\n  height: 740,\n  width: 1315\n};\nconst FEATURES_DEFAULT_POPUP_WINDOW = {\n  height: 700,\n  width: 1200\n};\nconst FEATURES_CONFIRM_WINDOW = {\n  height: 700,\n  width: 450\n};\nconst POPUP_LOADED = \"popup_loaded\";\nconst POPUP_RESULT = \"popup_result\";\nconst SETUP_COMPLETE = \"setup_complete\";\nconst ACTIVITY_ACTION_ALL = \"walletActivity.allTransactions\";\nconst ACTIVITY_ACTION_SEND = \"walletActivity.send\";\nconst ACTIVITY_ACTION_BURN = \"walletActivity.burn\";\nconst ACTIVITY_ACTION_RECEIVE = \"walletActivity.receive\";\nconst ACTIVITY_ACTION_TOPUP = \"walletActivity.topup\";\nconst ACTIVITY_PERIOD_ALL = \"walletActivity.all\";\nconst ACTIVITY_PERIOD_WEEK_ONE = \"walletActivity.lastOneWeek\";\nconst ACTIVITY_PERIOD_MONTH_ONE = \"walletActivity.lastOneMonth\";\nconst ACTIVITY_PERIOD_MONTH_SIX = \"walletActivity.lastSixMonts\";\nconst ACTIVITY_STATUS_SUCCESSFUL = \"walletActivity.successful\";\nconst ACTIVITY_STATUS_UNSUCCESSFUL = \"walletActivity.unsuccessful\";\nconst ACTIVITY_STATUS_PENDING = \"walletActivity.pending\";\nconst ACTIVITY_STATUS_CANCELLED = \"walletActivity.cancelled\";\nconst ACTIVITY_STATUS_CANCELLING = \"walletActivity.cancelling\";\nconst COMMUNICATION_NOTIFICATIONS = {\n  IFRAME_STATUS: \"iframe_status\",\n  // Tell embed to create the window\n  CREATE_WINDOW: \"create_window\",\n  // Tell embed to close the window\n  CLOSE_WINDOW: \"close_window\",\n  USER_LOGGED_IN: \"user_logged_in\",\n  USER_LOGGED_OUT: \"user_logged_out\"\n};\nconst COMMUNICATION_JRPC_METHODS = {\n  LOGOUT: \"logout\",\n  WALLET_INSTANCE_ID: \"wallet_instance_id\",\n  USER_INFO: \"user_info\",\n  SET_PROVIDER: \"set_provider\",\n  TOPUP: \"topup\",\n  IFRAME_STATUS: \"iframe_status\",\n  // embed has opened the window as requested\n  OPENED_WINDOW: \"opened_window\",\n  // user has closed the window from embed's side\n  CLOSED_WINDOW: \"closed_window\",\n  GET_PROVIDER_STATE: \"get_provider_state\",\n  LOGIN_WITH_PRIVATE_KEY: \"login_with_private_key\"\n};\nconst PROVIDER_JRPC_METHODS = {\n  GET_PROVIDER_STATE: \"wallet_get_provider_state\"\n};\nconst PROVIDER_NOTIFICATIONS = {\n  ACCOUNTS_CHANGED: \"wallet_accounts_changed\",\n  CHAIN_CHANGED: \"wallet_chain_changed\",\n  UNLOCK_STATE_CHANGED: \"wallet_unlock_state_changed\"\n};\nconst BROADCAST_CHANNELS = {\n  REDIRECT_CHANNEL: \"redirect_channel\",\n  PROVIDER_CHANGE_CHANNEL: \"torus_provider_change_channel\",\n  TRANSACTION_CHANNEL: \"torus_channel\",\n  MESSAGE_CHANNEL: \"torus_message_channel\",\n  WALLET_LOGOUT_CHANNEL: \"wallet_logout_channel\",\n  WALLET_SELECTED_ADDRESS_CHANNEL: \"wallet_selected_address_channel\",\n  WALLET_NETWORK_CHANGE_CHANNEL: \"wallet_network_change_channel\",\n  WALLET_ACCOUNT_IMPORT_CHANNEL: \"wallet_account_import_channel\",\n  THEME_CHANGE: \"theme_change_channel\"\n};\nconst BROADCAST_CHANNELS_MSGS = {\n  LOGOUT: \"logout\",\n  ACCOUNT_IMPORTED: \"account_imported\",\n  SELECTED_ADDRESS_CHANGE: \"selected_address_change\",\n  NETWORK_CHANGE: \"network_change\",\n  SET_THEME: \"set_theme\"\n};\n\nfunction createChangeProviderMiddlewareMiddleware(_ref) {\n  let {\n    changeProvider\n  } = _ref;\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== COMMUNICATION_JRPC_METHODS.SET_PROVIDER) return next();\n    if (!changeProvider) throw new Error(\"CommunicationMiddleware - opts.changeProvider not provided\");\n    response.result = await changeProvider(request);\n  });\n}\nfunction createTopupMiddleware(_ref2) {\n  let {\n    topup\n  } = _ref2;\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== COMMUNICATION_JRPC_METHODS.TOPUP) return next();\n    if (!topup) throw new Error(\"CommunicationMiddleware - opts.topup not provided\");\n    response.result = await topup(request);\n  });\n}\nfunction createGenericJRPCMiddleware(targetMethod, handler) {\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== targetMethod) return next();\n    if (!handler) throw new Error(\"CommunicationMiddleware - \".concat(targetMethod, \" not provided\"));\n    const result = await handler(request);\n\n    if (!result) {\n      return next();\n    }\n\n    response.result = result;\n    return undefined;\n  });\n}\nfunction createCommunicationMiddleware(providerHandlers) {\n  const {\n    getUserInfo,\n    getWalletInstanceId,\n    topup,\n    logout,\n    changeProvider,\n    setIFrameStatus,\n    handleWindowRpc,\n    getProviderState,\n    loginWithPrivateKey\n  } = providerHandlers;\n  return mergeMiddleware([createChangeProviderMiddlewareMiddleware({\n    changeProvider\n  }), createTopupMiddleware({\n    topup\n  }), createScaffoldMiddleware({\n    [COMMUNICATION_JRPC_METHODS.LOGOUT]: logout,\n    [COMMUNICATION_JRPC_METHODS.WALLET_INSTANCE_ID]: getWalletInstanceId,\n    [COMMUNICATION_JRPC_METHODS.USER_INFO]: getUserInfo,\n    [COMMUNICATION_JRPC_METHODS.IFRAME_STATUS]: setIFrameStatus,\n    // Do this in the orchestrator because communicationWindowManager needs to be passed into PopupHandlers\n    [COMMUNICATION_JRPC_METHODS.OPENED_WINDOW]: handleWindowRpc,\n    [COMMUNICATION_JRPC_METHODS.CLOSED_WINDOW]: handleWindowRpc,\n    [COMMUNICATION_JRPC_METHODS.GET_PROVIDER_STATE]: getProviderState\n  }), createGenericJRPCMiddleware(COMMUNICATION_JRPC_METHODS.LOGIN_WITH_PRIVATE_KEY, loginWithPrivateKey)]);\n}\n\nclass BaseEmbedController extends BaseController {\n  constructor(_ref) {\n    let {\n      config = {},\n      state\n    } = _ref;\n    super({\n      config,\n      state\n    });\n\n    _defineProperty(this, \"_communicationProviderProxy\", void 0);\n\n    this.defaultState = {\n      buttonPosition: \"bottom-right\",\n      isIFrameFullScreen: true,\n      apiKey: \"torus-default\",\n      oauthModalVisibility: false,\n      loginInProgress: false,\n      dappMetadata: {\n        name: \"\",\n        icon: \"\"\n      }\n    };\n    this.initialize();\n  }\n  /**\n   * Called by orchestrator once while initializing the class\n   * @param handlers - JRPC handlers for provider\n   * @returns - provider - Returns the providerProxy\n   */\n\n\n  initializeProvider(handlers) {\n    const engine = new JRPCEngine();\n    const communicationMiddleware = createCommunicationMiddleware(handlers);\n    engine.push(communicationMiddleware);\n    const communicationProvider = providerFromEngine(engine);\n    this.setCommunicationProvider(communicationProvider);\n  }\n\n  setCommunicationProvider(communicationProvider) {\n    if (this._communicationProviderProxy) {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      this._communicationProviderProxy.setTarget(communicationProvider);\n    } else {\n      this._communicationProviderProxy = createSwappableProxy(communicationProvider);\n    }\n  }\n\n}\n\nclass CommunicationWindowManager extends SafeEventEmitter {\n  constructor() {\n    super(...arguments);\n\n    _defineProperty(this, \"handleWindowRpc\", (request, response, next, end) => {\n      const {\n        method,\n        params\n      } = request;\n\n      if (method === COMMUNICATION_JRPC_METHODS.OPENED_WINDOW) {\n        const {\n          windowId\n        } = params; // I've been informed that a window has been opened\n\n        this.emit(\"\".concat(windowId, \":opened\"));\n        response.result = true;\n        end();\n      } else if (method === COMMUNICATION_JRPC_METHODS.CLOSED_WINDOW) {\n        const {\n          windowId\n        } = params; // I've been informed that a window has been closed\n\n        this.emit(\"\".concat(windowId, \":closed\"));\n        response.result = true;\n        end();\n      } else {\n        next();\n      }\n    });\n  }\n\n}\n\nconst LOGIN_PROVIDER = {\n  GOOGLE: \"google\",\n  FACEBOOK: \"facebook\",\n  REDDIT: \"reddit\",\n  DISCORD: \"discord\",\n  TWITCH: \"twitch\",\n  APPLE: \"apple\",\n  LINE: \"line\",\n  GITHUB: \"github\",\n  KAKAO: \"kakao\",\n  LINKEDIN: \"linkedin\",\n  TWITTER: \"twitter\",\n  WEIBO: \"weibo\",\n  WECHAT: \"wechat\",\n  EMAIL_PASSWORDLESS: \"email_passwordless\"\n};\nconst PAYMENT_PROVIDER = {\n  MOONPAY: \"moonpay\",\n  WYRE: \"wyre\",\n  RAMPNETWORK: \"rampnetwork\",\n  XANPOOL: \"xanpool\",\n  MERCURYO: \"mercuryo\",\n  TRANSAK: \"transak\"\n};\n\nconst getTxStatusText = txStatus => {\n  switch (txStatus) {\n    case \"rejected\":\n    case \"unapproved\":\n    case \"failed\":\n      return ACTIVITY_STATUS_UNSUCCESSFUL;\n\n    case \"confirmed\":\n      return ACTIVITY_STATUS_SUCCESSFUL;\n\n    case \"submitted\":\n      return ACTIVITY_STATUS_PENDING;\n\n    case \"cancelled\":\n      return ACTIVITY_STATUS_CANCELLED;\n\n    default:\n      return \"\";\n  }\n};\n\n/**\n * General utility functions\n */\n\nfunction intToHex(i) {\n  const hex = i.toString(16);\n  return \"0x\".concat(hex);\n}\n/**\n * Returns a random number. Don't use for cryptographic purposes.\n * @returns a random number\n */\n\nconst randomId = () => Math.random().toString(36).slice(2);\n/**\n * Pads the front of the given hex string with zeroes until it reaches the\n * target length. If the input string is already longer than or equal to the\n * target length, it is returned unmodified.\n *\n * If the input string is \"0x\"-prefixed or not a hex string, an error will be\n * thrown.\n *\n * @param hexString - The hexadecimal string to pad with zeroes.\n * @param targetLength - The target length of the hexadecimal string.\n * @returns The input string front-padded with zeroes, or the original string\n * if it was already greater than or equal to to the target length.\n */\n\nfunction padWithZeroes(hexString, targetLength) {\n  if (hexString !== \"\" && !/^[a-f0-9]+$/iu.test(hexString)) {\n    throw new Error(\"Expected an unprefixed hex string. Received: \".concat(hexString));\n  }\n\n  if (targetLength < 0) {\n    throw new Error(\"Expected a non-negative integer target length. Received: \".concat(targetLength));\n  }\n\n  return String.prototype.padStart.call(hexString, targetLength, \"0\");\n}\n/**\n * Concatenate an extended ECDSA signature into a hex string.\n *\n * @param v - The 'v' portion of the signature.\n * @param r - The 'r' portion of the signature.\n * @param s - The 's' portion of the signature.\n * @returns The concatenated ECDSA signature.\n */\n\nfunction concatSig(v, r, s) {\n  const rSig = fromSigned(r);\n  const sSig = fromSigned(s);\n  const vSig = bufferToInt(v);\n  const rStr = padWithZeroes(toUnsigned(rSig).toString(\"hex\"), 64);\n  const sStr = padWithZeroes(toUnsigned(sSig).toString(\"hex\"), 64);\n  const vStr = stripHexPrefix(intToHex(vSig));\n  return addHexPrefix(rStr.concat(sStr, vStr));\n}\nfunction timeout$1(duration) {\n  return new Promise(resolve => {\n    const timeoutRef = window.setTimeout(() => {\n      resolve();\n      window.clearTimeout(timeoutRef);\n    }, duration);\n  });\n}\nconst getHeaders = jwt => {\n  return {\n    headers: {\n      Authorization: \"Bearer \".concat(jwt),\n      \"Content-Type\": \"application/json; charset=utf-8\"\n    }\n  };\n};\n/**\n * Text/number formatting utilities\n */\n\nconst formatSmallNumbers = function (number) {\n  let currency = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"usd\";\n  let noTilde = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  const finalNumber = BigNumber.isBigNumber(number) ? number.toNumber() : number;\n  if (!Number.isFinite(finalNumber)) return \"\";\n  const value = currency.toLowerCase() === \"usd\" ? parseFloat(Number(finalNumber).toFixed(2)) : parseFloat(Number(finalNumber).toFixed(5));\n  const tilde = value > 0 ? \"~ \" : \"\";\n  return \"\".concat(currency.toLowerCase() === \"usd\" || noTilde ? \"\" : tilde).concat(Number(value), \" \").concat(currency.toUpperCase());\n};\nconst addressSlicer = function (address) {\n  let sliceLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;\n\n  if (address.length < 11) {\n    return address;\n  }\n\n  if (typeof address !== \"string\") return \"\";\n  return \"\".concat(address.slice(0, sliceLength), \"...\").concat(address.slice(-sliceLength));\n};\nconst significantDigits = function (number) {\n  let perc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  let length_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;\n  let input = !BigNumber.isBigNumber(number) ? new BigNumber(number) : number;\n  if (input.isZero()) return input;\n\n  if (perc) {\n    input = input.times(new BigNumber(100));\n  }\n\n  let depth;\n\n  if (input.gte(new BigNumber(1))) {\n    depth = length_;\n  } else {\n    depth = length_ - 1 + Math.ceil(Math.log10(new BigNumber(\"1\").div(input).toNumber()));\n  }\n\n  const shift = new BigNumber(10).pow(new BigNumber(depth));\n  const roundedNumber = Math.round(shift.times(input).toNumber()) / shift.toNumber();\n  return roundedNumber;\n};\nconst formatDate = inputDate => {\n  const monthList = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n  const date = new Date(inputDate);\n  const day = date.getDate();\n  const month = monthList[date.getMonth()];\n  const year = date.getFullYear();\n  return \"\".concat(day, \" \").concat(month, \" \").concat(year);\n};\nconst formatTime = time => {\n  return new Date(time).toTimeString().slice(0, 8);\n};\n/**\n * Network utilities\n */\n\nconst transactionMatchesNetwork = (transaction, chainId) => {\n  if (typeof transaction.chainId !== \"undefined\") {\n    return transaction.chainId === chainId;\n  }\n\n  return false;\n};\n/**\n * Signing utils\n */\n\nconst hashMessage = message => {\n  const bufferedMessage = Buffer.from(message, \"utf8\");\n  const el = hashPersonalMessage(bufferedMessage);\n  return el;\n};\nconst signMessage = (privateKey, data) => {\n  const privKey = Buffer.from(privateKey, \"hex\");\n  const message = stripHexPrefix(data);\n  const msgSig = ecsign(Buffer.from(message, \"hex\"), privKey);\n  const rawMsgSig = concatSig(intToBuffer(msgSig.v), msgSig.r, msgSig.s);\n  return rawMsgSig;\n};\n/**\n * popup handler utils\n */\n\nfunction getPopupFeatures(_ref) {\n  let {\n    width: w,\n    height: h\n  } = _ref;\n  // Fixes dual-screen position                             Most browsers      Firefox\n  const dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : window.screenX;\n  const dualScreenTop = window.screenTop !== undefined ? window.screenTop : window.screenY;\n  const width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : window.screen.width;\n  const height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : window.screen.height;\n  const systemZoom = 1; // No reliable estimate\n\n  const left = Math.abs((width - w) / 2 / systemZoom + dualScreenLeft);\n  const top = Math.abs((height - h) / 2 / systemZoom + dualScreenTop);\n  const features = \"titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=\".concat(h / systemZoom, \",width=\").concat(w / systemZoom, \",top=\").concat(top, \",left=\").concat(left);\n  return features;\n}\nconst broadcastChannelOptions = {\n  // type: 'localstorage', // (optional) enforce a type, oneOf['native', 'idb', 'localstorage', 'node']\n  webWorkerSupport: false // (optional) set this to false if you know that your channel will never be used in a WebWorker (increases performance)\n\n};\nfunction getCustomDeviceInfo() {\n  var _navigator;\n\n  if ((_navigator = navigator) !== null && _navigator !== void 0 && _navigator.brave) {\n    return {\n      browser: \"Brave\"\n    };\n  }\n}\nclass UserError extends Error {}\nconst handleRedirectParameters = (hash, queryParameters) => {\n  const hashParameters = {};\n  const hashUrl = new URL(\"\".concat(window.location.origin, \"/?\").concat(hash.slice(1)));\n  hashUrl.searchParams.forEach((value, key) => {\n    hashParameters[key] = value;\n  });\n  let instanceParameters = {};\n  let error = \"\";\n\n  if (!queryParameters.windowId) {\n    if (Object.keys(hashParameters).length > 0 && hashParameters.state) {\n      instanceParameters = JSON.parse(window.atob(decodeURIComponent(decodeURIComponent(hashParameters.state)))) || {};\n      error = hashParameters.error_description || hashParameters.error || error;\n    } else if (Object.keys(queryParameters).length > 0 && queryParameters.state) {\n      instanceParameters = JSON.parse(window.atob(decodeURIComponent(decodeURIComponent(queryParameters.state)))) || {};\n      if (queryParameters.error) error = queryParameters.error;\n    }\n  }\n\n  return {\n    error,\n    instanceParameters,\n    hashParameters\n  };\n};\nfunction sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nclass BaseKeyringController extends BaseController {\n  constructor(_ref) {\n    var _state$wallets;\n\n    let {\n      config = {},\n      state\n    } = _ref;\n    super({\n      config,\n      state\n    });\n    this.defaultState = {\n      wallets: (_state$wallets = state.wallets) !== null && _state$wallets !== void 0 ? _state$wallets : []\n    };\n    this.initialize();\n  } // for signing auth message\n\n\n  signAuthMessage(address, message) {\n    const keyring = this.state.wallets.find(x => x.address === address);\n\n    if (!keyring) {\n      throw new Error(\"key does not exist\");\n    }\n\n    const hashedMessage = hashMessage(message).toString(\"hex\");\n    const rawMessageSig = signMessage(keyring.privateKey, hashedMessage);\n    return rawMessageSig;\n  }\n\n}\n\nconst RETRIABLE_ERRORS = [// ignore server overload errors\n\"Gateway timeout\", \"ETIMEDOUT\", // ignore server sent html error pages\n// or truncated json responses\n\"failed to parse response body\", // ignore errors where http req failed to establish\n\"Failed to fetch\"];\n\nfunction checkForHttpErrors(fetchRes) {\n  // check for errors\n  switch (fetchRes.status) {\n    case 405:\n      throw ethErrors.rpc.methodNotFound();\n\n    case 418:\n      throw ethErrors.rpc.internal({\n        message: \"Request is being rate limited.\"\n      });\n\n    case 503:\n    case 504:\n      throw ethErrors.rpc.internal({\n        message: \"Gateway timeout. The request took too long to process.\" + \"This can happen when querying over too wide a block range.\"\n      });\n  }\n}\n\nfunction timeout(duration) {\n  return new Promise(resolve => setTimeout(resolve, duration));\n}\n\nfunction parseResponse(fetchRes, body) {\n  // check for error code\n  if (fetchRes.status !== 200) {\n    throw ethErrors.rpc.internal({\n      message: \"Non-200 status code: '\".concat(fetchRes.status, \"'\"),\n      data: body\n    });\n  } // check for rpc error\n\n\n  if (body.error) {\n    throw ethErrors.rpc.internal({\n      data: body.error\n    });\n  } // return successful result\n\n\n  return body.result;\n}\n\nfunction createFetchConfigFromReq(_ref) {\n  let {\n    req,\n    rpcTarget,\n    originHttpHeaderKey\n  } = _ref;\n  const parsedUrl = new URL(rpcTarget); // prepare payload\n  // copy only canonical json rpc properties\n\n  const payload = {\n    id: req.id,\n    jsonrpc: req.jsonrpc,\n    method: req.method,\n    params: req.params\n  }; // extract 'origin' parameter from request\n\n  const originDomain = req.origin; // serialize request body\n\n  const serializedPayload = JSON.stringify(payload); // configure fetch params\n\n  const fetchParams = {\n    method: \"POST\",\n    headers: {\n      Accept: \"application/json\",\n      \"Content-Type\": \"application/json\"\n    },\n    body: serializedPayload\n  }; // optional: add request origin as header\n\n  if (originHttpHeaderKey && originDomain) {\n    fetchParams.headers[originHttpHeaderKey] = originDomain;\n  }\n\n  return {\n    fetchUrl: parsedUrl.href,\n    fetchParams\n  };\n}\nfunction createFetchMiddleware(_ref2) {\n  let {\n    rpcTarget,\n    originHttpHeaderKey\n  } = _ref2;\n  return createAsyncMiddleware(async (req, res, _next) => {\n    const {\n      fetchUrl,\n      fetchParams\n    } = createFetchConfigFromReq({\n      req,\n      rpcTarget,\n      originHttpHeaderKey\n    }); // attempt request multiple times\n\n    const maxAttempts = 5;\n    const retryInterval = 1000;\n\n    for (let attempt = 0; attempt < maxAttempts; attempt++) {\n      try {\n        const fetchRes = await fetch(fetchUrl, fetchParams); // check for http errrors\n\n        checkForHttpErrors(fetchRes); // parse response body\n\n        const fetchBody = await fetchRes.json();\n        const result = parseResponse(fetchRes, fetchBody); // set result and exit retry loop\n\n        res.result = result;\n        return;\n      } catch (err) {\n        const errMsg = err.toString();\n        const isRetriable = RETRIABLE_ERRORS.some(phrase => errMsg.includes(phrase)); // re-throw error if not retriable\n\n        if (!isRetriable) {\n          throw err;\n        }\n      } // delay before retrying\n\n\n      await timeout(retryInterval);\n    }\n  });\n}\n\nfunction createLoggerMiddleware(options) {\n  return function loggerMiddleware(request, response, next) {\n    next(callback => {\n      if (response.error) {\n        log.warn(\"Error in RPC response:\\n\", response);\n      }\n\n      if (request.isTorusInternal) return;\n      log.info(\"RPC (\".concat(options.origin, \"):\"), request, \"->\", response);\n      callback();\n    });\n  };\n}\n\nfunction createOriginMiddleware(options) {\n  return function originMiddleware(request, _, next) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    request.origin = options.origin;\n    next();\n  };\n}\n\nclass BroadcastChannelHandler {\n  constructor(channelPrefix) {\n    _defineProperty(this, \"bc\", void 0);\n\n    _defineProperty(this, \"channel\", void 0);\n\n    const queryParameters = new URLSearchParams(window.location.search);\n    const instanceId = queryParameters.get(\"instanceId\");\n    this.channel = \"\".concat(channelPrefix, \"_\").concat(instanceId);\n    this.bc = new BroadcastChannel(this.channel, broadcastChannelOptions);\n  }\n\n  getMessageFromChannel() {\n    return new Promise((resolve, reject) => {\n      this.bc.addEventListener(\"message\", async ev => {\n        this.bc.close();\n\n        if (ev.error) {\n          reject(ev.error);\n        } else {\n          resolve(ev.data);\n        }\n      });\n      this.bc.postMessage({\n        data: {\n          type: POPUP_LOADED\n        }\n      });\n    });\n  }\n\n}\n\nclass StreamWindow extends BaseController {\n  // if window has been closed by users\n  constructor(_ref) {\n    let {\n      config,\n      state = {}\n    } = _ref;\n    super({\n      config,\n      state\n    });\n\n    _defineProperty(this, \"closed\", false);\n\n    this.initialize();\n  }\n\n  async open() {\n    return new Promise((resolve, reject) => {\n      const {\n        communicationEngine,\n        communicationWindowManager\n      } = this.config;\n      let popupSuccess = false;\n      communicationWindowManager.once(\"\".concat(this.state.windowId, \":closed\"), () => {\n        this.closed = true;\n      }); // Window is not open yet\n\n      if (!this.state.windowId) {\n        this.update({\n          windowId: randomId()\n        });\n        communicationWindowManager.once(\"\".concat(this.state.windowId, \":opened\"), () => {\n          resolve(this);\n        }); // Tell the other party to create a window by prompting the user to click on something\n\n        communicationEngine.emit(\"notification\", {\n          method: COMMUNICATION_NOTIFICATIONS.CREATE_WINDOW,\n          params: {\n            windowId: this.state.windowId,\n            url: this.state.url.href\n          }\n        });\n      } else {\n        // Send this window with `windowId` the url to open via bc\n        const bc = new BroadcastChannel(this.state.windowId, broadcastChannelOptions);\n        bc.addEventListener(\"message\", async ev => {\n          try {\n            log.info(ev, \"receiving data on channel: \".concat(bc.name));\n            const {\n              error\n            } = ev;\n\n            if (error) {\n              // Popup says some error. so, we say it's not really opened\n              reject(new Error(error));\n              return;\n            }\n\n            const {\n              message\n            } = ev.data;\n\n            if (message === POPUP_LOADED) {\n              popupSuccess = true;\n              await bc.postMessage({\n                data: {\n                  url: this.state.url.href,\n                  message: \"\" // No need of a msg\n\n                }\n              });\n              resolve(this);\n              bc.close();\n            }\n          } catch (error) {\n            reject(error);\n            bc.close(); // Something went wrong. so, we close that window\n\n            this.close();\n          }\n        }); // We don't know if the other end is ready to receive this msg. So, we keep writing until it receives and sends back something\n        // we need backoff strategy\n        // we need to wait for first attempt to succeed/fail until the second attempt\n        // If we get 429, we need to wait for a while and then try again\n\n        const postMsg = async () => {\n          // this never throws\n          const localResponse = await bc.postMessage({\n            data: {\n              message: SETUP_COMPLETE\n            }\n          });\n          return localResponse;\n        };\n\n        let currentDelay = bc.type === \"server\" ? 1000 : 200;\n\n        const recursiveFn = async () => {\n          if (!popupSuccess && !this.closed) {\n            const localResponse = await postMsg();\n\n            if (bc.type === \"server\") {\n              const serverResponse = localResponse;\n\n              if (serverResponse.status >= 400) {\n                // We need to wait for a while and then try again\n                currentDelay = Math.round(currentDelay * 1.5);\n              }\n            }\n\n            await sleep(currentDelay);\n            await recursiveFn();\n          }\n        };\n\n        recursiveFn();\n      }\n    });\n  }\n\n  close() {\n    const {\n      communicationEngine\n    } = this.config;\n    communicationEngine.emit(\"notification\", {\n      method: COMMUNICATION_NOTIFICATIONS.CLOSE_WINDOW,\n      params: {\n        windowId: this.state.windowId\n      }\n    });\n  }\n\n}\n\n/*\nScenarios:\n1. Open a normal popup window and no communication with it - Use PopupHandler\n2. Open a popup window and communicate with it - Use PopupWithBcHandler (can initiate communication by waiting for window to open or not)\n\n3. If window is already opened, pass in windowId to the popup handler.\n   This will establish communication with the popup window and sends it a new url to redirect to\n\n\nIf you're trying to open a window and it gets blocked (happens if you're in iframe or delay b/w click and opening window),\nStreamWindow is invoked and it writes in a channel to display a message to the user\n\nOnce user clicks on that modal/dialog, we pre-open the window and pass in the windowId (goes to 3)\n*/\n\n/**\n * Handles popup window management.\n * For broadcast channel communication, use url with `instanceId` coded into state parameter.\n * This state parameter will be passed across redirects according to OAuth spec.\n */\n\nclass PopupHandler extends BaseController {\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config,\n      state\n    }); // this.id = randomId()\n    // Add in dapp storage key to all popups as a hash parameter\n\n    this.defaultConfig = {\n      dappStorageKey: \"\",\n      features: getPopupFeatures(FEATURES_DEFAULT_POPUP_WINDOW),\n      target: \"_blank\",\n      communicationEngine: null,\n      communicationWindowManager: null\n    };\n    this.defaultState = {\n      windowTimer: null,\n      window: null,\n      iClosedWindow: false,\n      windowId: \"\",\n      url: state.url\n    };\n    this.initialize();\n\n    this._setupTimer();\n  }\n\n  async open() {\n    // if window is already open\n    const {\n      target,\n      features,\n      dappStorageKey,\n      communicationEngine,\n      communicationWindowManager\n    } = this.config;\n    const {\n      windowId,\n      url\n    } = this.state;\n\n    if (dappStorageKey) {\n      const urlHashParams = new URLSearchParams(url.hash.slice(1));\n      urlHashParams.append(\"dappStorageKey\", dappStorageKey);\n      url.hash = urlHashParams.toString();\n      this.update({\n        url\n      });\n    } // No window has been pre-opened\n\n\n    if (!windowId) {\n      // try to open a window first\n      let localWindow = window.open(url.href, target, features);\n\n      if (!localWindow) {\n        // if it's blocked, open StreamWindow\n        localWindow = new StreamWindow({\n          config: {\n            communicationEngine,\n            communicationWindowManager\n          },\n          state: {\n            url\n          }\n        });\n        localWindow.open();\n      }\n\n      this.update({\n        window: localWindow\n      });\n      return;\n    } // A window has been pre-opened with a query parameter `windowId`\n\n\n    const localWindow = new StreamWindow({\n      config: {\n        communicationEngine,\n        communicationWindowManager\n      },\n      state: {\n        url,\n        windowId\n      }\n    });\n    this.update({\n      window: localWindow\n    });\n    await localWindow.open();\n  }\n\n  close() {\n    this.update({\n      iClosedWindow: true\n    });\n    const {\n      window\n    } = this.state;\n    if (window) window.close();\n  }\n\n  _setupTimer() {\n    const timer = window.setInterval(() => {\n      const {\n        window,\n        windowTimer,\n        iClosedWindow\n      } = this.state;\n\n      if (window && window.closed) {\n        if (windowTimer) clearInterval(windowTimer);\n\n        if (!iClosedWindow) {\n          this.emit(\"close\");\n        }\n\n        this.update({\n          iClosedWindow: false,\n          window: null\n        });\n      }\n\n      if (window === null && windowTimer) clearInterval(windowTimer);\n    }, 500);\n    this.update({\n      windowTimer: timer\n    });\n  }\n\n}\n\nclass PopupStoreChannel {\n  constructor(_ref) {\n    let {\n      instanceId,\n      handleLogout,\n      handleAccountImport,\n      handleNetworkChange,\n      handleSelectedAddressChange,\n      handleThemeChange\n    } = _ref;\n\n    _defineProperty(this, \"handleLogout\", void 0);\n\n    _defineProperty(this, \"handleAccountImport\", void 0);\n\n    _defineProperty(this, \"handleNetworkChange\", void 0);\n\n    _defineProperty(this, \"handleThemeChange\", void 0);\n\n    _defineProperty(this, \"handleSelectedAddressChange\", void 0);\n\n    _defineProperty(this, \"instanceId\", void 0);\n\n    this.instanceId = instanceId;\n    this.handleLogout = handleLogout;\n    this.handleAccountImport = handleAccountImport;\n    this.handleNetworkChange = handleNetworkChange;\n    this.handleSelectedAddressChange = handleSelectedAddressChange;\n    this.handleThemeChange = handleThemeChange;\n  }\n\n  setupStoreChannels() {\n    this.logoutChannel();\n    this.importAccountChannel();\n    this.networkChangeChannel();\n    this.selectedAddressChangeChannel();\n    this.themeChangedChannel();\n  }\n\n  logoutChannel() {\n    const logoutChannel = new BroadcastChannel(\"\".concat(BROADCAST_CHANNELS.WALLET_LOGOUT_CHANNEL, \"_\").concat(this.instanceId), broadcastChannelOptions);\n    logoutChannel.addEventListener(\"message\", ev => {\n      var _ev$data;\n\n      log.info(\"received logout message\", ev);\n\n      if (!ev.error && ((_ev$data = ev.data) === null || _ev$data === void 0 ? void 0 : _ev$data.type) === BROADCAST_CHANNELS_MSGS.LOGOUT) {\n        log.info(\"Logging Out\");\n        this.handleLogout();\n      }\n    });\n  }\n\n  importAccountChannel() {\n    const walletAccountImportChannel = new BroadcastChannel(\"\".concat(BROADCAST_CHANNELS.WALLET_ACCOUNT_IMPORT_CHANNEL, \"_\").concat(this.instanceId), broadcastChannelOptions);\n    walletAccountImportChannel.addEventListener(\"message\", ev => {\n      var _ev$data2;\n\n      if (!ev.error && ((_ev$data2 = ev.data) === null || _ev$data2 === void 0 ? void 0 : _ev$data2.type) === BROADCAST_CHANNELS_MSGS.ACCOUNT_IMPORTED) {\n        var _ev$data3;\n\n        this.handleAccountImport((_ev$data3 = ev.data) === null || _ev$data3 === void 0 ? void 0 : _ev$data3.privKey);\n      }\n    });\n  }\n\n  networkChangeChannel() {\n    const walletAccountImportChannel = new BroadcastChannel(\"\".concat(BROADCAST_CHANNELS.WALLET_NETWORK_CHANGE_CHANNEL, \"_\").concat(this.instanceId), broadcastChannelOptions);\n    walletAccountImportChannel.addEventListener(\"message\", ev => {\n      var _ev$data4;\n\n      if (!ev.error && ((_ev$data4 = ev.data) === null || _ev$data4 === void 0 ? void 0 : _ev$data4.type) === BROADCAST_CHANNELS_MSGS.NETWORK_CHANGE) {\n        var _ev$data5;\n\n        this.handleNetworkChange((_ev$data5 = ev.data) === null || _ev$data5 === void 0 ? void 0 : _ev$data5.network);\n      }\n    });\n  }\n\n  themeChangedChannel() {\n    const walletAccountImportChannel = new BroadcastChannel(\"\".concat(BROADCAST_CHANNELS.THEME_CHANGE, \"_\").concat(this.instanceId), broadcastChannelOptions);\n    walletAccountImportChannel.addEventListener(\"message\", ev => {\n      var _ev$data6;\n\n      log.info({\n        ev\n      });\n\n      if (!ev.error && ((_ev$data6 = ev.data) === null || _ev$data6 === void 0 ? void 0 : _ev$data6.type) === BROADCAST_CHANNELS_MSGS.SET_THEME) {\n        var _ev$data7;\n\n        this.handleThemeChange((_ev$data7 = ev.data) === null || _ev$data7 === void 0 ? void 0 : _ev$data7.theme);\n      }\n    });\n  }\n\n  selectedAddressChangeChannel() {\n    const walletAccountImportChannel = new BroadcastChannel(\"\".concat(BROADCAST_CHANNELS.WALLET_SELECTED_ADDRESS_CHANNEL, \"_\").concat(this.instanceId), broadcastChannelOptions);\n    walletAccountImportChannel.addEventListener(\"message\", ev => {\n      var _ev$data8;\n\n      if (!ev.error && ((_ev$data8 = ev.data) === null || _ev$data8 === void 0 ? void 0 : _ev$data8.type) === BROADCAST_CHANNELS_MSGS.SELECTED_ADDRESS_CHANGE) {\n        var _ev$data9;\n\n        this.handleSelectedAddressChange((_ev$data9 = ev.data) === null || _ev$data9 === void 0 ? void 0 : _ev$data9.selectedAddress);\n      }\n    });\n  }\n\n}\n\n/**\n * PopupWithBcHandler is a PopupHandler which uses broadcast channel to communicate with the popup window.\n */\n\nclass PopupWithBcHandler extends PopupHandler {\n  constructor(_ref) {\n    let {\n      config,\n      state,\n      instanceId\n    } = _ref;\n    super({\n      config,\n      state\n    });\n\n    _defineProperty(this, \"bc\", void 0);\n\n    this.bc = new BroadcastChannel(instanceId, broadcastChannelOptions);\n  }\n  /**\n   * Receives the data from popup window and closes the window\n   * @param successExtraFn - Extra function to be called after the data is received\n   * @returns The data to be received\n   */\n\n\n  handle(successExtraFn) {\n    return new Promise((resolve, reject) => {\n      const closeListener = () => {\n        this.bc.close();\n        reject(new UserError(\"user closed popup\"));\n        this.removeListener(\"close\", closeListener);\n      };\n\n      this.on(\"close\", closeListener);\n      this.bc.addEventListener(\"message\", async ev => {\n        log.info(ev, \"receiving data on channel: \".concat(this.bc.name));\n\n        try {\n          const {\n            error,\n            data\n          } = ev;\n\n          if (error) {\n            reject(new Error(error));\n            return;\n          }\n\n          if (successExtraFn) await successExtraFn.call(this, data);\n          resolve(data);\n        } catch (error) {\n          reject(error);\n        } finally {\n          this.bc.close();\n          this.close();\n        }\n      });\n      this.open().then(() => {\n        log.info(\"opened window \".concat(this.bc.name)); // Opened window. yay.  let the bc events do their job\n\n        return undefined;\n      }).catch(err => {\n        log.error(err, \"something went wrong while opening window\");\n        reject(err);\n      });\n    });\n  }\n  /**\n   * Use this if we have to send large payloads which don't fit in query/hash params.\n   * Waits for ack that popup window is ready to receive data.\n   * Receives the data from popup window and closes the window\n   * @param payload - The data to be sent to the popup window once we have ack that window is ready to receive data\n   * @param successExtraFn - Extra function to be called after the data is received\n   * @returns The data to be received\n   */\n\n\n  handleWithHandshake(payload, successExtraFn) {\n    return new Promise((resolve, reject) => {\n      const closeListener = () => {\n        this.bc.close();\n        reject(new UserError(\"user closed popup\"));\n        this.removeListener(\"close\", closeListener);\n      };\n\n      this.on(\"close\", closeListener);\n      this.bc.addEventListener(\"message\", async ev => {\n        try {\n          log.info(ev, \"receiving data on channel: \".concat(this.bc.name));\n          const {\n            error,\n            data\n          } = ev;\n\n          if (error) {\n            reject(new Error(error));\n            return;\n          } // Do handshake\n\n\n          const {\n            type = \"\"\n          } = data;\n\n          if (type === POPUP_LOADED) {\n            // Hack with generic to use the same type for both send and receive\n            await this.bc.postMessage({\n              data: payload\n            });\n          } else if (type === POPUP_RESULT) {\n            if (successExtraFn) await successExtraFn.call(this, data);\n            resolve(data); // Must only close the bc after result is done\n\n            this.bc.close();\n            this.close();\n          }\n        } catch (error) {\n          reject(error);\n          this.bc.close();\n          this.close();\n        }\n      });\n      this.open().then(() => {\n        log.info(\"opened window \".concat(this.bc.name)); // Opened window. yay.  let the bc events do their job\n\n        return undefined;\n      }).catch(err => {\n        log.error(err, \"something went wrong while opening window\");\n        reject(err);\n      });\n    });\n  }\n\n}\n\nclass RedirectHandler {\n  constructor() {\n    _defineProperty(this, \"error\", void 0);\n\n    _defineProperty(this, \"finalQueryParams\", {});\n\n    _defineProperty(this, \"instanceParameters\", void 0);\n\n    _defineProperty(this, \"hashParameters\", void 0);\n\n    const {\n      hash\n    } = window.location;\n    const queryParameters = new URLSearchParams(window.location.search);\n    queryParameters.forEach((value, key) => {\n      this.finalQueryParams[key] = value;\n    });\n    const {\n      error,\n      instanceParameters,\n      hashParameters\n    } = handleRedirectParameters(hash, this.finalQueryParams);\n    this.error = error;\n    this.instanceParameters = instanceParameters;\n    this.hashParameters = hashParameters;\n  }\n\n  async handle() {\n    return new Promise((resolve, reject) => {\n      const {\n        finalQueryParams,\n        instanceParameters,\n        hashParameters,\n        error\n      } = this;\n      let bc;\n\n      try {\n        if (!finalQueryParams.windowId) {\n          bc = new BroadcastChannel(\"\".concat(BROADCAST_CHANNELS.REDIRECT_CHANNEL, \"_\").concat(instanceParameters.instanceId), broadcastChannelOptions);\n          bc.addEventListener(\"message\", async ev => {\n            if (ev.error) {\n              reject(ev.error);\n              window.close();\n            } else {\n              resolve();\n              bc.close();\n              log.info(\"posted\", {\n                finalQueryParams,\n                hashParameters,\n                instanceParameters\n              });\n            }\n          });\n          bc.postMessage({\n            data: {\n              instanceParams: instanceParameters,\n              hashParams: hashParameters,\n              queryParams: finalQueryParams\n            },\n            error\n          });\n          setTimeout(() => {\n            resolve();\n            window.location.href = window.location.origin + window.location.search + window.location.hash;\n          }, 5000);\n        } else {\n          bc = new BroadcastChannel(\"\".concat(finalQueryParams.windowId), broadcastChannelOptions);\n          bc.addEventListener(\"message\", async ev => {\n            const {\n              url,\n              message\n            } = ev.data;\n\n            if (url) {\n              resolve();\n              window.location.href = url;\n            } else if (message === SETUP_COMPLETE) {\n              await bc.postMessage({\n                data: {\n                  windowId: finalQueryParams.windowId,\n                  message: POPUP_LOADED\n                }\n              });\n            }\n\n            if (ev.error && ev.error !== \"\") {\n              log.error(ev.error);\n              resolve();\n              bc.close();\n            }\n          });\n        }\n      } catch (err) {\n        log.info(err, \"something went wrong\");\n        reject(err);\n        if (bc) bc.close();\n        window.close();\n      }\n    });\n  }\n\n}\n\nconst ACTIVITY_ACTION = {\n  ACTIVITY_ACTION_ALL: \"walletActivity.allTransactions\",\n  ACTIVITY_ACTION_SEND: \"walletActivity.send\",\n  ACTIVITY_ACTION_RECEIVE: \"walletActivity.receive\",\n  ACTIVITY_ACTION_TOPUP: \"walletActivity.topup\"\n};\nconst ACCOUNT_CATEGORY = {\n  NORMAL: \"normal\",\n  THRESHOLD: \"threshold\",\n  IMPORTED: \"imported\"\n};\n\nfunction ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nconst DEFAULT_INTERVAL = 180 * 1000;\nconst DEFAULT_PREFERENCES = {\n  selectedCurrency: \"USD\",\n  theme: \"dark\",\n  locale: \"en-US\",\n  accountType: ACCOUNT_CATEGORY.NORMAL,\n  contacts: [],\n  jwtToken: \"\",\n  fetchedPastTx: [],\n  pastTransactions: [],\n  paymentTx: [],\n  defaultPublicAddress: \"\",\n  customTokens: [],\n  customNfts: [],\n  crashReport: true,\n  userInfo: {\n    aggregateVerifier: \"\",\n    email: \"\",\n    name: \"\",\n    profileImage: \"\",\n    typeOfLogin: LOGIN_PROVIDER.GOOGLE,\n    verifier: \"\",\n    verifierId: \"\"\n  }\n};\n/**\n * Controller that stores shared settings and exposes convenience methods\n */\n\nclass BasePreferencesController extends BaseController {\n  /**\n   * Name of this controller used during composition\n   */\n\n  /**\n   * Creates a PreferencesController instance\n   *\n   * @param config - Initial options used to configure this controller\n   * @param state - Initial state to set on this controller\n   */\n  constructor(_ref) {\n    let {\n      config,\n      state,\n      defaultPreferences,\n      signAuthMessage\n    } = _ref;\n    super({\n      config,\n      state\n    });\n\n    _defineProperty(this, \"name\", \"PreferencesController\");\n\n    _defineProperty(this, \"iframeOrigin\", void 0);\n\n    _defineProperty(this, \"signAuthMessage\", void 0);\n\n    _defineProperty(this, \"defaultPreferences\", void 0);\n\n    if (!config.api) {\n      throw new Error(\"PreferencesController - no api specified in config.\");\n    }\n\n    this.defaultState = {\n      identities: {},\n      selectedAddress: \"\",\n      lastErrorMessage: \"\",\n      lastSuccessMessage: \"\"\n    };\n    this.defaultConfig = {\n      api: config.api,\n      pollInterval: DEFAULT_INTERVAL\n    };\n    this.initialize();\n    this.defaultPreferences = _objectSpread$1(_objectSpread$1({}, DEFAULT_PREFERENCES), defaultPreferences);\n    this.signAuthMessage = signAuthMessage;\n  }\n\n  setIframeOrigin(origin) {\n    this.iframeOrigin = origin;\n  }\n\n  getAddressState(address) {\n    const selectedAddress = address || this.state.selectedAddress;\n    return this.state.identities[selectedAddress];\n  }\n  /**\n   * Sets selected address\n   *\n   * @param selectedAddress - casper account hash\n   */\n\n\n  setSelectedAddress(selectedAddress) {\n    this.update({\n      selectedAddress\n    });\n  }\n\n  async getUser(address) {\n    const user = await get(\"\".concat(this.config.api, \"/user?fetchTx=false\"), this.headers(address), {\n      useAPIKey: true\n    });\n    return user.data;\n  }\n\n  async createUser(params) {\n    const {\n      selectedCurrency,\n      theme,\n      verifier,\n      verifierId,\n      locale,\n      address,\n      idToken\n    } = params;\n    const userPayload = {\n      default_currency: selectedCurrency,\n      theme,\n      verifier,\n      verifier_id: verifierId,\n      locale,\n      idToken\n    };\n    await post(\"\".concat(this.config.api, \"/user\"), userPayload, this.headers(address), {\n      useAPIKey: true\n    });\n    this.updateState({\n      theme,\n      defaultPublicAddress: address,\n      selectedCurrency,\n      locale\n    }, address);\n  }\n\n  async storeUserLogin(params) {\n    const {\n      verifierId,\n      verifier,\n      options,\n      address,\n      idToken\n    } = params;\n\n    if (!options.rehydrate) {\n      const browser = bowser.getParser(window.navigator.userAgent);\n      const specialBrowser = getCustomDeviceInfo();\n      const recordLoginPayload = {\n        os: browser.getOSName(),\n        os_version: browser.getOSVersion() || \"unidentified\",\n        browser: (specialBrowser === null || specialBrowser === void 0 ? void 0 : specialBrowser.browser) || browser.getBrowserName() || \"unidentified\",\n        browser_version: browser.getBrowserVersion() || \"unidentified\",\n        platform: browser.getPlatform().type || \"desktop\",\n        hostname: this.iframeOrigin,\n        verifier,\n        verifier_id: verifierId,\n        idToken\n      };\n      await post(\"\".concat(this.config.api, \"/user/recordLogin\"), recordLoginPayload, this.headers(address), {\n        useAPIKey: true\n      });\n    }\n  }\n\n  async setCrashReport(isEnabled) {\n    var _this$getAddressState;\n\n    if (isEnabled === ((_this$getAddressState = this.getAddressState()) === null || _this$getAddressState === void 0 ? void 0 : _this$getAddressState.crashReport)) return true;\n\n    try {\n      await patch(\"\".concat(this.config.api, \"/user\"), {\n        enable_crash_reporter: isEnabled\n      }, this.headers(), {\n        useAPIKey: true\n      });\n      this.updateState({\n        crashReport: isEnabled\n      });\n      return true;\n    } catch (error) {\n      log.error(error);\n      return false;\n    }\n  }\n\n  async setUserTheme(theme) {\n    var _this$getAddressState2;\n\n    if (theme === ((_this$getAddressState2 = this.getAddressState()) === null || _this$getAddressState2 === void 0 ? void 0 : _this$getAddressState2.theme)) return true;\n\n    try {\n      await patch(\"\".concat(this.config.api, \"/user\"), {\n        theme\n      }, this.headers(), {\n        useAPIKey: true\n      });\n      this.updateState({\n        theme\n      });\n      return true;\n    } catch (error) {\n      log.error(error);\n      return false;\n    }\n  }\n\n  async setUserLocale(locale) {\n    var _this$getAddressState3;\n\n    if (locale === ((_this$getAddressState3 = this.getAddressState()) === null || _this$getAddressState3 === void 0 ? void 0 : _this$getAddressState3.locale)) return;\n\n    try {\n      await patch(\"\".concat(this.config.api, \"/user\"), {\n        locale\n      }, this.headers(), {\n        useAPIKey: true\n      });\n      this.updateState({\n        locale\n      });\n      return true;\n    } catch (error) {\n      log.error(\"unable to set locale\", error);\n      return false;\n    }\n  }\n\n  async setSelectedCurrency(payload) {\n    var _this$getAddressState4;\n\n    if (payload.selectedCurrency === ((_this$getAddressState4 = this.getAddressState()) === null || _this$getAddressState4 === void 0 ? void 0 : _this$getAddressState4.selectedCurrency)) return true;\n\n    try {\n      await patch(\"\".concat(this.config.api, \"/user\"), {\n        default_currency: payload.selectedCurrency\n      }, this.headers(), {\n        useAPIKey: true\n      });\n      this.updateState({\n        selectedCurrency: payload.selectedCurrency\n      });\n      return true;\n    } catch (error) {\n      log.error(error);\n      return false;\n    }\n  }\n\n  async addContact(contact) {\n    try {\n      var _this$getAddressState5;\n\n      const response = await post(\"\".concat(this.config.api, \"/contact\"), contact, this.headers(), {\n        useAPIKey: true\n      });\n      this.updateState({\n        contacts: [...(((_this$getAddressState5 = this.getAddressState()) === null || _this$getAddressState5 === void 0 ? void 0 : _this$getAddressState5.contacts) || []), response.data]\n      });\n      return true;\n    } catch (error) {\n      log.error(\"unable to add contact\", error);\n      return false;\n    }\n  }\n\n  async deleteContact(contactId) {\n    try {\n      var _this$getAddressState6;\n\n      const response = await remove(\"\".concat(this.config.api, \"/contact/\").concat(contactId), {}, this.headers(), {\n        useAPIKey: true\n      });\n      const finalContacts = (_this$getAddressState6 = this.getAddressState()) === null || _this$getAddressState6 === void 0 ? void 0 : _this$getAddressState6.contacts.filter(contact => contact.id !== response.data.id);\n      if (finalContacts) this.updateState({\n        contacts: [...finalContacts]\n      });\n      return true;\n    } catch (error) {\n      log.error(\"unable to delete contact\", error);\n      return false;\n    }\n  }\n\n  async revokeDiscord(idToken) {\n    try {\n      const resp = await post(\"\".concat(this.config.api, \"/revoke/discord\"), {\n        token: idToken\n      }, this.headers(), {\n        useAPIKey: true\n      });\n      log.info(resp);\n    } catch (error) {\n      log.error(error);\n    }\n  }\n\n  async patchPastTx(body, address) {\n    try {\n      const response = await patch(\"\".concat(this.config.api, \"/transaction\"), body, this.headers(address), {\n        useAPIKey: true\n      });\n      log.info(\"successfully patched\", response);\n    } catch (error) {\n      log.error(\"unable to patch tx\", error);\n    }\n  }\n\n  async postPastTx(tx, address) {\n    try {\n      const response = await post(\"\".concat(this.config.api, \"/transaction\"), tx, this.headers(address), {\n        useAPIKey: true\n      });\n      log.info(\"successfully posted tx\", response);\n      return response;\n    } catch (error) {\n      log.error(error, \"unable to insert transaction\");\n    }\n  }\n\n  async getWalletOrders(address) {\n    try {\n      const response = await get(\"\".concat(this.config.api, \"/transaction\"), this.headers(address), {\n        useAPIKey: true\n      });\n      return response.success ? response.data ? response.data : [] : [];\n    } catch (error) {\n      log.error(\"unable to get wallet orders tx\", error);\n      return [];\n    }\n  }\n\n  async getTopUpOrders(address) {\n    try {\n      const response = await get(\"\".concat(this.config.commonApiHost, \"/transaction\"), this.headers(address), {\n        useAPIKey: true\n      });\n      return response.data || [];\n    } catch (error) {\n      log.error(\"unable to fetch past Top up orders\", error);\n    }\n  }\n\n  async getBillBoardData() {\n    try {\n      const response = await get(\"\".concat(this.config.api, \"/billboard\"), this.headers(), {\n        useAPIKey: true\n      });\n      return response.success ? response.data : [];\n    } catch (error) {\n      log.error(\"unable to get billboard data\", error);\n      return [];\n    }\n  }\n\n  async getMessageForSigning(publicAddress) {\n    const response = await post(\"\".concat(this.config.api, \"/auth/message\"), {\n      public_address: publicAddress\n    }, {}, {\n      useAPIKey: true\n    });\n    return response.message;\n  }\n\n  async getTwitterId(payload) {\n    const res = await get(\"\".concat(this.config.api, \"/twitter?screen_name=\").concat(payload.nick), this.headers(), {\n      useAPIKey: true\n    });\n    return \"\".concat(payload.typeOfLogin.toLowerCase(), \"|\").concat(res.data.toString());\n  }\n\n  async sendEmail(payload) {\n    return post(\"\".concat(this.config.api, \"/transaction/sendemail\"), payload.emailObject, this.headers(), {\n      useAPIKey: true\n    });\n  }\n\n  async refreshJwt() {\n    const address = this.state.selectedAddress;\n    const messageToSign = await this.getMessageForSigning(address);\n    if (!messageToSign.startsWith(this.config.signInPrefix)) throw new Error(\"Cannot sign on invalid message\");\n    const signedMessage = this.signAuthMessage(address, messageToSign);\n    const response = await post(\"\".concat(this.config.api, \"/auth/verify\"), {\n      public_address: address,\n      signed_message: signedMessage\n    }, {}, {\n      useAPIKey: true\n    });\n    this.updateState({\n      jwtToken: response.token\n    }, address);\n  }\n\n  async getDappList() {\n    try {\n      const response = await get(\"\".concat(this.config.api, \"/dapps\"), this.headers(), {\n        useAPIKey: true\n      });\n      return response.success ? response.data : [];\n    } catch (error) {\n      log.error(\"unable to get billboard data\", error);\n      return [];\n    }\n  }\n\n  async init(address, userInfo, jwtToken) {\n    let response = {\n      token: jwtToken\n    };\n    if (this.getAddressState(address)) return;\n\n    if (!jwtToken) {\n      const messageToSign = await this.getMessageForSigning(address);\n      if (!messageToSign.startsWith(this.config.signInPrefix)) throw new Error(\"Cannot sign on invalid message\");\n      const signedMessage = this.signAuthMessage(address, messageToSign);\n      response = await post(\"\".concat(this.config.api, \"/auth/verify\"), {\n        public_address: address,\n        signed_message: signedMessage\n      }, {}, {\n        useAPIKey: true\n      });\n    }\n\n    this.updateState({\n      jwtToken: response.token,\n      userInfo\n    }, address);\n  }\n\n  updateState(preferences, address) {\n    const selectedAddress = address || this.state.selectedAddress;\n    const currentState = this.getAddressState(selectedAddress) || cloneDeep(this.defaultPreferences);\n\n    const mergedState = _objectSpread$1(_objectSpread$1({}, currentState), preferences);\n\n    this.update({\n      identities: _objectSpread$1(_objectSpread$1({}, this.state.identities), {}, {\n        [selectedAddress]: mergedState\n      })\n    });\n    return mergedState;\n  }\n\n  headers(address) {\n    var _this$getAddressState7;\n\n    const selectedAddress = address || this.state.selectedAddress;\n    return getHeaders(((_this$getAddressState7 = this.getAddressState(selectedAddress)) === null || _this$getAddressState7 === void 0 ? void 0 : _this$getAddressState7.jwtToken) || \"\");\n  }\n\n}\n\n/**\n * The status of the transaction. Each status represents the state of the transaction internally\n * in the wallet. Some of these correspond with the state of the transaction on the network, but\n * some are wallet-specific.\n */\nvar TransactionStatus;\n\n(function (TransactionStatus) {\n  TransactionStatus[\"approved\"] = \"approved\";\n  TransactionStatus[\"cancelled\"] = \"cancelled\";\n  TransactionStatus[\"confirmed\"] = \"confirmed\";\n  TransactionStatus[\"failed\"] = \"failed\";\n  TransactionStatus[\"finalized\"] = \"finalized\";\n  TransactionStatus[\"processed\"] = \"processed\";\n  TransactionStatus[\"rejected\"] = \"rejected\";\n  TransactionStatus[\"signed\"] = \"signed\";\n  TransactionStatus[\"submitted\"] = \"submitted\";\n  TransactionStatus[\"unapproved\"] = \"unapproved\";\n  TransactionStatus[\"dropped\"] = \"dropped\";\n  TransactionStatus[\"expired\"] = \"expired\";\n})(TransactionStatus || (TransactionStatus = {}));\n\nconst TRANSACTION_TYPES = {\n  CONTRACT_INTERACTION: \"contractInteraction\",\n  DEPLOY_CONTRACT: \"contractDeployment\",\n  WASM_BASED_DEPLOY: \"wasmBasedDeploy\",\n  STANDARD_TRANSACTION: \"transaction\",\n  STANDARD_PAYMENT_TRANSACTION: \"payment_transaction\" // specific to chains like solana and casper\n\n};\nconst TX_EVENTS = {\n  TX_WARNING: \"tx:warning\",\n  TX_ERROR: \"tx:error\",\n  TX_FAILED: \"tx:failed\",\n  TX_CONFIRMED: \"tx:confirmed\",\n  TX_DROPPED: \"tx:dropped\",\n  TX_EXPIRED: \"tx:expired\",\n  TX_STATUS_UPDATE: \"tx:status_update\",\n  TX_UNAPPROVED: \"tx:unapproved\"\n};\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass BaseTransactionStateManager extends BaseController {\n  constructor(_ref) {\n    let {\n      config,\n      state,\n      getCurrentChainId\n    } = _ref;\n    super({\n      config,\n      state\n    });\n\n    _defineProperty(this, \"getCurrentChainId\", void 0);\n\n    this.defaultConfig = {\n      txHistoryLimit: 40\n    };\n    this.defaultState = {\n      transactions: {},\n      unapprovedTxs: {},\n      currentNetworkTxsList: []\n    };\n    this.initialize();\n    this.getCurrentChainId = getCurrentChainId;\n  }\n\n  getUnapprovedTxList() {\n    const chainId = this.getCurrentChainId();\n    return pickBy(this.state.transactions, transaction => transaction.status === TransactionStatus.unapproved && transactionMatchesNetwork(transaction, chainId));\n  }\n\n  getTransaction(txId) {\n    const {\n      transactions\n    } = this.state;\n    return transactions[txId];\n  }\n\n  updateTransaction(txMeta) {\n    // commit txMeta to state\n    const txId = txMeta.id;\n    txMeta.updated_at = new Date().toISOString();\n    this.update({\n      transactions: _objectSpread(_objectSpread({}, this.state.transactions), {}, {\n        [txId]: txMeta\n      })\n    });\n  }\n\n  setTxStatusRejected(txId) {\n    this._setTransactionStatus(txId, TransactionStatus.rejected);\n\n    this._deleteTransaction(txId);\n  }\n  /**\n   * The implementing controller can override this functionality and add custom logic + call super.()\n   */\n\n\n  setTxStatusUnapproved(txId) {\n    this._setTransactionStatus(txId, TransactionStatus.unapproved);\n  }\n\n  setTxStatusApproved(txId) {\n    this._setTransactionStatus(txId, TransactionStatus.approved);\n  }\n\n  setTxStatusSigned(txId) {\n    this._setTransactionStatus(txId, TransactionStatus.signed);\n  }\n\n  setTxStatusSubmitted(txId) {\n    this._setTransactionStatus(txId, TransactionStatus.submitted);\n  }\n\n  setTxStatusDropped(txId) {\n    this._setTransactionStatus(txId, TransactionStatus.dropped);\n  }\n\n  setTxStatusExpired(txId) {\n    this._setTransactionStatus(txId, TransactionStatus.expired);\n  }\n\n  setTxStatusConfirmed(txId) {\n    this._setTransactionStatus(txId, TransactionStatus.confirmed);\n  }\n\n  setTxStatusFailed(txId, error_) {\n    const error = !error_ ? new Error(\"Internal torus failure\") : error_;\n    const txMeta = this.getTransaction(txId);\n    txMeta.error = error;\n    this.updateTransaction(txMeta);\n\n    this._setTransactionStatus(txId, TransactionStatus.failed);\n  }\n  /**\n   * Method to determine if the transaction is in a final state\n   * @param status - Transaction status\n   * @returns boolean if the transaction is in a final state\n   */\n\n\n  isFinalState(status) {\n    return status === TransactionStatus.rejected || status === TransactionStatus.submitted || status === TransactionStatus.confirmed || status === TransactionStatus.failed || status === TransactionStatus.cancelled || status === TransactionStatus.expired;\n  }\n  /**\n   * Filters out the unapproved transactions from state\n   */\n\n\n  clearUnapprovedTxs() {\n    this.update({\n      transactions: omitBy(this.state.transactions, transaction => transaction.status === TransactionStatus.unapproved)\n    });\n  }\n  /**\n   * will append new transactions to old txns.\n   */\n\n\n  _addTransactionsToState(transactions) {\n    this.update({\n      transactions: transactions.reduce((result, newTx) => {\n        result[newTx.id] = newTx;\n        return result;\n      }, this.state.transactions)\n    });\n  }\n  /**\n   * will set new txns, override existing if any in state.\n   */\n\n\n  _setTransactionsToState(transactions) {\n    this.update({\n      transactions: transactions.reduce((result, newTx) => {\n        result[newTx.id] = newTx;\n        return result;\n      }, {})\n    });\n  }\n\n  _deleteTransaction(targetTransactionId) {\n    const {\n      transactions\n    } = this.state;\n    delete transactions[targetTransactionId];\n    this.update({\n      transactions\n    });\n  }\n\n  _deleteTransactions(targetTransactionIds) {\n    const {\n      transactions\n    } = this.state;\n    targetTransactionIds.forEach(transactionId => {\n      delete transactions[transactionId];\n    });\n    this.update({\n      transactions\n    });\n  }\n\n  _setTransactionStatus(txId, status) {\n    const txMeta = this.getTransaction(txId);\n\n    if (!txMeta) {\n      return;\n    }\n\n    txMeta.status = status; // only updating status so no validation required on txn.\n\n    this.updateTransaction(txMeta);\n    this.emit(TX_EVENTS.TX_STATUS_UPDATE, {\n      txId,\n      status\n    });\n\n    if (this.isFinalState(status)) {\n      this.emit(\"\".concat(txMeta.id, \":finished\"), txMeta);\n    } else {\n      this.emit(\"\".concat(txMeta.id, \":\").concat(status), txId);\n    }\n  }\n\n}\n\nexport { ACCOUNT_CATEGORY, ACTIVITY_ACTION, ACTIVITY_ACTION_ALL, ACTIVITY_ACTION_BURN, ACTIVITY_ACTION_RECEIVE, ACTIVITY_ACTION_SEND, ACTIVITY_ACTION_TOPUP, ACTIVITY_PERIOD_ALL, ACTIVITY_PERIOD_MONTH_ONE, ACTIVITY_PERIOD_MONTH_SIX, ACTIVITY_PERIOD_WEEK_ONE, ACTIVITY_STATUS_CANCELLED, ACTIVITY_STATUS_CANCELLING, ACTIVITY_STATUS_PENDING, ACTIVITY_STATUS_SUCCESSFUL, ACTIVITY_STATUS_UNSUCCESSFUL, BROADCAST_CHANNELS, BROADCAST_CHANNELS_MSGS, BaseBlockTracker, BaseController, BaseCurrencyController, BaseEmbedController, BaseKeyringController, BasePreferencesController, BaseTransactionStateManager, BroadcastChannelHandler, COMMUNICATION_JRPC_METHODS, COMMUNICATION_NOTIFICATIONS, CommunicationWindowManager, DEFAULT_PREFERENCES, FEATURES_CONFIRM_WINDOW, FEATURES_DEFAULT_POPUP_WINDOW, FEATURES_DEFAULT_WALLET_WINDOW, FEATURES_PROVIDER_CHANGE_WINDOW, LOGIN_PROVIDER, PAYMENT_PROVIDER, POPUP_LOADED, POPUP_RESULT, PROVIDER_JRPC_METHODS, PROVIDER_NOTIFICATIONS, PopupHandler, PopupStoreChannel, PopupWithBcHandler, RedirectHandler, SETUP_COMPLETE, StreamWindow, TRANSACTION_TYPES, TX_EVENTS, TransactionStatus, UserError, addressSlicer, broadcastChannelOptions, concatSig, createChangeProviderMiddlewareMiddleware, createCommunicationMiddleware, createEventEmitterProxy, createFetchConfigFromReq, createFetchMiddleware, createGenericJRPCMiddleware, createLoggerMiddleware, createOriginMiddleware, createRandomId, createSwappableProxy, createTopupMiddleware, formatDate, formatSmallNumbers, formatTime, getCustomDeviceInfo, getHeaders, getPopupFeatures, getTxStatusText, handleRedirectParameters, hashMessage, intToHex, padWithZeroes, providerAsMiddleware, providerFromEngine, providerFromMiddleware, randomId, signMessage, significantDigits, sleep, timeout$1 as timeout, transactionMatchesNetwork };\n//# sourceMappingURL=baseControllers.esm.js.map\n",null,null,null,null,null,null,null,null,"/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (root, definition) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        define(definition);\n    } else if (typeof module === 'object' && module.exports) {\n        module.exports = definition();\n    } else {\n        root.log = definition();\n    }\n}(this, function () {\n    \"use strict\";\n\n    // Slightly dubious tricks to cut down minimized file size\n    var noop = function() {};\n    var undefinedType = \"undefined\";\n    var isIE = (typeof window !== undefinedType) && (typeof window.navigator !== undefinedType) && (\n        /Trident\\/|MSIE /.test(window.navigator.userAgent)\n    );\n\n    var logMethods = [\n        \"trace\",\n        \"debug\",\n        \"info\",\n        \"warn\",\n        \"error\"\n    ];\n\n    // Cross-browser bind equivalent that works at least back to IE6\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === 'function') {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\n                };\n            }\n        }\n    }\n\n    // Trace() doesn't print the message in IE, so for that case we need to wrap it\n    function traceForIE() {\n        if (console.log) {\n            if (console.log.apply) {\n                console.log.apply(console, arguments);\n            } else {\n                // In old IE, native console methods themselves don't have apply().\n                Function.prototype.apply.apply(console.log, [console, arguments]);\n            }\n        }\n        if (console.trace) console.trace();\n    }\n\n    // Build the best logging method possible for this env\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\n    function realMethod(methodName) {\n        if (methodName === 'debug') {\n            methodName = 'log';\n        }\n\n        if (typeof console === undefinedType) {\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (methodName === 'trace' && isIE) {\n            return traceForIE;\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, 'log');\n        } else {\n            return noop;\n        }\n    }\n\n    // These private functions always need `this` to be set properly\n\n    function replaceLoggingMethods(level, loggerName) {\n        /*jshint validthis:true */\n        for (var i = 0; i < logMethods.length; i++) {\n            var methodName = logMethods[i];\n            this[methodName] = (i < level) ?\n                noop :\n                this.methodFactory(methodName, level, loggerName);\n        }\n\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n    }\n\n    // In old IE versions, the console isn't present until you first open it.\n    // We build realMethod() replacements here that regenerate logging methods\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n        return function () {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this, level, loggerName);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n\n    // By default, we use closely bound real methods wherever possible, and\n    // otherwise we wait for a console to appear, and then try again.\n    function defaultMethodFactory(methodName, level, loggerName) {\n        /*jshint validthis:true */\n        return realMethod(methodName) ||\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n\n    function Logger(name, defaultLevel, factory) {\n      var self = this;\n      var currentLevel;\n      defaultLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\n\n      var storageKey = \"loglevel\";\n      if (typeof name === \"string\") {\n        storageKey += \":\" + name;\n      } else if (typeof name === \"symbol\") {\n        storageKey = undefined;\n      }\n\n      function persistLevelIfPossible(levelNum) {\n          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n\n          if (typeof window === undefinedType || !storageKey) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage[storageKey] = levelName;\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n          } catch (ignore) {}\n      }\n\n      function getPersistedLevel() {\n          var storedLevel;\n\n          if (typeof window === undefinedType || !storageKey) return;\n\n          try {\n              storedLevel = window.localStorage[storageKey];\n          } catch (ignore) {}\n\n          // Fallback to cookies if local storage gives us nothing\n          if (typeof storedLevel === undefinedType) {\n              try {\n                  var cookie = window.document.cookie;\n                  var location = cookie.indexOf(\n                      encodeURIComponent(storageKey) + \"=\");\n                  if (location !== -1) {\n                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n                  }\n              } catch (ignore) {}\n          }\n\n          // If the stored level is not valid, treat it as if nothing was stored.\n          if (self.levels[storedLevel] === undefined) {\n              storedLevel = undefined;\n          }\n\n          return storedLevel;\n      }\n\n      function clearPersistedLevel() {\n          if (typeof window === undefinedType || !storageKey) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage.removeItem(storageKey);\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC\";\n          } catch (ignore) {}\n      }\n\n      /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */\n\n      self.name = name;\n\n      self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\n          \"ERROR\": 4, \"SILENT\": 5};\n\n      self.methodFactory = factory || defaultMethodFactory;\n\n      self.getLevel = function () {\n          return currentLevel;\n      };\n\n      self.setLevel = function (level, persist) {\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n              level = self.levels[level.toUpperCase()];\n          }\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n              currentLevel = level;\n              if (persist !== false) {  // defaults to true\n                  persistLevelIfPossible(level);\n              }\n              replaceLoggingMethods.call(self, level, name);\n              if (typeof console === undefinedType && level < self.levels.SILENT) {\n                  return \"No console available for logging\";\n              }\n          } else {\n              throw \"log.setLevel() called with invalid level: \" + level;\n          }\n      };\n\n      self.setDefaultLevel = function (level) {\n          defaultLevel = level;\n          if (!getPersistedLevel()) {\n              self.setLevel(level, false);\n          }\n      };\n\n      self.resetLevel = function () {\n          self.setLevel(defaultLevel, false);\n          clearPersistedLevel();\n      };\n\n      self.enableAll = function(persist) {\n          self.setLevel(self.levels.TRACE, persist);\n      };\n\n      self.disableAll = function(persist) {\n          self.setLevel(self.levels.SILENT, persist);\n      };\n\n      // Initialize with the right level\n      var initialLevel = getPersistedLevel();\n      if (initialLevel == null) {\n          initialLevel = defaultLevel;\n      }\n      self.setLevel(initialLevel, false);\n    }\n\n    /*\n     *\n     * Top-level API\n     *\n     */\n\n    var defaultLogger = new Logger();\n\n    var _loggersByName = {};\n    defaultLogger.getLogger = function getLogger(name) {\n        if ((typeof name !== \"symbol\" && typeof name !== \"string\") || name === \"\") {\n          throw new TypeError(\"You must supply a name when creating a logger.\");\n        }\n\n        var logger = _loggersByName[name];\n        if (!logger) {\n          logger = _loggersByName[name] = new Logger(\n            name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n        }\n        return logger;\n    };\n\n    // Grab the current global log variable in case of overwrite\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if (typeof window !== undefinedType &&\n               window.log === defaultLogger) {\n            window.log = _log;\n        }\n\n        return defaultLogger;\n    };\n\n    defaultLogger.getLoggers = function getLoggers() {\n        return _loggersByName;\n    };\n\n    // ES6 default export, for compatibility\n    defaultLogger['default'] = defaultLogger;\n\n    return defaultLogger;\n}));\n","import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { PublicKey } from '@solana/web3.js';\nimport { createLoggerMiddleware, COMMUNICATION_JRPC_METHODS, COMMUNICATION_NOTIFICATIONS, PROVIDER_JRPC_METHODS, PROVIDER_NOTIFICATIONS } from '@toruslabs/base-controllers';\nimport { setAPIKey } from '@toruslabs/http-helpers';\nimport { SafeEventEmitter, ObjectMultiplex, createStreamMiddleware, JRPCEngine, createIdRemapMiddleware, getRpcPromiseCallback, BasePostMessageStream } from '@toruslabs/openlogin-jrpc';\nimport { ethErrors, EthereumRpcError } from 'eth-rpc-errors';\nimport { duplex } from 'is-stream';\nimport pump from 'pump';\nimport loglevel from 'loglevel';\nimport dequal from 'fast-deep-equal';\n\nvar messages = {\n  errors: {\n    disconnected: () => \"Torus: Lost connection to Torus.\",\n    permanentlyDisconnected: () => \"Torus: Disconnected from iframe. Page reload required.\",\n    unsupportedSync: method => \"Torus: The Torus Ethereum provider does not support synchronous methods like \".concat(method, \" without a callback parameter.\"),\n    invalidDuplexStream: () => \"Must provide a Node.js-style duplex stream.\",\n    invalidOptions: maxEventListeners => \"Invalid options. Received: { maxEventListeners: \".concat(maxEventListeners, \"}\"),\n    invalidRequestArgs: () => \"Expected a single, non-array, object argument.\",\n    invalidRequestMethod: () => \"'args.method' must be a non-empty string.\",\n    invalidRequestParams: () => \"'args.params' must be an object or array if provided.\",\n    invalidLoggerObject: () => \"'args.logger' must be an object if provided.\",\n    invalidLoggerMethod: method => \"'args.logger' must include required method '\".concat(method, \"'.\")\n  },\n  info: {\n    connected: chainId => \"Torus: Connected to chain with ID \\\"\".concat(chainId, \"\\\".\")\n  },\n  warnings: {}\n};\n\nconst PAYMENT_PROVIDER = {\n  MOONPAY: \"moonpay\",\n  WYRE: \"wyre\",\n  RAMPNETWORK: \"rampnetwork\",\n  XANPOOL: \"xanpool\",\n  MERCURYO: \"mercuryo\",\n  TRANSAK: \"transak\"\n};\nconst TORUS_BUILD_ENV = {\n  PRODUCTION: \"production\",\n  DEVELOPMENT: \"development\",\n  TESTING: \"testing\"\n};\nconst BUTTON_POSITION = {\n  BOTTOM_LEFT: \"bottom-left\",\n  TOP_LEFT: \"top-left\",\n  BOTTOM_RIGHT: \"bottom-right\",\n  TOP_RIGHT: \"top-right\"\n};\nconst LOGIN_PROVIDER = {\n  GOOGLE: \"google\",\n  FACEBOOK: \"facebook\",\n  REDDIT: \"reddit\",\n  DISCORD: \"discord\",\n  TWITCH: \"twitch\",\n  APPLE: \"apple\",\n  LINE: \"line\",\n  GITHUB: \"github\",\n  KAKAO: \"kakao\",\n  LINKEDIN: \"linkedin\",\n  TWITTER: \"twitter\",\n  WEIBO: \"weibo\",\n  WECHAT: \"wechat\",\n  EMAIL_PASSWORDLESS: \"email_passwordless\"\n};\n\nconst translations = {\n  en: {\n    embed: {\n      continue: \"Continue\",\n      actionRequired: \"Authorization required\",\n      pendingAction: \"Click continue to proceed with your request in a popup\",\n      cookiesRequired: \"Cookies Required\",\n      enableCookies: \"Please enable cookies in your browser preferences to access Torus\",\n      clickHere: \"More Info\"\n    }\n  },\n  de: {\n    embed: {\n      continue: \"Fortsetzen\",\n      actionRequired: \"Autorisierung erforderlich\",\n      pendingAction: \"Klicken Sie in einem Popup auf Weiter, um mit Ihrer Anfrage fortzufahren\",\n      cookiesRequired: \"Cookies benötigt\",\n      enableCookies: \"Bitte aktivieren Sie Cookies in Ihren Browsereinstellungen, um auf Torus zuzugreifen\",\n      clickHere: \"Mehr Info\"\n    }\n  },\n  ja: {\n    embed: {\n      continue: \"継続する\",\n      actionRequired: \"認証が必要です\",\n      pendingAction: \"続行をクリックして、ポップアップでリクエストを続行します\",\n      cookiesRequired: \"必要なクッキー\",\n      enableCookies: \"Torusにアクセスするには、ブラウザの設定でCookieを有効にしてください。\",\n      clickHere: \"詳しくは\"\n    }\n  },\n  ko: {\n    embed: {\n      continue: \"계속하다\",\n      actionRequired: \"승인 필요\",\n      pendingAction: \"팝업에서 요청을 진행하려면 계속을 클릭하십시오.\",\n      cookiesRequired: \"쿠키 필요\",\n      enableCookies: \"브라우저 환경 설정에서 쿠키를 활성화하여 Torus에 액세스하십시오.\",\n      clickHere: \"더 많은 정보\"\n    }\n  },\n  zh: {\n    embed: {\n      continue: \"继续\",\n      actionRequired: \"需要授权\",\n      pendingAction: \"单击继续以在弹出窗口中继续您的请求\",\n      cookiesRequired: \"必填Cookie\",\n      enableCookies: \"请在您的浏览器首选项中启用cookie以访问Torus。\",\n      clickHere: \"更多信息\"\n    }\n  }\n};\nvar configuration = {\n  supportedVerifierList: [LOGIN_PROVIDER.GOOGLE, LOGIN_PROVIDER.REDDIT, LOGIN_PROVIDER.DISCORD],\n  api: \"https://api.tor.us\",\n  translations,\n  prodTorusUrl: \"\",\n  localStorageKey: \"torus-\".concat(window.location.hostname)\n};\n\nvar log = loglevel.getLogger(\"solana-embed\");\n\n/**\n * json-rpc-engine middleware that logs RPC errors and and validates req.method.\n *\n * @param log - The logging API to use.\n * @returns  json-rpc-engine middleware function\n */\n\nfunction createErrorMiddleware() {\n  return (req, res, next) => {\n    // json-rpc-engine will terminate the request when it notices this error\n    if (typeof req.method !== \"string\" || !req.method) {\n      res.error = ethErrors.rpc.invalidRequest({\n        message: \"The request 'method' must be a non-empty string.\",\n        data: req\n      });\n    }\n\n    next(done => {\n      const {\n        error\n      } = res;\n\n      if (!error) {\n        return done();\n      }\n\n      log.error(\"Torus - RPC Error: \".concat(error.message), error);\n      return done();\n    });\n  };\n}\n/**\n * Logs a stream disconnection error. Emits an 'error' if given an\n * EventEmitter that has listeners for the 'error' event.\n *\n * @param log - The logging API to use.\n * @param remoteLabel - The label of the disconnected stream.\n * @param error - The associated error to log.\n * @param emitter - The logging API to use.\n */\n\nfunction logStreamDisconnectWarning(remoteLabel, error, emitter) {\n  let warningMsg = \"Torus: Lost connection to \\\"\".concat(remoteLabel, \"\\\".\");\n\n  if (error !== null && error !== void 0 && error.stack) {\n    warningMsg += \"\\n\".concat(error.stack);\n  }\n\n  log.warn(warningMsg);\n\n  if (emitter && emitter.listenerCount(\"error\") > 0) {\n    emitter.emit(\"error\", warningMsg);\n  }\n}\nconst getWindowId = () => Math.random().toString(36).slice(2);\nconst getTorusUrl = async buildEnv => {\n  let torusUrl;\n  let logLevel; // const versionUsed = version;\n  // log.info(\"solana embed version used: \", versionUsed);\n\n  switch (buildEnv) {\n    case \"testing\":\n      torusUrl = \"https://solana-testing.tor.us\";\n      logLevel = \"debug\";\n      break;\n\n    case \"development\":\n      torusUrl = \"http://localhost:8080\";\n      logLevel = \"debug\";\n      break;\n\n    default:\n      torusUrl = \"https://solana.tor.us\";\n      logLevel = \"error\";\n      break;\n  }\n\n  return {\n    torusUrl,\n    logLevel\n  };\n};\nconst getUserLanguage = () => {\n  let userLanguage = window.navigator.language || \"en-US\";\n  const userLanguages = userLanguage.split(\"-\");\n  userLanguage = Object.prototype.hasOwnProperty.call(configuration.translations, userLanguages[0]) ? userLanguages[0] : \"en\";\n  return userLanguage;\n};\nconst FEATURES_PROVIDER_CHANGE_WINDOW = {\n  height: 660,\n  width: 375\n};\nconst FEATURES_DEFAULT_WALLET_WINDOW = {\n  height: 740,\n  width: 1315\n};\nconst FEATURES_DEFAULT_POPUP_WINDOW = {\n  height: 700,\n  width: 1200\n};\nconst FEATURES_CONFIRM_WINDOW = {\n  height: 600,\n  width: 400\n};\nfunction storageAvailable(type) {\n  let storage;\n\n  try {\n    storage = window[type];\n    const x = \"__storage_test__\";\n    storage.setItem(x, x);\n    storage.removeItem(x);\n    return true;\n  } catch (e) {\n    return e && ( // everything except Firefox\n    e.code === 22 || // Firefox\n    e.code === 1014 || // test name field too, because code might not be present\n    // everything except Firefox\n    e.name === \"QuotaExceededError\" || // Firefox\n    e.name === \"NS_ERROR_DOM_QUOTA_REACHED\") && // acknowledge QuotaExceededError only if there's something already stored\n    storage && storage.length !== 0;\n  }\n}\n/**\n * popup handler utils\n */\n\nfunction getPopupFeatures(_ref) {\n  let {\n    width: w,\n    height: h\n  } = _ref;\n  // Fixes dual-screen position                             Most browsers      Firefox\n  const dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : window.screenX;\n  const dualScreenTop = window.screenTop !== undefined ? window.screenTop : window.screenY;\n  const width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : window.screen.width;\n  const height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : window.screen.height;\n  const systemZoom = 1; // No reliable estimate\n\n  const left = Math.abs((width - w) / 2 / systemZoom + dualScreenLeft);\n  const top = Math.abs((height - h) / 2 / systemZoom + dualScreenTop);\n  const features = \"titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=\".concat(h / systemZoom, \",width=\").concat(w / systemZoom, \",top=\").concat(top, \",left=\").concat(left);\n  return features;\n}\n\nclass BaseProvider extends SafeEventEmitter {\n  /**\n   * Indicating that this provider is a Torus provider.\n   */\n  constructor(connectionStream, _ref) {\n    let {\n      maxEventListeners = 100,\n      jsonRpcStreamName = \"provider\"\n    } = _ref;\n    super();\n\n    _defineProperty(this, \"isTorus\", void 0);\n\n    _defineProperty(this, \"_rpcEngine\", void 0);\n\n    _defineProperty(this, \"jsonRpcConnectionEvents\", void 0);\n\n    _defineProperty(this, \"_state\", void 0);\n\n    if (!duplex(connectionStream)) {\n      throw new Error(messages.errors.invalidDuplexStream());\n    }\n\n    this.isTorus = true;\n    this.setMaxListeners(maxEventListeners);\n    this._handleConnect = this._handleConnect.bind(this);\n    this._handleDisconnect = this._handleDisconnect.bind(this);\n    this._handleStreamDisconnect = this._handleStreamDisconnect.bind(this);\n    this._rpcRequest = this._rpcRequest.bind(this);\n    this._initializeState = this._initializeState.bind(this);\n    this.request = this.request.bind(this);\n    this.sendAsync = this.sendAsync.bind(this); // this.enable = this.enable.bind(this);\n    // setup connectionStream multiplexing\n\n    const mux = new ObjectMultiplex();\n    pump(connectionStream, mux, connectionStream, this._handleStreamDisconnect.bind(this, \"Torus\")); // ignore phishing warning message (handled elsewhere)\n\n    mux.ignoreStream(\"phishing\"); // setup own event listeners\n    // connect to async provider\n\n    const jsonRpcConnection = createStreamMiddleware();\n    pump(jsonRpcConnection.stream, mux.createStream(jsonRpcStreamName), jsonRpcConnection.stream, this._handleStreamDisconnect.bind(this, \"Torus RpcProvider\")); // handle RPC requests via dapp-side rpc engine\n\n    const rpcEngine = new JRPCEngine();\n    rpcEngine.push(createIdRemapMiddleware());\n    rpcEngine.push(createErrorMiddleware());\n    rpcEngine.push(createLoggerMiddleware({\n      origin: location.origin\n    }));\n    rpcEngine.push(jsonRpcConnection.middleware);\n    this._rpcEngine = rpcEngine;\n    this.jsonRpcConnectionEvents = jsonRpcConnection.events;\n  }\n  /**\n   * Submits an RPC request for the given method, with the given params.\n   * Resolves with the result of the method call, or rejects on error.\n   */\n\n\n  async request(args) {\n    if (!args || typeof args !== \"object\" || Array.isArray(args)) {\n      throw ethErrors.rpc.invalidRequest({\n        message: messages.errors.invalidRequestArgs(),\n        data: args\n      });\n    }\n\n    const {\n      method,\n      params\n    } = args;\n\n    if (typeof method !== \"string\" || method.length === 0) {\n      throw ethErrors.rpc.invalidRequest({\n        message: messages.errors.invalidRequestMethod(),\n        data: args\n      });\n    }\n\n    if (params !== undefined && !Array.isArray(params) && (typeof params !== \"object\" || params === null)) {\n      throw ethErrors.rpc.invalidRequest({\n        message: messages.errors.invalidRequestParams(),\n        data: args\n      });\n    }\n\n    return new Promise((resolve, reject) => {\n      this._rpcRequest({\n        method,\n        params\n      }, getRpcPromiseCallback(resolve, reject));\n    });\n  }\n  /**\n   * Submits an RPC request per the given JSON-RPC request object.\n   */\n\n\n  send(payload, callback) {\n    this._rpcRequest(payload, callback);\n  }\n  /**\n   * Submits an RPC request per the given JSON-RPC request object.\n   */\n\n\n  sendAsync(payload) {\n    return new Promise((resolve, reject) => {\n      this._rpcRequest(payload, getRpcPromiseCallback(resolve, reject));\n    });\n  }\n  /**\n   * Called when connection is lost to critical streams.\n   *\n   * emits TorusInpageProvider#disconnect\n   */\n\n\n  _handleStreamDisconnect(streamName, error) {\n    logStreamDisconnectWarning(streamName, error, this);\n\n    this._handleDisconnect(false, error ? error.message : undefined);\n  }\n\n}\n\nconst handleEvent = function (handle, eventName, handler) {\n  for (var _len = arguments.length, handlerArgs = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n    handlerArgs[_key - 3] = arguments[_key];\n  }\n\n  const handlerWrapper = () => {\n    handler(...handlerArgs);\n    handle.removeEventListener(eventName, handlerWrapper);\n  };\n\n  handle.addEventListener(eventName, handlerWrapper);\n};\nasync function documentReady() {\n  return new Promise(resolve => {\n    if (document.readyState !== \"loading\") {\n      resolve();\n    } else {\n      handleEvent(document, \"DOMContentLoaded\", resolve);\n    }\n  });\n}\nconst htmlToElement = html => {\n  const template = window.document.createElement(\"template\");\n  const trimmedHtml = html.trim(); // Never return a text node of whitespace as the result\n\n  template.innerHTML = trimmedHtml;\n  return template.content.firstChild;\n};\n\nclass PopupHandler extends SafeEventEmitter {\n  constructor(_ref) {\n    let {\n      url,\n      target,\n      features\n    } = _ref;\n    super();\n\n    _defineProperty(this, \"url\", void 0);\n\n    _defineProperty(this, \"target\", void 0);\n\n    _defineProperty(this, \"features\", void 0);\n\n    _defineProperty(this, \"window\", void 0);\n\n    _defineProperty(this, \"windowTimer\", void 0);\n\n    _defineProperty(this, \"iClosedWindow\", void 0);\n\n    this.url = url;\n    this.target = target || \"_blank\";\n    this.features = features || getPopupFeatures(FEATURES_DEFAULT_POPUP_WINDOW);\n    this.window = undefined;\n    this.windowTimer = undefined;\n    this.iClosedWindow = false;\n\n    this._setupTimer();\n  }\n\n  _setupTimer() {\n    this.windowTimer = Number(setInterval(() => {\n      if (this.window && this.window.closed) {\n        clearInterval(this.windowTimer);\n\n        if (!this.iClosedWindow) {\n          this.emit(\"close\");\n        }\n\n        this.iClosedWindow = false;\n        this.window = undefined;\n      }\n\n      if (this.window === undefined) clearInterval(this.windowTimer);\n    }, 500));\n  }\n\n  open() {\n    var _this$window;\n\n    this.window = window.open(this.url.href, this.target, this.features);\n    if ((_this$window = this.window) !== null && _this$window !== void 0 && _this$window.focus) this.window.focus();\n    return Promise.resolve();\n  }\n\n  close() {\n    this.iClosedWindow = true;\n    if (this.window) this.window.close();\n  }\n\n  redirect(locationReplaceOnRedirect) {\n    if (locationReplaceOnRedirect) {\n      window.location.replace(this.url.href);\n    } else {\n      window.location.href = this.url.href;\n    }\n  }\n\n}\n\nfunction ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nclass TorusCommunicationProvider extends BaseProvider {\n  constructor(connectionStream, _ref) {\n    let {\n      maxEventListeners = 100,\n      jsonRpcStreamName = \"provider\"\n    } = _ref;\n    super(connectionStream, {\n      maxEventListeners,\n      jsonRpcStreamName\n    }); // private state\n\n    _defineProperty(this, \"embedTranslations\", void 0);\n\n    _defineProperty(this, \"torusUrl\", void 0);\n\n    _defineProperty(this, \"dappStorageKey\", void 0);\n\n    _defineProperty(this, \"windowRefs\", void 0);\n\n    _defineProperty(this, \"tryWindowHandle\", void 0);\n\n    _defineProperty(this, \"torusAlertContainer\", void 0);\n\n    _defineProperty(this, \"torusIframe\", void 0);\n\n    this._state = _objectSpread$2({}, TorusCommunicationProvider._defaultState); // public state\n\n    this.torusUrl = \"\";\n    this.dappStorageKey = \"\";\n    const languageTranslations = configuration.translations[getUserLanguage()];\n    this.embedTranslations = languageTranslations.embed;\n    this.windowRefs = {}; // setup own event listeners\n    // EIP-1193 connect\n\n    this.on(\"connect\", () => {\n      this._state.isConnected = true;\n    });\n\n    const notificationHandler = payload => {\n      const {\n        method,\n        params\n      } = payload;\n\n      if (method === COMMUNICATION_NOTIFICATIONS.IFRAME_STATUS) {\n        const {\n          isFullScreen,\n          rid\n        } = params;\n\n        this._displayIframe({\n          isFull: isFullScreen,\n          rid: rid\n        });\n      } else if (method === COMMUNICATION_NOTIFICATIONS.CREATE_WINDOW) {\n        const {\n          windowId,\n          url\n        } = params;\n\n        this._createPopupBlockAlert(windowId, url);\n      } else if (method === COMMUNICATION_NOTIFICATIONS.CLOSE_WINDOW) {\n        this._handleCloseWindow(params);\n      } else if (method === COMMUNICATION_NOTIFICATIONS.USER_LOGGED_IN) {\n        const {\n          currentLoginProvider\n        } = params;\n        this._state.isLoggedIn = true;\n        this._state.currentLoginProvider = currentLoginProvider;\n      } else if (method === COMMUNICATION_NOTIFICATIONS.USER_LOGGED_OUT) {\n        this._state.isLoggedIn = false;\n        this._state.currentLoginProvider = null;\n\n        this._displayIframe();\n      }\n    };\n\n    this.jsonRpcConnectionEvents.on(\"notification\", notificationHandler);\n  }\n\n  get isLoggedIn() {\n    return this._state.isLoggedIn;\n  }\n\n  get isIFrameFullScreen() {\n    return this._state.isIFrameFullScreen;\n  }\n  /**\n   * Returns whether the inPage provider is connected to Torus.\n   */\n\n\n  isConnected() {\n    return this._state.isConnected;\n  }\n\n  async _initializeState(params) {\n    try {\n      const {\n        torusUrl,\n        dappStorageKey,\n        torusAlertContainer,\n        torusIframe\n      } = params;\n      this.torusUrl = torusUrl;\n      this.dappStorageKey = dappStorageKey;\n      this.torusAlertContainer = torusAlertContainer;\n      this.torusIframe = torusIframe;\n      this.torusIframe.addEventListener(\"load\", () => {\n        // only do this if iframe is not full screen\n        if (!this._state.isIFrameFullScreen) this._displayIframe();\n      });\n      const {\n        currentLoginProvider,\n        isLoggedIn\n      } = await this.request({\n        method: COMMUNICATION_JRPC_METHODS.GET_PROVIDER_STATE,\n        params: []\n      }); // indicate that we've connected, for EIP-1193 compliance\n\n      this._handleConnect(currentLoginProvider, isLoggedIn);\n    } catch (error) {\n      log.error(\"Torus: Failed to get initial state. Please report this bug.\", error);\n    } finally {\n      log.info(\"initialized communication state\");\n      this._state.initialized = true;\n      this.emit(\"_initialized\");\n    }\n  }\n\n  _handleWindow(windowId) {\n    let {\n      url,\n      target,\n      features\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const finalUrl = new URL(url || \"\".concat(this.torusUrl, \"/redirect?windowId=\").concat(windowId));\n\n    if (this.dappStorageKey) {\n      // If multiple instances, it returns the first one\n      if (finalUrl.hash) finalUrl.hash += \"&dappStorageKey=\".concat(this.dappStorageKey);else finalUrl.hash = \"#dappStorageKey=\".concat(this.dappStorageKey);\n    }\n\n    const handledWindow = new PopupHandler({\n      url: finalUrl,\n      target,\n      features\n    });\n    handledWindow.open();\n\n    if (!handledWindow.window) {\n      this._createPopupBlockAlert(windowId, finalUrl.href);\n\n      return;\n    } // Add to collection only if window is opened\n\n\n    this.windowRefs[windowId] = handledWindow; // We tell the iframe that the window has been successfully opened\n\n    this.request({\n      method: COMMUNICATION_JRPC_METHODS.OPENED_WINDOW,\n      params: {\n        windowId\n      }\n    });\n    handledWindow.once(\"close\", () => {\n      // user closed the window\n      delete this.windowRefs[windowId];\n      this.request({\n        method: COMMUNICATION_JRPC_METHODS.CLOSED_WINDOW,\n        params: {\n          windowId\n        }\n      });\n    });\n  }\n\n  _displayIframe() {\n    let {\n      isFull = false,\n      rid = \"\"\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const style = {}; // set phase\n\n    if (!isFull) {\n      style.display = this._state.torusWidgetVisibility ? \"block\" : \"none\";\n      style.height = \"70px\";\n      style.width = \"70px\";\n\n      switch (this._state.buttonPosition) {\n        case BUTTON_POSITION.TOP_LEFT:\n          style.top = \"0px\";\n          style.left = \"0px\";\n          style.right = \"auto\";\n          style.bottom = \"auto\";\n          break;\n\n        case BUTTON_POSITION.TOP_RIGHT:\n          style.top = \"0px\";\n          style.right = \"0px\";\n          style.left = \"auto\";\n          style.bottom = \"auto\";\n          break;\n\n        case BUTTON_POSITION.BOTTOM_RIGHT:\n          style.bottom = \"0px\";\n          style.right = \"0px\";\n          style.top = \"auto\";\n          style.left = \"auto\";\n          break;\n\n        case BUTTON_POSITION.BOTTOM_LEFT:\n        default:\n          style.bottom = \"0px\";\n          style.left = \"0px\";\n          style.top = \"auto\";\n          style.right = \"auto\";\n          break;\n      }\n    } else {\n      style.display = \"block\";\n      style.width = \"100%\";\n      style.height = \"100%\";\n      style.top = \"0px\";\n      style.right = \"0px\";\n      style.left = \"0px\";\n      style.bottom = \"0px\";\n    }\n\n    Object.assign(this.torusIframe.style, style);\n    this._state.isIFrameFullScreen = isFull;\n    this.request({\n      method: COMMUNICATION_JRPC_METHODS.IFRAME_STATUS,\n      params: {\n        isIFrameFullScreen: isFull,\n        rid\n      }\n    });\n  }\n\n  hideTorusButton() {\n    this._state.torusWidgetVisibility = false;\n\n    this._displayIframe();\n  }\n\n  showTorusButton() {\n    this._state.torusWidgetVisibility = true;\n\n    this._displayIframe();\n  }\n  /**\n   * Internal RPC method. Forwards requests to background via the RPC engine.\n   * Also remap ids inbound and outbound\n   */\n\n\n  _rpcRequest(payload, callback) {\n    const cb = callback;\n    const _payload = payload;\n\n    if (!Array.isArray(_payload)) {\n      if (!_payload.jsonrpc) {\n        _payload.jsonrpc = \"2.0\";\n      }\n    }\n\n    this.tryWindowHandle(_payload, cb);\n  }\n  /**\n   * When the provider becomes connected, updates internal state and emits\n   * required events. Idempotent.\n   *\n   * @param currentLoginProvider - The login Provider\n   * emits TorusInpageProvider#connect\n   */\n\n\n  _handleConnect(currentLoginProvider, isLoggedIn) {\n    if (!this._state.isConnected) {\n      this._state.isConnected = true;\n      this.emit(\"connect\", {\n        currentLoginProvider,\n        isLoggedIn\n      });\n      log.debug(messages.info.connected(currentLoginProvider));\n    }\n  }\n  /**\n   * When the provider becomes disconnected, updates internal state and emits\n   * required events. Idempotent with respect to the isRecoverable parameter.\n   *\n   * Error codes per the CloseEvent status codes as required by EIP-1193:\n   * https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\n   *\n   * @param isRecoverable - Whether the disconnection is recoverable.\n   * @param errorMessage - A custom error message.\n   * emits TorusInpageProvider#disconnect\n   */\n\n\n  _handleDisconnect(isRecoverable, errorMessage) {\n    if (this._state.isConnected || !this._state.isPermanentlyDisconnected && !isRecoverable) {\n      this._state.isConnected = false;\n      let error;\n\n      if (isRecoverable) {\n        error = new EthereumRpcError(1013, // Try again later\n        errorMessage || messages.errors.disconnected());\n        log.debug(error);\n      } else {\n        error = new EthereumRpcError(1011, // Internal error\n        errorMessage || messages.errors.permanentlyDisconnected());\n        log.error(error);\n        this._state.currentLoginProvider = null;\n        this._state.isLoggedIn = false;\n        this._state.torusWidgetVisibility = false;\n        this._state.isIFrameFullScreen = false;\n        this._state.isPermanentlyDisconnected = true;\n      }\n\n      this.emit(\"disconnect\", error);\n    }\n  } // Called if the iframe wants to close the window cause it is done processing the request\n\n\n  _handleCloseWindow(params) {\n    const {\n      windowId\n    } = params;\n\n    if (this.windowRefs[windowId]) {\n      this.windowRefs[windowId].close();\n      delete this.windowRefs[windowId];\n    }\n  }\n\n  async _createPopupBlockAlert(windowId, url) {\n    const logoUrl = this.getLogoUrl();\n    const torusAlert = htmlToElement('<div id=\"torusAlert\" class=\"torus-alert--v2\">' + \"<div id=\\\"torusAlert__logo\\\"><img src=\\\"\".concat(logoUrl, \"\\\" /></div>\") + \"<div>\" + \"<h1 id=\\\"torusAlert__title\\\">\".concat(this.embedTranslations.actionRequired, \"</h1>\") + \"<p id=\\\"torusAlert__desc\\\">\".concat(this.embedTranslations.pendingAction, \"</p>\") + \"</div>\" + \"</div>\");\n    const successAlert = htmlToElement(\"<div><a id=\\\"torusAlert__btn\\\">\".concat(this.embedTranslations.continue, \"</a></div>\"));\n    const btnContainer = htmlToElement('<div id=\"torusAlert__btn-container\"></div>');\n    btnContainer.appendChild(successAlert);\n    torusAlert.appendChild(btnContainer);\n\n    const bindOnLoad = () => {\n      successAlert.addEventListener(\"click\", () => {\n        this._handleWindow(windowId, {\n          url,\n          target: \"_blank\",\n          features: getPopupFeatures(FEATURES_CONFIRM_WINDOW)\n        });\n\n        torusAlert.remove();\n        if (this.torusAlertContainer.children.length === 0) this.torusAlertContainer.style.display = \"none\";\n      });\n    };\n\n    const attachOnLoad = () => {\n      this.torusAlertContainer.appendChild(torusAlert);\n    };\n\n    await documentReady();\n    attachOnLoad();\n    bindOnLoad();\n    this.torusAlertContainer.style.display = \"block\";\n  }\n\n  getLogoUrl() {\n    const logoUrl = \"\".concat(this.torusUrl, \"/images/torus_icon-blue.svg\");\n    return logoUrl;\n  }\n\n}\n\n_defineProperty(TorusCommunicationProvider, \"_defaultState\", {\n  buttonPosition: \"bottom-left\",\n  currentLoginProvider: null,\n  isIFrameFullScreen: false,\n  hasEmittedConnection: false,\n  torusWidgetVisibility: false,\n  initialized: false,\n  isLoggedIn: false,\n  isPermanentlyDisconnected: false,\n  isConnected: false\n});\n\nfunction ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nclass TorusInPageProvider extends BaseProvider {\n  /**\n   * The chain ID of the currently connected Solana chain.\n   * See [chainId.network]{@link https://chainid.network} for more information.\n   */\n\n  /**\n   * The user's currently selected Solana address.\n   * If null, Torus is either locked or the user has not permitted any\n   * addresses to be viewed.\n   */\n  constructor(connectionStream, _ref) {\n    let {\n      maxEventListeners = 100,\n      jsonRpcStreamName = \"provider\"\n    } = _ref;\n    super(connectionStream, {\n      maxEventListeners,\n      jsonRpcStreamName\n    }); // private state\n\n    _defineProperty(this, \"chainId\", void 0);\n\n    _defineProperty(this, \"selectedAddress\", void 0);\n\n    _defineProperty(this, \"tryWindowHandle\", void 0);\n\n    this._state = _objectSpread$1({}, TorusInPageProvider._defaultState); // public state\n\n    this.selectedAddress = null;\n    this.chainId = null;\n    this._handleAccountsChanged = this._handleAccountsChanged.bind(this);\n    this._handleChainChanged = this._handleChainChanged.bind(this);\n    this._handleUnlockStateChanged = this._handleUnlockStateChanged.bind(this); // setup own event listeners\n    // EIP-1193 connect\n\n    this.on(\"connect\", () => {\n      this._state.isConnected = true;\n    });\n\n    const jsonRpcNotificationHandler = payload => {\n      const {\n        method,\n        params\n      } = payload;\n\n      if (method === PROVIDER_NOTIFICATIONS.ACCOUNTS_CHANGED) {\n        this._handleAccountsChanged(params);\n      } else if (method === PROVIDER_NOTIFICATIONS.UNLOCK_STATE_CHANGED) {\n        this._handleUnlockStateChanged(params);\n      } else if (method === PROVIDER_NOTIFICATIONS.CHAIN_CHANGED) {\n        this._handleChainChanged(params);\n      }\n    }; // json rpc notification listener\n\n\n    this.jsonRpcConnectionEvents.on(\"notification\", jsonRpcNotificationHandler);\n  }\n  /**\n   * Returns whether the inpage provider is connected to Torus.\n   */\n\n\n  isConnected() {\n    return this._state.isConnected;\n  } // Private Methods\n  //= ===================\n\n  /**\n   * Constructor helper.\n   * Populates initial state by calling 'wallet_getProviderState' and emits\n   * necessary events.\n   */\n\n\n  async _initializeState() {\n    try {\n      const {\n        accounts,\n        chainId,\n        isUnlocked\n      } = await this.request({\n        method: PROVIDER_JRPC_METHODS.GET_PROVIDER_STATE,\n        params: []\n      }); // indicate that we've connected, for EIP-1193 compliance\n\n      this.emit(\"connect\", {\n        chainId\n      });\n\n      this._handleChainChanged({\n        chainId\n      });\n\n      this._handleUnlockStateChanged({\n        accounts,\n        isUnlocked\n      });\n\n      this._handleAccountsChanged(accounts);\n    } catch (error) {\n      log.error(\"Torus: Failed to get initial state. Please report this bug.\", error);\n    } finally {\n      log.info(\"initialized provider state\");\n      this._state.initialized = true;\n      this.emit(\"_initialized\");\n    }\n  }\n  /**\n   * Internal RPC method. Forwards requests to background via the RPC engine.\n   * Also remap ids inbound and outbound\n   */\n\n\n  _rpcRequest(payload, callback) {\n    let isInternal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let cb = callback;\n    const _payload = payload;\n\n    if (!Array.isArray(_payload)) {\n      if (!_payload.jsonrpc) {\n        _payload.jsonrpc = \"2.0\";\n      }\n\n      if (_payload.method === \"solana_accounts\" || _payload.method === \"solana_requestAccounts\") {\n        // handle accounts changing\n        cb = (err, res) => {\n          this._handleAccountsChanged(res.result || [], _payload.method === \"solana_accounts\", isInternal);\n\n          callback(err, res);\n        };\n      } else if (_payload.method === \"wallet_getProviderState\") {\n        this._rpcEngine.handle(payload, cb);\n\n        return;\n      }\n    }\n\n    this.tryWindowHandle(_payload, cb);\n  }\n  /**\n   * When the provider becomes connected, updates internal state and emits\n   * required events. Idempotent.\n   *\n   * @param chainId - The ID of the newly connected chain.\n   * emits TorusInpageProvider#connect\n   */\n\n\n  _handleConnect(chainId) {\n    if (!this._state.isConnected) {\n      this._state.isConnected = true;\n      this.emit(\"connect\", {\n        chainId\n      });\n      log.debug(messages.info.connected(chainId));\n    }\n  }\n  /**\n   * When the provider becomes disconnected, updates internal state and emits\n   * required events. Idempotent with respect to the isRecoverable parameter.\n   *\n   * Error codes per the CloseEvent status codes as required by EIP-1193:\n   * https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\n   *\n   * @param isRecoverable - Whether the disconnection is recoverable.\n   * @param errorMessage - A custom error message.\n   * emits TorusInpageProvider#disconnect\n   */\n\n\n  _handleDisconnect(isRecoverable, errorMessage) {\n    if (this._state.isConnected || !this._state.isPermanentlyDisconnected && !isRecoverable) {\n      this._state.isConnected = false;\n      let error;\n\n      if (isRecoverable) {\n        error = new EthereumRpcError(1013, // Try again later\n        errorMessage || messages.errors.disconnected());\n        log.debug(error);\n      } else {\n        error = new EthereumRpcError(1011, // Internal error\n        errorMessage || messages.errors.permanentlyDisconnected());\n        log.error(error);\n        this.chainId = null;\n        this._state.accounts = null;\n        this.selectedAddress = null;\n        this._state.isUnlocked = false;\n        this._state.isPermanentlyDisconnected = true;\n      }\n\n      this.emit(\"disconnect\", error);\n    }\n  }\n  /**\n   * Called when accounts may have changed.\n   */\n\n\n  _handleAccountsChanged(accounts) {\n    let isEthAccounts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let isInternal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    // defensive programming\n    let finalAccounts = accounts;\n\n    if (!Array.isArray(finalAccounts)) {\n      log.error(\"Torus: Received non-array accounts parameter. Please report this bug.\", finalAccounts);\n      finalAccounts = [];\n    }\n\n    for (const account of accounts) {\n      if (typeof account !== \"string\") {\n        log.error(\"Torus: Received non-string account. Please report this bug.\", accounts);\n        finalAccounts = [];\n        break;\n      }\n    } // emit accountsChanged if anything about the accounts array has changed\n\n\n    if (!dequal(this._state.accounts, finalAccounts)) {\n      // we should always have the correct accounts even before solana_accounts\n      // returns, except in cases where isInternal is true\n      if (isEthAccounts && Array.isArray(this._state.accounts) && this._state.accounts.length > 0 && !isInternal) {\n        log.error('Torus: \"solana_accounts\" unexpectedly updated accounts. Please report this bug.', finalAccounts);\n      }\n\n      this._state.accounts = finalAccounts;\n      this.emit(\"accountsChanged\", finalAccounts);\n    } // handle selectedAddress\n\n\n    if (this.selectedAddress !== finalAccounts[0]) {\n      this.selectedAddress = finalAccounts[0] || null;\n    }\n  }\n  /**\n   * Upon receipt of a new chainId and networkVersion, emits corresponding\n   * events and sets relevant public state.\n   * Does nothing if neither the chainId nor the networkVersion are different\n   * from existing values.\n   *\n   * emits TorusInpageProvider#chainChanged\n   * @param networkInfo - An object with network info.\n   */\n\n\n  _handleChainChanged() {\n    let {\n      chainId\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!chainId) {\n      log.error(\"Torus: Received invalid network parameters. Please report this bug.\", {\n        chainId\n      });\n      return;\n    }\n\n    if (chainId === \"loading\") {\n      this._handleDisconnect(true);\n    } else {\n      this._handleConnect(chainId);\n\n      if (chainId !== this.chainId) {\n        this.chainId = chainId;\n\n        if (this._state.initialized) {\n          this.emit(\"chainChanged\", this.chainId);\n        }\n      }\n    }\n  }\n  /**\n   * Upon receipt of a new isUnlocked state, sets relevant public state.\n   * Calls the accounts changed handler with the received accounts, or an empty\n   * array.\n   *\n   * Does nothing if the received value is equal to the existing value.\n   * There are no lock/unlock events.\n   *\n   * @param opts - Options bag.\n   */\n\n\n  _handleUnlockStateChanged() {\n    let {\n      accounts,\n      isUnlocked\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (typeof isUnlocked !== \"boolean\") {\n      log.error(\"Torus: Received invalid isUnlocked parameter. Please report this bug.\", {\n        isUnlocked\n      });\n      return;\n    }\n\n    if (isUnlocked !== this._state.isUnlocked) {\n      this._state.isUnlocked = isUnlocked;\n\n      this._handleAccountsChanged(accounts || []);\n    }\n  }\n\n}\n\n_defineProperty(TorusInPageProvider, \"_defaultState\", {\n  accounts: null,\n  isConnected: false,\n  isUnlocked: false,\n  initialized: false,\n  isPermanentlyDisconnected: false,\n  hasEmittedConnection: false\n});\n\n/**\n * Returns whether the given image URL exists\n */\nfunction imgExists(url) {\n  return new Promise((resolve, reject) => {\n    try {\n      const img = document.createElement(\"img\");\n\n      img.onload = () => resolve(true);\n\n      img.onerror = () => resolve(false);\n\n      img.src = url;\n    } catch (e) {\n      reject(e);\n    }\n  });\n}\n/**\n * Extracts a name for the site from the DOM\n */\n\n\nconst getSiteName = window => {\n  const {\n    document\n  } = window;\n  const siteName = document.querySelector('head > meta[property=\"og:site_name\"]');\n\n  if (siteName) {\n    return siteName.content;\n  }\n\n  const metaTitle = document.querySelector('head > meta[name=\"title\"]');\n\n  if (metaTitle) {\n    return metaTitle.content;\n  }\n\n  if (document.title && document.title.length > 0) {\n    return document.title;\n  }\n\n  return window.location.hostname;\n};\n/**\n * Extracts an icon for the site from the DOM\n */\n\n\nasync function getSiteIcon(window) {\n  try {\n    const {\n      document\n    } = window; // Use the site's favicon if it exists\n\n    let icon = document.querySelector('head > link[rel=\"shortcut icon\"]');\n\n    if (icon && (await imgExists(icon.href))) {\n      return icon.href;\n    } // Search through available icons in no particular order\n\n\n    icon = Array.from(document.querySelectorAll('head > link[rel=\"icon\"]')).find(_icon => Boolean(_icon.href));\n\n    if (icon && (await imgExists(icon.href))) {\n      return icon.href;\n    }\n\n    return \"\";\n  } catch (error) {\n    return \"\";\n  }\n}\n/**\n * Gets site metadata and returns it\n *\n */\n\n\nconst getSiteMetadata = async () => ({\n  name: getSiteName(window),\n  icon: await getSiteIcon(window)\n});\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nconst {\n  version\n} = require(\"../package.json\");\n\nconst PROVIDER_UNSAFE_METHODS = [\"send_transaction\", \"sign_transaction\", \"sign_all_transactions\", \"sign_message\", \"connect\"];\nconst COMMUNICATION_UNSAFE_METHODS = [COMMUNICATION_JRPC_METHODS.SET_PROVIDER];\nconst isLocalStorageAvailable = storageAvailable(\"localStorage\"); // preload for iframe doesn't work https://bugs.chromium.org/p/chromium/issues/detail?id=593267\n\n(async function preLoadIframe() {\n  try {\n    if (typeof document === \"undefined\") return;\n    const torusIframeHtml = document.createElement(\"link\");\n    const {\n      torusUrl\n    } = await getTorusUrl(\"production\");\n    torusIframeHtml.href = \"\".concat(torusUrl, \"/frame\");\n    torusIframeHtml.crossOrigin = \"anonymous\";\n    torusIframeHtml.type = \"text/html\";\n    torusIframeHtml.rel = \"prefetch\";\n\n    if (torusIframeHtml.relList && torusIframeHtml.relList.supports) {\n      if (torusIframeHtml.relList.supports(\"prefetch\")) {\n        document.head.appendChild(torusIframeHtml);\n      }\n    }\n  } catch (error) {\n    log.warn(error);\n  }\n})();\n\nclass Torus {\n  constructor() {\n    let {\n      modalZIndex = 99999\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _defineProperty(this, \"isInitialized\", void 0);\n\n    _defineProperty(this, \"torusAlert\", void 0);\n\n    _defineProperty(this, \"modalZIndex\", void 0);\n\n    _defineProperty(this, \"alertZIndex\", void 0);\n\n    _defineProperty(this, \"requestedLoginProvider\", void 0);\n\n    _defineProperty(this, \"provider\", void 0);\n\n    _defineProperty(this, \"communicationProvider\", void 0);\n\n    _defineProperty(this, \"dappStorageKey\", void 0);\n\n    _defineProperty(this, \"torusAlertContainer\", void 0);\n\n    _defineProperty(this, \"torusUrl\", void 0);\n\n    _defineProperty(this, \"torusIframe\", void 0);\n\n    _defineProperty(this, \"styleLink\", void 0);\n\n    this.torusUrl = \"\";\n    this.isInitialized = false; // init done\n\n    this.requestedLoginProvider = null;\n    this.modalZIndex = modalZIndex;\n    this.alertZIndex = modalZIndex + 1000;\n    this.dappStorageKey = \"\";\n  }\n\n  get isLoggedIn() {\n    if (!this.communicationProvider) return false;\n    return this.communicationProvider.isLoggedIn;\n  }\n\n  async init() {\n    let {\n      buildEnv = TORUS_BUILD_ENV.PRODUCTION,\n      enableLogging = false,\n      network,\n      showTorusButton = false,\n      useLocalStorage = false,\n      buttonPosition = BUTTON_POSITION.BOTTOM_LEFT,\n      apiKey = \"torus-default\",\n      extraParams = {}\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (this.isInitialized) throw new Error(\"Already initialized\");\n    setAPIKey(apiKey);\n    const {\n      torusUrl,\n      logLevel\n    } = await getTorusUrl(buildEnv);\n    log.enableAll();\n    log.info(torusUrl, \"url loaded\");\n    log.info(\"Solana Embed Version :\".concat(version));\n    this.torusUrl = torusUrl;\n    log.setDefaultLevel(logLevel);\n    if (enableLogging) log.enableAll();else log.disableAll();\n    const dappStorageKey = this.handleDappStorageKey(useLocalStorage);\n    const torusIframeUrl = new URL(torusUrl);\n    if (torusIframeUrl.pathname.endsWith(\"/\")) torusIframeUrl.pathname += \"frame\";else torusIframeUrl.pathname += \"/frame\";\n    const hashParams = new URLSearchParams();\n    if (dappStorageKey) hashParams.append(\"dappStorageKey\", dappStorageKey);\n    hashParams.append(\"origin\", window.location.origin);\n    torusIframeUrl.hash = hashParams.toString(); // Iframe code\n\n    this.torusIframe = htmlToElement(\"<iframe\\n        id=\\\"torusIframe\\\"\\n        class=\\\"torusIframe\\\"\\n        src=\\\"\".concat(torusIframeUrl.href, \"\\\"\\n        style=\\\"display: none; position: fixed; top: 0; right: 0; width: 100%;\\n        height: 100%; border: none; border-radius: 0; z-index: \").concat(this.modalZIndex.toString(), \"\\\"\\n      ></iframe>\"));\n    this.torusAlertContainer = htmlToElement(\"<div id=\\\"torusAlertContainer\\\" style=\\\"display:none; z-index: \".concat(this.alertZIndex.toString(), \"\\\"></div>\"));\n    this.styleLink = htmlToElement(\"<link href=\\\"\".concat(torusUrl, \"/css/widget.css\\\" rel=\\\"stylesheet\\\" type=\\\"text/css\\\">\"));\n\n    const handleSetup = async () => {\n      return new Promise((resolve, reject) => {\n        try {\n          window.document.head.appendChild(this.styleLink);\n          window.document.body.appendChild(this.torusIframe);\n          window.document.body.appendChild(this.torusAlertContainer);\n          this.torusIframe.addEventListener(\"load\", async () => {\n            const dappMetadata = await getSiteMetadata(); // send init params here\n\n            this.torusIframe.contentWindow.postMessage({\n              buttonPosition,\n              apiKey,\n              network,\n              dappMetadata,\n              extraParams\n            }, torusIframeUrl.origin);\n            await this._setupWeb3({\n              torusUrl\n            });\n            if (showTorusButton) this.showTorusButton();else this.hideTorusButton();\n            this.isInitialized = true;\n            window.torus = this;\n            resolve();\n          });\n        } catch (error) {\n          reject(error);\n        }\n      });\n    };\n\n    await documentReady();\n    await handleSetup();\n  }\n\n  async login() {\n    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!this.isInitialized) throw new Error(\"Call init() first\");\n\n    try {\n      this.requestedLoginProvider = params.loginProvider || null;\n\n      if (!this.requestedLoginProvider) {\n        this.communicationProvider._displayIframe({\n          isFull: true\n        });\n      } // If user is already logged in, we assume they have given access to the website\n\n\n      const res = await new Promise((resolve, reject) => {\n        // We use this method because we want to update inPage provider state with account info\n        this.provider._rpcRequest({\n          method: \"solana_requestAccounts\",\n          params: [this.requestedLoginProvider, params.login_hint]\n        }, getRpcPromiseCallback(resolve, reject));\n      });\n\n      if (Array.isArray(res) && res.length > 0) {\n        return res;\n      } // This would never happen, but just in case\n\n\n      throw new Error(\"Login failed\");\n    } catch (error) {\n      log.error(\"login failed\", error);\n      throw error;\n    } finally {\n      if (this.communicationProvider.isIFrameFullScreen) this.communicationProvider._displayIframe();\n    }\n  }\n\n  async loginWithPrivateKey(loginParams) {\n    if (!this.isInitialized) throw new Error(\"Call init() first\");\n    const {\n      privateKey,\n      userInfo\n    } = loginParams;\n    const {\n      success\n    } = await this.communicationProvider.request({\n      method: \"login_with_private_key\",\n      params: {\n        privateKey,\n        userInfo\n      }\n    });\n    if (!success) throw new Error(\"Login Failed\");\n  }\n\n  async logout() {\n    if (!this.communicationProvider.isLoggedIn) throw new Error(\"Not logged in\");\n    await this.communicationProvider.request({\n      method: COMMUNICATION_JRPC_METHODS.LOGOUT,\n      params: []\n    });\n    this.requestedLoginProvider = null;\n  }\n\n  async cleanUp() {\n    if (this.communicationProvider.isLoggedIn) {\n      await this.logout();\n    }\n\n    this.clearInit();\n  }\n\n  clearInit() {\n    function isElement(element) {\n      return element instanceof Element || element instanceof Document;\n    }\n\n    if (isElement(this.styleLink) && window.document.body.contains(this.styleLink)) {\n      this.styleLink.remove();\n      this.styleLink = undefined;\n    }\n\n    if (isElement(this.torusIframe) && window.document.body.contains(this.torusIframe)) {\n      this.torusIframe.remove();\n      this.torusIframe = undefined;\n    }\n\n    if (isElement(this.torusAlertContainer) && window.document.body.contains(this.torusAlertContainer)) {\n      this.torusAlert = undefined;\n      this.torusAlertContainer.remove();\n      this.torusAlertContainer = undefined;\n    }\n\n    this.isInitialized = false;\n  }\n\n  hideTorusButton() {\n    this.communicationProvider.hideTorusButton();\n  }\n\n  showTorusButton() {\n    this.communicationProvider.showTorusButton();\n  }\n\n  async setProvider(params) {\n    await this.communicationProvider.request({\n      method: COMMUNICATION_JRPC_METHODS.SET_PROVIDER,\n      params: _objectSpread({}, params)\n    });\n  }\n\n  async showWallet(path) {\n    let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const instanceId = await this.communicationProvider.request({\n      method: COMMUNICATION_JRPC_METHODS.WALLET_INSTANCE_ID,\n      params: []\n    });\n    const finalPath = path ? \"/\".concat(path) : \"\";\n    const finalUrl = new URL(\"\".concat(this.torusUrl, \"/wallet\").concat(finalPath)); // Using URL constructor to prevent js injection and allow parameter validation.!\n\n    finalUrl.searchParams.append(\"instanceId\", instanceId);\n    Object.keys(params).forEach(x => {\n      finalUrl.searchParams.append(x, params[x]);\n    });\n\n    if (this.dappStorageKey) {\n      finalUrl.hash = \"#dappStorageKey=\".concat(this.dappStorageKey);\n    } // No need to track this window state. Hence, no _handleWindow call.\n\n\n    const walletWindow = new PopupHandler({\n      url: finalUrl,\n      features: getPopupFeatures(FEATURES_DEFAULT_WALLET_WINDOW)\n    });\n    walletWindow.open();\n  }\n\n  async getUserInfo() {\n    const userInfoResponse = await this.communicationProvider.request({\n      method: COMMUNICATION_JRPC_METHODS.USER_INFO,\n      params: []\n    });\n    return userInfoResponse;\n  }\n\n  async initiateTopup(provider, params) {\n    if (!this.isInitialized) throw new Error(\"Torus is not initialized\");\n    const windowId = getWindowId();\n\n    this.communicationProvider._handleWindow(windowId);\n\n    const topupResponse = await this.communicationProvider.request({\n      method: COMMUNICATION_JRPC_METHODS.TOPUP,\n      params: {\n        provider,\n        params,\n        windowId\n      }\n    });\n    return topupResponse;\n  } // Solana specific API\n\n\n  async getAccounts() {\n    const response = await this.provider.request({\n      method: \"getAccounts\",\n      params: []\n    });\n    return response;\n  }\n\n  async sendTransaction(transaction) {\n    const response = await this.provider.request({\n      method: \"send_transaction\",\n      params: {\n        message: transaction.serialize({\n          requireAllSignatures: false\n        }).toString(\"hex\")\n      }\n    });\n    return response;\n  }\n\n  async signTransaction(transaction) {\n    const response = await this.provider.request({\n      method: \"sign_transaction\",\n      params: {\n        message: transaction.serializeMessage().toString(\"hex\"),\n        messageOnly: true\n      }\n    }); // reconstruct signature pair\n\n    const parsed = JSON.parse(response);\n    const signature = {\n      publicKey: new PublicKey(parsed.publicKey),\n      signature: Buffer.from(parsed.signature, \"hex\")\n    };\n    transaction.addSignature(signature.publicKey, signature.signature);\n    return transaction;\n  }\n\n  async signAllTransactions(transactions) {\n    const encodedMessage = transactions.map(tx => {\n      return tx.serializeMessage().toString(\"hex\");\n    });\n    const responses = await this.provider.request({\n      method: \"sign_all_transactions\",\n      params: {\n        message: encodedMessage,\n        messageOnly: true\n      }\n    }); // reconstruct signature pairs\n\n    const signatures = responses.map(item => {\n      const parsed = JSON.parse(item);\n      return {\n        publicKey: new PublicKey(parsed.publicKey),\n        signature: Buffer.from(parsed.signature, \"hex\")\n      };\n    });\n    transactions.forEach((tx, idx) => {\n      tx.addSignature(signatures[idx].publicKey, signatures[idx].signature);\n      return tx;\n    });\n    return transactions;\n  }\n\n  async signMessage(data) {\n    const response = await this.provider.request({\n      method: \"sign_message\",\n      params: {\n        data\n      }\n    });\n    return response;\n  }\n\n  async getGaslessPublicKey() {\n    const response = await this.provider.request({\n      method: \"get_gasless_public_key\",\n      params: []\n    });\n    return response;\n  } // async connect(): Promise<boolean> {\n  //   const response = (await this.provider.request({\n  //     method: \"connect\",\n  //     params: {},\n  //   })) as boolean;\n  //   return response;\n  // }\n\n\n  handleDappStorageKey(useLocalStorage) {\n    let dappStorageKey = \"\";\n\n    if (isLocalStorageAvailable && useLocalStorage) {\n      const storedKey = window.localStorage.getItem(configuration.localStorageKey);\n      if (storedKey) dappStorageKey = storedKey;else {\n        const generatedKey = \"torus-app-\".concat(getWindowId());\n        window.localStorage.setItem(configuration.localStorageKey, generatedKey);\n        dappStorageKey = generatedKey;\n      }\n    }\n\n    this.dappStorageKey = dappStorageKey;\n    return dappStorageKey;\n  }\n\n  async _setupWeb3(providerParams) {\n    log.info(\"setupWeb3 running\"); // setup background connection\n\n    const providerStream = new BasePostMessageStream({\n      name: \"embed_torus\",\n      target: \"iframe_torus\",\n      targetWindow: this.torusIframe.contentWindow\n    }); // We create another LocalMessageDuplexStream for communication between dapp <> iframe\n\n    const communicationStream = new BasePostMessageStream({\n      name: \"embed_communication\",\n      target: \"iframe_communication\",\n      targetWindow: this.torusIframe.contentWindow\n    }); // compose the inPage provider\n\n    const inPageProvider = new TorusInPageProvider(providerStream, {});\n    const communicationProvider = new TorusCommunicationProvider(communicationStream, {});\n\n    inPageProvider.tryWindowHandle = (payload, cb) => {\n      const _payload = payload;\n\n      if (!Array.isArray(_payload) && PROVIDER_UNSAFE_METHODS.includes(_payload.method)) {\n        if (!this.communicationProvider.isLoggedIn) throw new Error(\"User Not Logged In\");\n        const windowId = getWindowId();\n\n        communicationProvider._handleWindow(windowId, {\n          target: \"_blank\",\n          features: getPopupFeatures(FEATURES_CONFIRM_WINDOW)\n        }); // for inPageProvider methods sending windowId in request instead of params\n        // as params might be positional.\n\n\n        _payload.windowId = windowId;\n      }\n\n      inPageProvider._rpcEngine.handle(_payload, cb);\n    };\n\n    communicationProvider.tryWindowHandle = (payload, cb) => {\n      const _payload = payload;\n\n      if (!Array.isArray(_payload) && COMMUNICATION_UNSAFE_METHODS.includes(_payload.method)) {\n        const windowId = getWindowId();\n\n        communicationProvider._handleWindow(windowId, {\n          target: \"_blank\",\n          features: getPopupFeatures(FEATURES_PROVIDER_CHANGE_WINDOW) // todo: are these features generic for all\n\n        }); // for communication methods sending window id in jrpc req params\n\n\n        _payload.params.windowId = windowId;\n      }\n\n      communicationProvider._rpcEngine.handle(_payload, cb);\n    }; // detect solana_requestAccounts and pipe to enable for now\n\n\n    const detectAccountRequestPrototypeModifier = m => {\n      const originalMethod = inPageProvider[m]; // eslint-disable-next-line @typescript-eslint/no-this-alias\n\n      const self = this;\n\n      inPageProvider[m] = function providerFunc(request, cb) {\n        const {\n          method,\n          params = []\n        } = request;\n\n        if (method === \"solana_requestAccounts\") {\n          if (!cb) return self.login({\n            loginProvider: params[0]\n          });\n          self.login({\n            loginProvider: params[0]\n          }) // eslint-disable-next-line promise/no-callback-in-promise\n          .then(res => cb(null, res)) // eslint-disable-next-line promise/no-callback-in-promise\n          .catch(err => cb(err));\n        }\n\n        return originalMethod.apply(this, [request, cb]);\n      };\n    }; // Detects call to solana_requestAccounts in request & sendAsync and passes to login\n\n\n    detectAccountRequestPrototypeModifier(\"request\");\n    detectAccountRequestPrototypeModifier(\"sendAsync\");\n    detectAccountRequestPrototypeModifier(\"send\");\n    const proxiedInPageProvider = new Proxy(inPageProvider, {\n      // straight up lie that we deleted the property so that it doesn't\n      // throw an error in strict mode\n      deleteProperty: () => true\n    });\n    const proxiedCommunicationProvider = new Proxy(communicationProvider, {\n      // straight up lie that we deleted the property so that it doesn't\n      // throw an error in strict mode\n      deleteProperty: () => true\n    });\n    this.provider = proxiedInPageProvider;\n    this.communicationProvider = proxiedCommunicationProvider;\n    await Promise.all([inPageProvider._initializeState(), communicationProvider._initializeState(_objectSpread(_objectSpread({}, providerParams), {}, {\n      dappStorageKey: this.dappStorageKey,\n      torusAlertContainer: this.torusAlertContainer,\n      torusIframe: this.torusIframe\n    }))]);\n    log.debug(\"Torus - injected provider\");\n  }\n\n}\n\nexport { BUTTON_POSITION, LOGIN_PROVIDER, PAYMENT_PROVIDER, TORUS_BUILD_ENV, TorusInPageProvider, Torus as default };\n//# sourceMappingURL=solanaEmbed.esm.js.map\n",null,null,null,null,"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { BaseController, createEventEmitterProxy, providerFromEngine } from '@toruslabs/base-controllers';\nimport { WalletInitializationError } from '@web3auth/base';\nimport { ethErrors } from 'eth-rpc-errors';\nimport { JRPCEngine, createScaffoldMiddleware, createAsyncMiddleware } from '@toruslabs/openlogin-jrpc';\nimport getCreateRandomId from 'json-rpc-random-id';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass BaseProvider extends BaseController {\n  // should be Assigned in setupProvider\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config,\n      state\n    });\n\n    _defineProperty(this, \"_providerEngineProxy\", null);\n\n    if (!config.chainConfig) throw WalletInitializationError.invalidProviderConfigError(\"Please provide chainConfig\");\n    if (!config.chainConfig.chainId) throw WalletInitializationError.invalidProviderConfigError(\"Please provide chainId inside chainConfig\");\n    if (!config.chainConfig.rpcTarget) throw WalletInitializationError.invalidProviderConfigError(\"Please provide rpcTarget inside chainConfig\");\n    this.defaultState = {\n      chainId: \"loading\"\n    };\n    this.defaultConfig = {\n      chainConfig: config.chainConfig,\n      networks: {\n        [config.chainConfig.chainId]: config.chainConfig\n      }\n    };\n    super.initialize();\n  }\n\n  get provider() {\n    return this._providerEngineProxy;\n  }\n\n  set provider(_) {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  addChain(chainConfig) {\n    if (!chainConfig.chainId) throw ethErrors.rpc.invalidParams(\"chainId is required\");\n    if (!chainConfig.rpcTarget) throw ethErrors.rpc.invalidParams(\"chainId is required\");\n    this.configure({\n      networks: _objectSpread(_objectSpread({}, this.config.networks), {}, {\n        [chainConfig.chainId]: chainConfig\n      })\n    });\n  }\n\n  getChainConfig(chainId) {\n    var _this$config$networks;\n\n    const chainConfig = (_this$config$networks = this.config.networks) === null || _this$config$networks === void 0 ? void 0 : _this$config$networks[chainId];\n    if (!chainConfig) throw ethErrors.rpc.invalidRequest(\"Chain \".concat(chainId, \" is not supported, please add chainConfig for it\"));\n    return chainConfig;\n  }\n\n  getProviderEngineProxy() {\n    return this._providerEngineProxy;\n  }\n\n  updateProviderEngineProxy(providerEngineProxy) {\n    if (this._providerEngineProxy) {\n      this._providerEngineProxy.setTarget(providerEngineProxy);\n    } else {\n      this._providerEngineProxy = createEventEmitterProxy(providerEngineProxy);\n    }\n  }\n\n}\n\nclass CommonPrivateKeyProvider {\n  constructor() {\n    _defineProperty(this, \"_providerEngineProxy\", null);\n  }\n\n  get provider() {\n    return this._providerEngineProxy;\n  }\n\n  set provider(_) {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  addChain(_) {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  async setupProvider(privKey) {\n    const privKeyMiddleware = this.getPrivKeyMiddleware(privKey);\n    const engine = new JRPCEngine();\n    engine.push(privKeyMiddleware);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n  }\n\n  async switchChain(_) {\n    return Promise.resolve();\n  }\n\n  getProviderEngineProxy() {\n    return this._providerEngineProxy;\n  }\n\n  updateProviderEngineProxy(providerEngineProxy) {\n    if (this._providerEngineProxy) {\n      this._providerEngineProxy.setTarget(providerEngineProxy);\n    } else {\n      this._providerEngineProxy = createEventEmitterProxy(providerEngineProxy);\n    }\n  }\n\n  getPrivKeyMiddleware(privKey) {\n    const middleware = {\n      getPrivatekey: async () => {\n        return privKey;\n      }\n    };\n    return this.createPrivKeyMiddleware(middleware);\n  }\n\n  createPrivKeyMiddleware(_ref) {\n    let {\n      getPrivatekey\n    } = _ref;\n\n    async function getPrivatekeyHandler(_, res) {\n      res.result = await getPrivatekey();\n    }\n\n    return createScaffoldMiddleware({\n      private_key: createAsyncMiddleware(getPrivatekeyHandler)\n    });\n  }\n\n}\n\n_defineProperty(CommonPrivateKeyProvider, \"getProviderInstance\", async params => {\n  const providerFactory = new CommonPrivateKeyProvider();\n  await providerFactory.setupProvider(params.privKey);\n  return providerFactory;\n});\n\nconst createRandomId = getCreateRandomId();\n\nexport { BaseProvider, CommonPrivateKeyProvider, createRandomId };\n//# sourceMappingURL=baseProvider.esm.js.map\n",null,null,null,null,null,null,null,"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { createFetchMiddleware, providerFromEngine } from '@toruslabs/base-controllers';\nimport { mergeMiddleware, createAsyncMiddleware, JRPCEngine } from '@toruslabs/openlogin-jrpc';\nimport { CHAIN_NAMESPACES, isHexStrict, WalletInitializationError } from '@web3auth/base';\nimport { BaseProvider } from '@web3auth/base-provider';\nimport bs58 from 'bs58';\nimport { ethErrors } from 'eth-rpc-errors';\nimport { PublicKey, Connection, Keypair } from '@solana/web3.js';\nimport nacl from '@toruslabs/tweetnacl-js';\n\nfunction createChainIdMiddleware(chainId) {\n  return (req, res, next, end) => {\n    if (req.method === \"solana_chainId\") {\n      res.result = chainId;\n      return end();\n    }\n\n    return next();\n  };\n}\nfunction createProviderConfigMiddleware(providerConfig) {\n  return (req, res, next, end) => {\n    if (req.method === \"solana_provider_config\") {\n      res.result = providerConfig;\n      return end();\n    }\n\n    return next();\n  };\n}\nfunction createConfigMiddleware(providerConfig) {\n  const {\n    chainId\n  } = providerConfig;\n  return mergeMiddleware([createChainIdMiddleware(chainId), createProviderConfigMiddleware(providerConfig)]);\n}\nfunction createJsonRpcClient(providerConfig) {\n  const {\n    rpcTarget\n  } = providerConfig;\n  const fetchMiddleware = createFetchMiddleware({\n    rpcTarget\n  });\n  const networkMiddleware = mergeMiddleware([createConfigMiddleware(providerConfig), fetchMiddleware]);\n  return {\n    networkMiddleware,\n    fetchMiddleware\n  };\n}\n\nfunction createGetAccountsMiddleware(_ref) {\n  let {\n    getAccounts\n  } = _ref;\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== \"getAccounts\") return next();\n    if (!getAccounts) throw new Error(\"WalletMiddleware - opts.getAccounts not provided\"); // This calls from the prefs controller\n\n    const accounts = await getAccounts(request);\n    response.result = accounts;\n    return undefined;\n  });\n}\nfunction createRequestAccountsMiddleware(_ref2) {\n  let {\n    requestAccounts\n  } = _ref2;\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== \"requestAccounts\") return next();\n    if (!requestAccounts) throw new Error(\"WalletMiddleware - opts.requestAccounts not provided\"); // This calls the UI login function\n\n    const accounts = await requestAccounts(request);\n    response.result = accounts;\n    return undefined;\n  });\n}\nfunction createGenericJRPCMiddleware(targetMethod, handler) {\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== targetMethod) return next();\n    if (!handler) throw new Error(\"WalletMiddleware - \".concat(targetMethod, \" not provided\"));\n    const result = await handler(request);\n    response.result = result;\n    return undefined;\n  });\n}\nfunction createSolanaMiddleware(providerHandlers) {\n  const {\n    getAccounts,\n    requestAccounts,\n    signTransaction,\n    signAndSendTransaction,\n    signAllTransactions,\n    signMessage,\n    getPrivateKey,\n    getSecretKey\n  } = providerHandlers;\n  return mergeMiddleware([createRequestAccountsMiddleware({\n    requestAccounts\n  }), createGetAccountsMiddleware({\n    getAccounts\n  }), createGenericJRPCMiddleware(\"signTransaction\", signTransaction), createGenericJRPCMiddleware(\"signAndSendTransaction\", signAndSendTransaction), createGenericJRPCMiddleware(\"signAllTransactions\", signAllTransactions), createGenericJRPCMiddleware(\"signMessage\", signMessage), createGenericJRPCMiddleware(\"solanaPrivateKey\", getPrivateKey), createGenericJRPCMiddleware(\"solanaSecretKey\", getSecretKey)]);\n}\nfunction createChainSwitchMiddleware(_ref3) {\n  let {\n    addNewChainConfig,\n    switchSolanaChain\n  } = _ref3;\n  return mergeMiddleware([createGenericJRPCMiddleware(\"addSolanaChain\", addNewChainConfig), createGenericJRPCMiddleware(\"switchSolanaChain\", switchSolanaChain)]);\n}\nfunction createAccountMiddleware(_ref4) {\n  let {\n    updatePrivatekey\n  } = _ref4;\n  return mergeMiddleware([createGenericJRPCMiddleware(\"updateAccount\", updatePrivatekey)]);\n}\n\nfunction ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$3(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass BaseInjectedProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread$3(_objectSpread$3({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.SOLANA\n        })\n      },\n      state\n    });\n  }\n\n  async switchChain(_) {\n    return Promise.resolve();\n  }\n\n  async setupProvider(injectedProvider) {\n    const engine = new JRPCEngine();\n    const providerHandlers = this.getProviderHandlers(injectedProvider);\n    const solanaMiddleware = createSolanaMiddleware(providerHandlers);\n    engine.push(solanaMiddleware);\n    const configMiddleware = createConfigMiddleware(this.config.chainConfig);\n    engine.push(configMiddleware);\n    const injectedProviderProxy = this.getInjectedProviderProxy(injectedProvider);\n\n    if (injectedProviderProxy) {\n      engine.push(injectedProviderProxy);\n    }\n\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await this.lookupNetwork();\n  }\n\n  async lookupNetwork() {\n    const {\n      chainConfig\n    } = this.config;\n    this.update({\n      chainId: chainConfig.chainId\n    });\n    return chainConfig.chainId || \"\";\n  }\n\n  getInjectedProviderProxy(_) {\n    return undefined;\n  }\n\n}\n\nconst getBaseProviderHandlers = injectedProvider => {\n  const providerHandlers = {\n    requestAccounts: async () => {\n      return injectedProvider.publicKey ? [bs58.encode(injectedProvider.publicKey.toBytes())] : [];\n    },\n    getAccounts: async () => injectedProvider.publicKey ? [bs58.encode(injectedProvider.publicKey.toBytes())] : [],\n    getPrivateKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    getSecretKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    signTransaction: async req => {\n      const transaction = await injectedProvider.signTransaction(req.params.message);\n      return transaction;\n    },\n    signMessage: async req => {\n      const sigData = await injectedProvider.signMessage(req.params.message, req.params.display);\n      return sigData.signature;\n    },\n    signAllTransactions: async req => {\n      var _req$params, _req$params2;\n\n      if (!((_req$params = req.params) !== null && _req$params !== void 0 && _req$params.message) || !((_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.message.length)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const transaction = await injectedProvider.signAllTransactions(req.params.message);\n      return transaction;\n    },\n    signAndSendTransaction: async req => {\n      const txRes = await injectedProvider.signAndSendTransaction(req.params.message);\n      return {\n        signature: txRes.signature\n      };\n    }\n  };\n  return providerHandlers;\n};\n\nfunction ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction createInjectedProviderProxyMiddleware(provider) {\n  return createAsyncMiddleware(async (req, res, _next) => {\n    const result = await provider.request(_objectSpread$2({}, req));\n    res.result = result;\n  });\n}\n\nclass PhantomInjectedProvider extends BaseInjectedProvider {\n  getProviderHandlers(injectedProvider) {\n    return getBaseProviderHandlers(injectedProvider);\n  }\n\n  getInjectedProviderProxy(injectedProvider) {\n    return createInjectedProviderProxyMiddleware(injectedProvider);\n  }\n\n}\n\nconst getSlopeHandlers = (injectedProvider, getProviderEngineProxy) => {\n  const providerHandlers = {\n    requestAccounts: async () => {\n      const {\n        data\n      } = await injectedProvider.connect();\n      return [data.publicKey];\n    },\n    getAccounts: async () => {\n      const {\n        data\n      } = await injectedProvider.connect();\n      return [data.publicKey];\n    },\n    getPrivateKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    getSecretKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    signTransaction: async req => {\n      const txMessage = req.params.message;\n      if (!txMessage) throw ethErrors.rpc.invalidRequest({\n        message: \"Invalid transaction message\"\n      });\n      const {\n        data\n      } = await injectedProvider.signTransaction(bs58.encode(txMessage.serializeMessage()));\n      if (!data.publicKey || !data.signature) throw new Error(\"Invalid signature from slope wallet\");\n      const publicKey = new PublicKey(data.publicKey);\n      const signature = bs58.decode(data.signature);\n      txMessage.addSignature(publicKey, signature);\n      return txMessage;\n    },\n    signMessage: async req => {\n      const response = await injectedProvider.signMessage(req.params.message);\n      return bs58.decode(response.data.signature);\n    },\n    signAndSendTransaction: async req => {\n      const provider = getProviderEngineProxy();\n      if (!provider) throw ethErrors.provider.custom({\n        message: \"Provider is not initialized\",\n        code: 4902\n      });\n      const txMessage = req.params.message;\n      if (!txMessage) throw ethErrors.rpc.invalidRequest({\n        message: \"Invalid transaction message\"\n      });\n      const {\n        data\n      } = await injectedProvider.signTransaction(bs58.encode(txMessage.serializeMessage()));\n      if (!data.publicKey || !data.signature) throw new Error(\"Invalid signature from slope wallet\");\n      const publicKey = new PublicKey(data.publicKey);\n      const signature = bs58.decode(data.signature);\n      txMessage.addSignature(publicKey, signature);\n      const chainConfig = await provider.request({\n        method: \"solana_provider_config\",\n        params: []\n      });\n      const conn = new Connection(chainConfig.rpcTarget);\n      const res = await conn.sendRawTransaction(txMessage.serialize());\n      return {\n        signature: res\n      };\n    },\n    signAllTransactions: async req => {\n      var _req$params, _req$params2, _data$signatures;\n\n      if (!((_req$params = req.params) !== null && _req$params !== void 0 && _req$params.message) || !((_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.message.length)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const allTxns = req.params.message;\n      const {\n        length\n      } = allTxns;\n      const unsignedTx = [];\n\n      for (let i = 0; i < length; i++) {\n        unsignedTx.push(bs58.encode(req.params.message[i].serializeMessage()));\n      }\n\n      const {\n        msg,\n        data\n      } = await injectedProvider.signAllTransactions(unsignedTx);\n      if (!data.publicKey || ((_data$signatures = data.signatures) === null || _data$signatures === void 0 ? void 0 : _data$signatures.length) !== length) throw new Error(msg);\n      const publicKey = new PublicKey(data.publicKey);\n\n      for (let i = 0; i < length; i++) {\n        const signature = bs58.decode(data.signatures[i]);\n        allTxns[i].addSignature(publicKey, signature);\n      }\n\n      return allTxns;\n    }\n  };\n  return providerHandlers;\n};\n\nclass SlopeInjectedProxyProvider extends BaseInjectedProvider {\n  getProviderHandlers(injectedProvider) {\n    return getSlopeHandlers(injectedProvider, this.getProviderEngineProxy.bind(this));\n  }\n\n}\n\nconst getSolflareHandlers = (injectedProvider, getProviderEngineProxy) => {\n  const solflareProviderHandlers = getBaseProviderHandlers(injectedProvider);\n\n  solflareProviderHandlers.signAndSendTransaction = async req => {\n    const provider = getProviderEngineProxy();\n    if (!provider) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const transaction = await injectedProvider.signTransaction(req.params.message);\n    const chainConfig = await provider.request({\n      method: \"solana_provider_config\",\n      params: []\n    });\n    const conn = new Connection(chainConfig.rpcTarget);\n    const res = await conn.sendRawTransaction(transaction.serialize());\n    return {\n      signature: res\n    };\n  };\n\n  return solflareProviderHandlers;\n};\n\nclass SolflareInjectedProvider extends BaseInjectedProvider {\n  getProviderHandlers(injectedProvider) {\n    return getSolflareHandlers(injectedProvider, this.getProviderEngineProxy.bind(this));\n  }\n\n}\n\nconst getSolletHandlers = (injectedProvider, getProviderEngineProxy) => {\n  const providerHandlers = getBaseProviderHandlers(injectedProvider);\n\n  providerHandlers.signMessage = async req => {\n    const {\n      signature\n    } = await injectedProvider.sign(req.params.message, \"utf8\");\n    return signature;\n  };\n\n  providerHandlers.signAndSendTransaction = async req => {\n    const provider = getProviderEngineProxy();\n    if (!provider) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const transaction = await injectedProvider.signTransaction(req.params.message);\n    const chainConfig = await provider.request({\n      method: \"solana_provider_config\",\n      params: []\n    });\n    const conn = new Connection(chainConfig.rpcTarget);\n    const res = await conn.sendRawTransaction(transaction.serialize());\n    return {\n      signature: res\n    };\n  };\n\n  return providerHandlers;\n};\n\nclass SolletInjectedProvider extends BaseInjectedProvider {\n  getProviderHandlers(injectedProvider) {\n    return getSolletHandlers(injectedProvider, this.getProviderEngineProxy.bind(this));\n  }\n\n}\n\nconst getTorusHandlers = injectedProvider => {\n  const providerHandlers = {\n    requestAccounts: async () => {\n      const accounts = await injectedProvider.request({\n        method: \"solana_requestAccounts\",\n        params: {}\n      });\n      return accounts;\n    },\n    getAccounts: async () => {\n      const accounts = await injectedProvider.request({\n        method: \"solana_requestAccounts\",\n        params: {}\n      });\n      return accounts;\n    },\n    getPrivateKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    getSecretKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    signMessage: async req => {\n      var _req$params;\n\n      if (!((_req$params = req.params) !== null && _req$params !== void 0 && _req$params.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const message = await injectedProvider.signMessage(req.params.message);\n      return message;\n    },\n    signTransaction: async req => {\n      var _req$params2;\n\n      if (!((_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const txMessage = req.params.message;\n      const response = await injectedProvider.signTransaction(txMessage);\n      return response;\n    },\n    signAndSendTransaction: async req => {\n      var _req$params3;\n\n      if (!((_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const txMessage = req.params.message;\n      const response = await injectedProvider.sendTransaction(txMessage);\n      return {\n        signature: response\n      };\n    },\n    signAllTransactions: async req => {\n      var _req$params4, _req$params5;\n\n      if (!((_req$params4 = req.params) !== null && _req$params4 !== void 0 && _req$params4.message) || !((_req$params5 = req.params) !== null && _req$params5 !== void 0 && _req$params5.message.length)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const transactions = req.params.message;\n      const response = await injectedProvider.signAllTransactions(transactions);\n      return response;\n    }\n  };\n  return providerHandlers;\n};\n\nfunction ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass TorusInjectedProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread$1(_objectSpread$1({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.SOLANA\n        })\n      },\n      state\n    });\n  }\n\n  async switchChain(_) {\n    return Promise.resolve();\n  }\n\n  async setupProvider(injectedProvider) {\n    this.handleInjectedProviderUpdate(injectedProvider);\n    await this.setupEngine(injectedProvider);\n  }\n\n  async lookupNetwork() {\n    if (!this.provider) throw ethErrors.provider.custom({\n      message: \"Torus solana provider is not initialized\",\n      code: 4902\n    });\n    const {\n      chainId\n    } = this.config.chainConfig;\n    const connectedChainId = await this.provider.request({\n      method: \"solana_chainId\"\n    });\n    const connectedHexChainId = isHexStrict(connectedChainId.toString()) ? connectedChainId : \"0x\".concat(parseInt(connectedChainId, 10).toString(16));\n    if (chainId !== connectedHexChainId) throw WalletInitializationError.rpcConnectionError(\"Invalid network, net_version is: \".concat(connectedHexChainId, \", expected: \").concat(chainId));\n    this.update({\n      chainId: connectedHexChainId\n    });\n    this.provider.emit(\"connect\", {\n      chainId: this.state.chainId\n    });\n    this.provider.emit(\"chainChanged\", this.state.chainId);\n    return this.state.chainId;\n  }\n\n  async setupEngine(injectedProvider) {\n    const providerHandlers = getTorusHandlers(injectedProvider);\n    const solanaMiddleware = createSolanaMiddleware(providerHandlers);\n    const injectedProviderProxy = createInjectedProviderProxyMiddleware(injectedProvider);\n    const engine = new JRPCEngine();\n    engine.push(solanaMiddleware);\n    engine.push(injectedProviderProxy);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await this.lookupNetwork();\n  }\n\n  async handleInjectedProviderUpdate(injectedProvider) {\n    injectedProvider.on(\"accountsChanged\", async accounts => {\n      this.provider.emit(\"accountsChanged\", accounts);\n    });\n    injectedProvider.on(\"chainChanged\", async chainId => {\n      const connectedHexChainId = isHexStrict(chainId) ? chainId : \"0x\".concat(parseInt(chainId, 10).toString(16)); // Check if chainId changed and trigger event\n\n      this.configure({\n        chainConfig: _objectSpread$1(_objectSpread$1({}, this.config.chainConfig), {}, {\n          chainId: connectedHexChainId\n        })\n      });\n      await this.setupProvider(injectedProvider);\n    });\n  }\n\n}\n\nasync function getProviderHandlers(_ref) {\n  let {\n    privKey,\n    getProviderEngineProxy\n  } = _ref;\n\n  const keyPairGenerator = () => {\n    return Keypair.fromSecretKey(Buffer.from(privKey, \"hex\"));\n  };\n\n  if (typeof privKey !== \"string\") throw WalletInitializationError.invalidParams(\"privKey must be a string\");\n  const keyPair = keyPairGenerator();\n  const providerHandlers = {\n    requestAccounts: async () => {\n      return [keyPair.publicKey.toBase58()];\n    },\n    getAccounts: async () => [keyPair.publicKey.toBase58()],\n    getPrivateKey: async () => privKey,\n    getSecretKey: async () => bs58.encode(keyPair.secretKey),\n    signTransaction: async req => {\n      var _req$params;\n\n      if (!((_req$params = req.params) !== null && _req$params !== void 0 && _req$params.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const transaction = req.params.message;\n      transaction.partialSign(keyPair);\n      return transaction;\n    },\n    signMessage: async req => {\n      var _req$params2;\n\n      if (!((_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const signedMsg = nacl.sign.detached(req.params.message, keyPair.secretKey);\n      return signedMsg;\n    },\n    signAndSendTransaction: async req => {\n      var _req$params3;\n\n      if (!((_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const _providerEngineProxy = getProviderEngineProxy();\n\n      if (!_providerEngineProxy) throw ethErrors.provider.custom({\n        message: \"Provider is not initialized\",\n        code: 4902\n      });\n      const transaction = req.params.message;\n      transaction.sign(keyPair);\n      const sig = await _providerEngineProxy.request({\n        method: \"sendTransaction\",\n        params: [bs58.encode(transaction.serialize())]\n      });\n      return {\n        signature: sig\n      };\n    },\n    signAllTransactions: async req => {\n      var _req$params4, _req$params5, _req$params6;\n\n      if (!((_req$params4 = req.params) !== null && _req$params4 !== void 0 && _req$params4.message) || !((_req$params5 = req.params) !== null && _req$params5 !== void 0 && _req$params5.message.length)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const txns = (_req$params6 = req.params) === null || _req$params6 === void 0 ? void 0 : _req$params6.message;\n\n      for (const tx of txns || []) {\n        const transaction = tx;\n        transaction.partialSign(keyPair);\n      }\n\n      return txns;\n    }\n  };\n  return providerHandlers;\n}\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass SolanaPrivateKeyProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread(_objectSpread({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.SOLANA\n        })\n      },\n      state\n    });\n  }\n\n  async enable() {\n    if (!this.state.privateKey) throw ethErrors.provider.custom({\n      message: \"Private key is not found in state, plz pass it in constructor state param\",\n      code: 4902\n    });\n    await this.setupProvider(this.state.privateKey);\n    return this._providerEngineProxy.request({\n      method: \"eth_accounts\"\n    });\n  }\n\n  async setupProvider(privKey) {\n    const providerHandlers = await getProviderHandlers({\n      privKey,\n      getProviderEngineProxy: this.getProviderEngineProxy.bind(this)\n    });\n    const solanaMiddleware = createSolanaMiddleware(providerHandlers);\n    const engine = new JRPCEngine();\n    const {\n      networkMiddleware\n    } = createJsonRpcClient(this.config.chainConfig);\n    engine.push(this.getChainSwitchMiddleware());\n    engine.push(this.getAccountMiddleware());\n    engine.push(solanaMiddleware);\n    engine.push(networkMiddleware);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await this.lookupNetwork();\n  }\n\n  async updateAccount(params) {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const existingKey = await this._providerEngineProxy.request({\n      method: \"solanaPrivateKey\"\n    });\n\n    if (existingKey !== params.privateKey) {\n      await this.setupProvider(params.privateKey);\n\n      this._providerEngineProxy.emit(\"accountsChanged\", {\n        accounts: await this._providerEngineProxy.request({\n          method: \"requestAccounts\"\n        })\n      });\n    }\n  }\n\n  async switchChain(params) {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const chainConfig = this.getChainConfig(params.chainId);\n    this.update({\n      chainId: \"loading\"\n    });\n    this.configure({\n      chainConfig\n    });\n    const privKey = await this._providerEngineProxy.request({\n      method: \"solanaPrivateKey\"\n    });\n    await this.setupProvider(privKey);\n  }\n\n  async lookupNetwork() {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const health = await this._providerEngineProxy.request({\n      method: \"getHealth\",\n      params: []\n    });\n    const {\n      chainConfig\n    } = this.config;\n    if (health !== \"ok\") throw WalletInitializationError.rpcConnectionError(\"Failed to lookup network for following rpc target: \".concat(chainConfig.rpcTarget));\n    this.update({\n      chainId: chainConfig.chainId\n    });\n\n    if (this.state.chainId !== chainConfig.chainId) {\n      this.provider.emit(\"chainChanged\", this.state.chainId);\n      this.provider.emit(\"connect\", {\n        chainId: this.state.chainId\n      });\n    }\n\n    return this.state.chainId;\n  }\n\n  getChainSwitchMiddleware() {\n    const chainSwitchHandlers = {\n      addNewChainConfig: async req => {\n        if (!req.params) throw ethErrors.rpc.invalidParams(\"Missing request params\");\n        const {\n          chainId,\n          chainName,\n          rpcUrls,\n          blockExplorerUrls,\n          nativeCurrency\n        } = req.params;\n        if (!chainId) throw ethErrors.rpc.invalidParams(\"Missing chainId in chainParams\");\n        if (!rpcUrls || rpcUrls.length === 0) throw ethErrors.rpc.invalidParams(\"Missing rpcUrls in chainParams\");\n        if (!nativeCurrency) throw ethErrors.rpc.invalidParams(\"Missing nativeCurrency in chainParams\");\n        this.addChain({\n          chainNamespace: CHAIN_NAMESPACES.SOLANA,\n          chainId,\n          ticker: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.symbol) || \"SOL\",\n          tickerName: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.name) || \"Solana\",\n          displayName: chainName,\n          rpcTarget: rpcUrls[0],\n          blockExplorer: (blockExplorerUrls === null || blockExplorerUrls === void 0 ? void 0 : blockExplorerUrls[0]) || \"\"\n        });\n      },\n      switchSolanaChain: async req => {\n        if (!req.params) throw ethErrors.rpc.invalidParams(\"Missing request params\");\n        if (!req.params.chainId) throw ethErrors.rpc.invalidParams(\"Missing chainId\");\n        await this.switchChain(req.params);\n      }\n    };\n    const chainSwitchMiddleware = createChainSwitchMiddleware(chainSwitchHandlers);\n    return chainSwitchMiddleware;\n  }\n\n  getAccountMiddleware() {\n    const accountHandlers = {\n      updatePrivatekey: async req => {\n        if (!req.params) throw ethErrors.rpc.invalidParams(\"Missing request params\");\n        if (!req.params.privateKey) throw ethErrors.rpc.invalidParams(\"Missing privateKey\");\n        const {\n          privateKey\n        } = req.params;\n        await this.updateAccount({\n          privateKey\n        });\n      }\n    };\n    return createAccountMiddleware(accountHandlers);\n  }\n\n}\n\n_defineProperty(SolanaPrivateKeyProvider, \"getProviderInstance\", async params => {\n  const providerFactory = new SolanaPrivateKeyProvider({\n    config: {\n      chainConfig: params.chainConfig\n    }\n  });\n  await providerFactory.setupProvider(params.privKey);\n  return providerFactory;\n});\n\nclass SolanaWallet {\n  constructor(provider) {\n    _defineProperty(this, \"provider\", void 0);\n\n    this.provider = provider;\n  }\n\n  async requestAccounts() {\n    const accounts = await this.provider.request({\n      method: \"requestAccounts\",\n      params: {}\n    });\n    return accounts;\n  }\n\n  async signAndSendTransaction(transaction) {\n    const {\n      signature\n    } = await this.provider.request({\n      method: \"signAndSendTransaction\",\n      params: {\n        message: transaction\n      }\n    });\n    return {\n      signature\n    };\n  }\n\n  async signTransaction(transaction) {\n    const signedTransaction = await this.provider.request({\n      method: \"signTransaction\",\n      params: {\n        message: transaction\n      }\n    });\n    return signedTransaction;\n  }\n\n  async signAllTransactions(transactions) {\n    const signedTransactions = await this.provider.request({\n      method: \"signAllTransactions\",\n      params: {\n        message: transactions\n      }\n    });\n    return signedTransactions;\n  }\n\n  async signMessage(data) {\n    const response = await this.provider.request({\n      method: \"signMessage\",\n      params: {\n        message: data\n      }\n    });\n    return response;\n  }\n\n  async request(args) {\n    const result = await this.provider.request(args);\n    return result;\n  }\n\n}\n\nexport { PhantomInjectedProvider, SlopeInjectedProxyProvider, SolanaPrivateKeyProvider, SolanaWallet, SolflareInjectedProvider, SolletInjectedProvider, TorusInjectedProvider };\n//# sourceMappingURL=solanaProvider.esm.js.map\n",null,null,null,null,null,null,null,null,"var basex = require('base-x')\nvar ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\nmodule.exports = basex(ALPHABET)\n","'use strict'\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n// @ts-ignore\nvar _Buffer = require('safe-buffer').Buffer\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256)\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i)\n    var xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  var BASE = ALPHABET.length\n  var LEADER = ALPHABET.charAt(0)\n  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (Array.isArray(source) || source instanceof Uint8Array) { source = _Buffer.from(source) }\n    if (!_Buffer.isBuffer(source)) { throw new TypeError('Expected Buffer') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0\n    var length = 0\n    var pbegin = 0\n    var pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    var b58 = new Uint8Array(size)\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin]\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return _Buffer.alloc(0) }\n    var psz = 0\n        // Skip and count leading '1's.\n    var zeroes = 0\n    var length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size)\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)]\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n        // Skip leading zeroes in b256.\n    var it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    var vch = _Buffer.allocUnsafe(zeroes + (size - it4))\n    vch.fill(0x00, 0, zeroes)\n    var j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nmodule.exports = base\n","import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport Torus from '@toruslabs/solana-embed';\nimport { WALLET_ADAPTERS, ADAPTER_NAMESPACES, CHAIN_NAMESPACES, ADAPTER_CATEGORY, ADAPTER_STATUS, getChainConfig, log, ADAPTER_EVENTS, WalletInitializationError, Web3AuthError, WalletLoginError } from '@web3auth/base';\nimport { BaseSolanaAdapter } from '@web3auth/base-solana-adapter';\nimport { TorusInjectedProvider } from '@web3auth/solana-provider';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass SolanaWalletAdapter extends BaseSolanaAdapter {\n  constructor() {\n    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n\n    _defineProperty(this, \"name\", WALLET_ADAPTERS.TORUS_SOLANA);\n\n    _defineProperty(this, \"adapterNamespace\", ADAPTER_NAMESPACES.SOLANA);\n\n    _defineProperty(this, \"currentChainNamespace\", CHAIN_NAMESPACES.SOLANA);\n\n    _defineProperty(this, \"type\", ADAPTER_CATEGORY.EXTERNAL);\n\n    _defineProperty(this, \"status\", ADAPTER_STATUS.NOT_READY);\n\n    _defineProperty(this, \"torusInstance\", null);\n\n    _defineProperty(this, \"torusWalletOptions\", void 0);\n\n    _defineProperty(this, \"initParams\", void 0);\n\n    _defineProperty(this, \"loginSettings\", {});\n\n    _defineProperty(this, \"solanaProvider\", null);\n\n    _defineProperty(this, \"rehydrated\", false);\n\n    this.torusWalletOptions = params.adapterSettings || {};\n    this.initParams = params.initParams || {};\n    this.loginSettings = params.loginSettings || {};\n    this.chainConfig = params.chainConfig || null;\n    this.sessionTime = params.sessionTime || 86400;\n  }\n\n  get provider() {\n    if (this.status === ADAPTER_STATUS.CONNECTED && this.solanaProvider) {\n      var _this$solanaProvider;\n\n      return ((_this$solanaProvider = this.solanaProvider) === null || _this$solanaProvider === void 0 ? void 0 : _this$solanaProvider.provider) || null;\n    }\n\n    return null;\n  }\n\n  set provider(_) {\n    throw new Error(\"Not implemented\");\n  }\n\n  async init(options) {\n    super.checkInitializationRequirements(); // set chainConfig for mainnet by default if not set\n\n    let network;\n\n    if (!this.chainConfig) {\n      this.chainConfig = getChainConfig(CHAIN_NAMESPACES.SOLANA, \"0x1\");\n      const {\n        blockExplorer,\n        displayName,\n        ticker,\n        tickerName,\n        rpcTarget,\n        chainId\n      } = this.chainConfig;\n      network = {\n        chainId,\n        rpcTarget,\n        blockExplorerUrl: blockExplorer,\n        displayName,\n        ticker,\n        tickerName,\n        logo: \"\"\n      };\n    } else {\n      const {\n        chainId,\n        blockExplorer,\n        displayName,\n        rpcTarget,\n        ticker,\n        tickerName\n      } = this.chainConfig;\n      network = {\n        chainId,\n        rpcTarget,\n        blockExplorerUrl: blockExplorer,\n        displayName,\n        tickerName,\n        ticker,\n        logo: \"\"\n      };\n    }\n\n    this.torusInstance = new Torus(this.torusWalletOptions);\n    log.debug(\"initializing torus solana adapter init\");\n    await this.torusInstance.init(_objectSpread(_objectSpread({\n      showTorusButton: false\n    }, this.initParams), {}, {\n      network\n    }));\n    this.solanaProvider = new TorusInjectedProvider({\n      config: {\n        chainConfig: this.chainConfig\n      }\n    });\n    this.status = ADAPTER_STATUS.READY;\n    this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.TORUS_SOLANA);\n\n    try {\n      log.debug(\"initializing torus solana adapter\");\n\n      if (options.autoConnect) {\n        this.rehydrated = true;\n        await this.connect();\n      }\n    } catch (error) {\n      log.error(\"Failed to connect with cached torus solana provider\", error);\n      this.emit(ADAPTER_EVENTS.ERRORED, error);\n    }\n  }\n\n  async connect() {\n    super.checkConnectionRequirements();\n    if (!this.torusInstance) throw WalletInitializationError.notReady(\"Torus wallet is not initialized\");\n    if (!this.solanaProvider) throw WalletInitializationError.notReady(\"Torus wallet is not initialized\");\n    this.status = ADAPTER_STATUS.CONNECTING;\n    this.emit(ADAPTER_EVENTS.CONNECTING, {\n      adapter: WALLET_ADAPTERS.TORUS_SOLANA\n    });\n\n    try {\n      await this.torusInstance.login(this.loginSettings);\n\n      try {\n        const torusInpageProvider = this.torusInstance.provider;\n        torusInpageProvider.sendTransaction = this.torusInstance.sendTransaction.bind(this.torusInstance);\n        torusInpageProvider.signAllTransactions = this.torusInstance.signAllTransactions.bind(this.torusInstance);\n        torusInpageProvider.signMessage = this.torusInstance.signMessage.bind(this.torusInstance);\n        torusInpageProvider.signTransaction = this.torusInstance.signTransaction.bind(this.torusInstance);\n        await this.solanaProvider.setupProvider(torusInpageProvider);\n      } catch (error) {\n        // some issue in solana wallet, always connecting to mainnet on init.\n        // fallback to change network if not connected to correct one on login.\n        if (error instanceof Web3AuthError && error.code === 5010) {\n          const {\n            chainId,\n            blockExplorer,\n            displayName,\n            rpcTarget,\n            ticker,\n            tickerName\n          } = this.chainConfig;\n          const network = {\n            chainId,\n            rpcTarget,\n            blockExplorerUrl: blockExplorer,\n            displayName,\n            tickerName,\n            ticker,\n            logo: \"\"\n          };\n          await this.torusInstance.setProvider(network);\n        } else {\n          throw error;\n        }\n      }\n\n      this.status = ADAPTER_STATUS.CONNECTED;\n      this.torusInstance.showTorusButton();\n      this.emit(ADAPTER_STATUS.CONNECTED, {\n        adapter: WALLET_ADAPTERS.TORUS_SOLANA,\n        reconnected: this.rehydrated\n      });\n      return this.provider;\n    } catch (error) {\n      // ready again to be connected\n      this.status = ADAPTER_STATUS.READY;\n      this.rehydrated = false;\n      this.emit(ADAPTER_EVENTS.ERRORED, error);\n      throw WalletLoginError.connectionError(\"Failed to login with torus solana wallet\");\n    }\n  }\n\n  async disconnect() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      cleanup: false\n    };\n    if (!this.torusInstance) throw WalletInitializationError.notReady(\"Torus wallet is not initialized\");\n    await super.disconnect();\n    await this.torusInstance.logout();\n\n    if (options.cleanup) {\n      // ready to connect again\n      this.status = ADAPTER_STATUS.NOT_READY;\n      this.torusInstance = null;\n      this.solanaProvider = null;\n    } else {\n      // ready to connect again\n      this.status = ADAPTER_STATUS.READY;\n    }\n\n    this.emit(ADAPTER_EVENTS.DISCONNECTED);\n  }\n\n  async getUserInfo() {\n    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.notConnectedError(\"Not connected with wallet\");\n    if (!this.torusInstance) throw WalletInitializationError.notReady(\"Torus wallet is not initialized\");\n    const userInfo = await this.torusInstance.getUserInfo();\n    return userInfo;\n  }\n\n  setAdapterSettings(options) {\n    if (this.status === ADAPTER_STATUS.READY) return;\n\n    if (options !== null && options !== void 0 && options.sessionTime) {\n      this.sessionTime = options.sessionTime;\n    }\n  }\n\n}\n\nexport { SolanaWalletAdapter };\n//# sourceMappingURL=torusSolanaAdapter.esm.js.map\n"],"sourceRoot":""}