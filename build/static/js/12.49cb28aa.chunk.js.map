{"version":3,"sources":["../../src/basePostMessageStream.ts","../../src/safeEventEmitter.ts","../../src/serializableError.ts","../../src/jrpc.ts","../../src/jrpcEngine.ts","../../src/substream.ts","../../src/mux.ts","../../src/postMessageStream.ts","../node_modules/@web3auth/openlogin-adapter/node_modules/loglevel/lib/loglevel.js","../../src/index.ts","../../src/baseProvider.ts","../../src/commonPrivateKeyProvider.ts","../../src/utils.ts","../../src/BaseController.ts","../../src/createEventEmitterProxy.ts","../../src/Network/INetworkController.ts","../../src/enums.ts","../../src/Embed/CommunicationWindowManager.ts","../../src/utils/utils.ts","../../src/Network/createFetchMiddleware.ts","../../src/Preferences/BasePreferencesController.ts","../../src/Transaction/ITransactionController.ts","../../src/constants.ts","../../src/loglevel.ts","../../src/Modal.ts","../../src/MemoryStore.ts","../../src/OpenLoginStore.ts","../../src/Provider.ts","../../src/OpenLogin.ts","../../src/config.ts","../../src/openloginAdapter.ts"],"names":["noop","ACK","BasePostMessageStream","name","target","targetWindow","window","targetOrigin","objectMode","Error","_init","_haveSyn","_name","_target","_targetWindow","_targetOrigin","_onMessage","onMessage","bind","_synIntervalId","addEventListener","_handShake","cork","_write","data","_break","push","err","emit","uncork","originConstraint","postMessage","event","message","origin","source","_onData","_","cb","_postMessage","removeEventListener","Duplex","safeApply","handler","context","args","Reflect","apply","setTimeout","arrayClone","arr","n","length","copy","Array","i","SafeEventEmitter","type","doError","events","_events","undefined","error","er","len","listeners","EventEmitter","SerializableError","code","Number","isInteger","stringify","stack","getRpcPromiseCallback","resolve","reject","unwrapResult","response","isArray","result","createStreamMiddleware","idMap","stream","read","write","res","_encoding","id","processNotification","Object","assign","end","processResponse","_err","middleware","req","next","createScaffoldMiddleware","handlers","method","createIdRemapMiddleware","_end","originalId","newId","randomId","done","createAsyncMiddleware","asyncMiddleware","nextPromise","Promise","resolveNextPromise","returnHandlerCallback","nextWasCalled","asyncNext","runReturnHandlersCallback","JRPCEngine","_middleware","_handleBatch","_handle","_promiseHandle","_runAllMiddleware","middlewareError","isComplete","returnHandlers","_runReturnHandlers","handlerCallback","reqs","all","map","responses","callerReq","jsonrpc","_processRequest","serializeError","_checkForCompletion","middlewareStack","_runMiddleware","reverse","returnHandler","mergeMiddleware","engine","forEach","asMiddleware","Substream","parent","_parent","chunk","callback","IGNORE_SUBSTREAM","Symbol","ObjectMultiplex","opts","_substreams","substream","_cb","once","eos","readable","writable","anyStreamEnd","_error","destroy","console","warn","setupMultiplex","mux","getStream","createStream","pump","PostMessageStream","dataObj","dataObjData","params","dataObjDataParam","_origin","location","root","definition","define","undefinedType","isIE","navigator","test","userAgent","logMethods","bindMethod","obj","methodName","Function","prototype","call","e","arguments","traceForIE","log","trace","realMethod","replaceLoggingMethods","level","loggerName","this","methodFactory","debug","enableLoggingWhenConsoleArrives","defaultMethodFactory","Logger","defaultLevel","factory","currentLevel","self","storageKey","persistLevelIfPossible","levelNum","levelName","toUpperCase","localStorage","ignore","document","cookie","encodeURIComponent","getPersistedLevel","storedLevel","indexOf","exec","slice","levels","clearPersistedLevel","removeItem","getLevel","setLevel","persist","SILENT","setDefaultLevel","resetLevel","enableAll","TRACE","disableAll","initialLevel","defaultLogger","_loggersByName","getLogger","TypeError","logger","_log","noConflict","getLoggers","logLevel","INFO","apiKey","embedHost","sentry","tracingOrigins","tracingPaths","fetchAndTrace","url","init","_url","URL","includes","pathname","transaction","startTransaction","span","startChild","op","fetch","finish","getApiKeyHeaders","headers","debugLogResponse","info","status","statusText","promiseTimeout","ms","promise","timeout","clearTimeout","race","get","options_","customOptions","defaultOptions","mode","useAPIKey","options","merge","ok","json","post","isUrlEncodedData","body","JSON","then","patch","remove","BaseProvider","constructor","config","state","chainConfig","WalletInitializationError","invalidProviderConfigError","chainId","rpcTarget","defaultState","defaultConfig","networks","provider","_providerEngineProxy","addChain","ethErrors","rpc","invalidParams","configure","getChainConfig","invalidRequest","getProviderEngineProxy","updateProviderEngineProxy","providerEngineProxy","setTarget","createEventEmitterProxy","BaseController","CommonPrivateKeyProvider","setupProvider","privKey","privKeyMiddleware","getPrivKeyMiddleware","providerFromEngine","switchChain","getPrivatekey","createPrivKeyMiddleware","private_key","providerFactory","getCreateRandomId","initialState","initialConfig","internalConfig","internalState","overwrite","fullUpdate","key","update","initialize","filterNoop","internalEvents","externalEventFilter","initialTarget","eventFilter","newTarget","oldTarget","eventNames","filter","eventEmitter","rawListeners","getRawListeners","on","removeAllListeners","Proxy","set","value","createRandomId","sendAsync","handle","fallbackError","toString","internal","send","request","COMMUNICATION_JRPC_METHODS","hexString","targetLength","String","padStart","getHeaders","signMessage","privateKey","Buffer","from","stripHexPrefix","msgSig","ecsign","v","r","s","rSig","fromSigned","sSig","vSig","bufferToInt","rStr","padWithZeroes","toUnsigned","sStr","vStr","hex","intToHex","addHexPrefix","concat","concatSig","intToBuffer","RETRIABLE_ERRORS","checkForHttpErrors","fetchRes","methodNotFound","duration","parseResponse","createFetchConfigFromReq","originHttpHeaderKey","parsedUrl","payload","originDomain","fetchParams","Accept","fetchUrl","href","createFetchMiddleware","_next","maxAttempts","retryInterval","attempt","fetchBody","errMsg","some","phrase","TransactionStatus","modalDOMElementID","storeKey","UX_MODE","POPUP","REDIRECT","OPENLOGIN_METHOD","ALLOWED_INTERACTIONS","OPENLOGIN_NETWORK","MAINNET","TESTNET","CYAN","DEVELOPMENT","SK_TESTNET","SUPPORTED_KEY_CURVES","SECP256K1","ED25519","loglevel","documentReady","readyState","htmlToElement","html","template","createElement","trimmedHtml","trim","innerHTML","content","firstChild","replaceUrl","searchParams","queryResult","queryParams","parse","safeatob","keys","hash","substring","hashUrl","hashResult","hashParams","cleanUrl","history","replaceState","windowRef","closedByHandler","closedMonitor","setInterval","closed","clearInterval","ev","pid","close","constructURL","baseURL","query","append","h","storageAvailable","storage","storageExists","storageLength","x","setItem","sessionStorageAvailable","localStorageAvailable","getPopupFeatures","dualScreenLeft","screenLeft","screenX","dualScreenTop","screenTop","screenY","width","innerWidth","documentElement","clientWidth","screen","height","innerHeight","clientHeight","left","Math","abs","top","w","handleStream","eventName","handlerWrapper","removeListener","Modal","modalUrl","initIFrame","setupStream","iframeElem","contentWindow","verifierStream","src","documentIFrameElem","getElementById","modalZIndex","_hideModal","appendChild","onload","initialized","style","setAttribute","entries","k","join","clientId","whiteLabel","loginConfig","_showModal","modalHandler","MemoryStore","store","OpenLoginStore","_storeKey","getItem","resetStore","currStore","getStore","storeNamespace","instance","sessionStorage","finalStoreKey","Provider","iframeUrl","rpcStream","JRPCConnection","rpcEngine","openloginIframeHtml","crossOrigin","rel","relList","supports","head","preloadIframe","OpenLogin","deleteProperty","_iframeUrl","network","modal","initState","no3PC","_startUrl","_popupUrl","redirectUrl","protocol","host","uxMode","replaceUrlOnRedirect","originData","_storageServerUrl","_sessionNamespace","getInstance","startUrl","popupUrl","support3PC","storageServerUrl","sessionNamespace","updateOriginData","getHashQueryParams","sessionId","_getData","_syncState","_check3PCSupport","filteredOriginData","getWhitelist","getWhiteLabel","whitelist","signed_urls","loginProvider","_selectedLogin","_modal","defaultParams","loginParams","allowedInteractions","logoutParams","_clientId","session","userData","timestamp","Date","now","sign","keccak","digest","sig","_user","getPublic","_userSig","base64url","encode","_userData","_originData","_whiteLabelData","_loginConfig","_sessionId","_jrpcRequest","_setPIDData","b64Params","jsonToBase64","_pid","_method","u","open","awaitReq","_rpcRequest","newState","_prompt","cancel","selectedLoginResponse","cleanup","encrypt","ciphertext","decrypt","storeData","userInfo","email","profileImage","aggregateVerifier","verifier","verifierId","typeOfLogin","dappShare","idToken","oAuthIdToken","oAuthAccessToken","dataObject","getOpenloginDefaultOptions","chainNamespace","adapterSettings","loginSettings","OpenloginAdapter","WALLET_ADAPTERS","OPENLOGIN","ADAPTER_NAMESPACES","MULTICHAIN","ADAPTER_CATEGORY","IN_APP","ADAPTER_STATUS","NOT_READY","CHAIN_NAMESPACES","EIP155","openloginOptions","sessionTime","currentChainNamespace","defaultChainIdConfig","OTHER","chainConfigProxy","privKeyProvider","isRedirectResult","redirectResult","openloginInstance","READY","ADAPTER_EVENTS","autoConnect","connect","CONNECTING","adapter","connectWithProvider","ERRORED","WalletLoginError","popupClosed","connectionError","disconnect","CONNECTED","notConnectedError","notReady","logout","DISCONNECTED","authenticateUser","getUserInfo","setAdapterSettings","setChainConfig","customChainConfig","SOLANA","SolanaPrivateKeyProvider","EthereumPrivateKeyProvider","curve","login","extraLoginOptions","login_hint","finalPrivKey","getED25519Key","sk","reconnected","BaseAdapter"],"mappings":"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","file":"static/js/12.49cb28aa.chunk.js","sourcesContent":["import _typeof from '@babel/runtime/helpers/typeof';\nimport _classCallCheck from '@babel/runtime/helpers/classCallCheck';\nimport _createClass from '@babel/runtime/helpers/createClass';\nimport _assertThisInitialized from '@babel/runtime/helpers/assertThisInitialized';\nimport _inherits from '@babel/runtime/helpers/inherits';\nimport _possibleConstructorReturn from '@babel/runtime/helpers/possibleConstructorReturn';\nimport _getPrototypeOf from '@babel/runtime/helpers/getPrototypeOf';\nimport _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { Duplex } from 'readable-stream';\nimport _asyncToGenerator from '@babel/runtime/helpers/asyncToGenerator';\nimport _regeneratorRuntime from '@babel/runtime/regenerator';\nimport { randomId } from '@toruslabs/openlogin-utils';\nimport { EventEmitter } from 'events';\nimport _wrapNativeSuper from '@babel/runtime/helpers/wrapNativeSuper';\nimport stringify from 'fast-safe-stringify';\nimport _slicedToArray from '@babel/runtime/helpers/slicedToArray';\nimport { serializeError } from 'eth-rpc-errors';\nimport eos from 'end-of-stream';\nimport once from 'once';\nimport pump from 'pump';\n\nfunction _createSuper$6(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$6(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$6() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction noop() {\n  return undefined;\n}\nvar SYN = \"SYN\";\nvar ACK = \"ACK\";\nvar BRK = \"BRK\";\nvar BasePostMessageStream = /*#__PURE__*/function (_Duplex) {\n  _inherits(BasePostMessageStream, _Duplex);\n  var _super = _createSuper$6(BasePostMessageStream);\n  function BasePostMessageStream(_ref) {\n    var _this;\n    var name = _ref.name,\n      target = _ref.target,\n      _ref$targetWindow = _ref.targetWindow,\n      targetWindow = _ref$targetWindow === void 0 ? window : _ref$targetWindow,\n      _ref$targetOrigin = _ref.targetOrigin,\n      targetOrigin = _ref$targetOrigin === void 0 ? \"*\" : _ref$targetOrigin;\n    _classCallCheck(this, BasePostMessageStream);\n    _this = _super.call(this, {\n      objectMode: true\n    });\n    _defineProperty(_assertThisInitialized(_this), \"_init\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"_haveSyn\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"_name\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"_target\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"_targetWindow\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"_targetOrigin\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"_onMessage\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"_synIntervalId\", void 0);\n    if (!name || !target) {\n      throw new Error(\"Invalid input.\");\n    }\n    _this._init = false;\n    _this._haveSyn = false;\n    _this._name = name;\n    _this._target = target; // target origin\n    _this._targetWindow = targetWindow;\n    _this._targetOrigin = targetOrigin;\n    _this._onMessage = _this.onMessage.bind(_assertThisInitialized(_this));\n    _this._synIntervalId = null;\n    window.addEventListener(\"message\", _this._onMessage, false);\n    _this._handShake();\n    return _this;\n  }\n  _createClass(BasePostMessageStream, [{\n    key: \"_break\",\n    value: function _break() {\n      this.cork();\n      this._write(BRK, null, noop);\n      this._haveSyn = false;\n      this._init = false;\n    }\n  }, {\n    key: \"_handShake\",\n    value: function _handShake() {\n      this._write(SYN, null, noop);\n      this.cork();\n    }\n  }, {\n    key: \"_onData\",\n    value: function _onData(data) {\n      if (!this._init) {\n        // listen for handshake\n        if (data === SYN) {\n          this._haveSyn = true;\n          this._write(ACK, null, noop);\n        } else if (data === ACK) {\n          this._init = true;\n          if (!this._haveSyn) {\n            this._write(ACK, null, noop);\n          }\n          this.uncork();\n        }\n      } else if (data === BRK) {\n        this._break();\n      } else {\n        // forward message\n        try {\n          this.push(data);\n        } catch (err) {\n          this.emit(\"error\", err);\n        }\n      }\n    }\n  }, {\n    key: \"_postMessage\",\n    value: function _postMessage(data) {\n      var originConstraint = this._targetOrigin;\n      this._targetWindow.postMessage({\n        target: this._target,\n        data: data\n      }, originConstraint);\n    }\n  }, {\n    key: \"onMessage\",\n    value: function onMessage(event) {\n      var message = event.data;\n      // validate message\n      if (this._targetOrigin !== \"*\" && event.origin !== this._targetOrigin || event.source !== this._targetWindow || _typeof(message) !== \"object\" || message.target !== this._name || !message.data) {\n        return;\n      }\n      this._onData(message.data);\n    }\n  }, {\n    key: \"_read\",\n    value: function _read() {\n      return undefined;\n    }\n  }, {\n    key: \"_write\",\n    value: function _write(data, _, cb) {\n      this._postMessage(data);\n      cb();\n    }\n  }, {\n    key: \"_destroy\",\n    value: function _destroy() {\n      window.removeEventListener(\"message\", this._onMessage, false);\n    }\n  }]);\n  return BasePostMessageStream;\n}(Duplex);\n\nfunction _createSuper$5(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$5(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$5() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction safeApply(handler, context, args) {\n  try {\n    Reflect.apply(handler, context, args);\n  } catch (err) {\n    // Throw error after timeout so as not to interrupt the stack\n    setTimeout(function () {\n      throw err;\n    });\n  }\n}\nfunction arrayClone(arr) {\n  var n = arr.length;\n  var copy = new Array(n);\n  for (var i = 0; i < n; i += 1) {\n    copy[i] = arr[i];\n  }\n  return copy;\n}\nvar SafeEventEmitter = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(SafeEventEmitter, _EventEmitter);\n  var _super = _createSuper$5(SafeEventEmitter);\n  function SafeEventEmitter() {\n    _classCallCheck(this, SafeEventEmitter);\n    return _super.apply(this, arguments);\n  }\n  _createClass(SafeEventEmitter, [{\n    key: \"emit\",\n    value: function emit(type) {\n      var doError = type === \"error\";\n      var events = this._events;\n      if (events !== undefined) {\n        doError = doError && events.error === undefined;\n      } else if (!doError) {\n        return false;\n      }\n      // If there is no 'error' event listener then throw.\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n      if (doError) {\n        var er;\n        if (args.length > 0) {\n          er = args[0];\n        }\n        if (er instanceof Error) {\n          // Note: The comments on the `throw` lines are intentional, they show\n          // up in Node's output if this results in an unhandled exception.\n          throw er; // Unhandled 'error' event\n        }\n        // At least give some kind of context to the user\n        var err = new Error(\"Unhandled error.\".concat(er ? \" (\".concat(er.message, \")\") : \"\"));\n        err.context = er;\n        throw err; // Unhandled 'error' event\n      }\n\n      var handler = events[type];\n      if (handler === undefined) {\n        return false;\n      }\n      if (typeof handler === \"function\") {\n        safeApply(handler, this, args);\n      } else {\n        var len = handler.length;\n        var listeners = arrayClone(handler);\n        for (var i = 0; i < len; i += 1) {\n          safeApply(listeners[i], this, args);\n        }\n      }\n      return true;\n    }\n  }]);\n  return SafeEventEmitter;\n}(EventEmitter);\n\nfunction _createSuper$4(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$4(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$4() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nvar SerializableError = /*#__PURE__*/function (_Error) {\n  _inherits(SerializableError, _Error);\n  var _super = _createSuper$4(SerializableError);\n  function SerializableError(_ref) {\n    var _this;\n    var code = _ref.code,\n      message = _ref.message,\n      data = _ref.data;\n    _classCallCheck(this, SerializableError);\n    if (!Number.isInteger(code)) {\n      throw new Error(\"code must be an integer\");\n    }\n    if (!message || typeof message !== \"string\") {\n      throw new Error(\"message must be string\");\n    }\n    _this = _super.call(this, message);\n    _defineProperty(_assertThisInitialized(_this), \"code\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"data\", void 0);\n    _this.code = code;\n    if (data !== undefined) {\n      _this.data = data;\n    }\n    return _this;\n  }\n  _createClass(SerializableError, [{\n    key: \"toString\",\n    value: function toString() {\n      return stringify({\n        code: this.code,\n        message: this.message,\n        data: this.data,\n        stack: this.stack\n      });\n    }\n  }]);\n  return SerializableError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar getRpcPromiseCallback = function getRpcPromiseCallback(resolve, reject) {\n  var unwrapResult = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  return function (error, response) {\n    if (error || response.error) {\n      reject(error || response.error);\n    } else if (!unwrapResult || Array.isArray(response)) {\n      resolve(response);\n    } else {\n      resolve(response.result);\n    }\n  };\n};\nfunction createErrorMiddleware(log) {\n  return function (req, res, next, end) {\n    try {\n      // json-rpc-engine will terminate the request when it notices this error\n      if (typeof req.method !== \"string\" || !req.method) {\n        res.error = new SerializableError({\n          code: -32603,\n          message: \"invalid method\"\n        });\n        end();\n        return;\n      }\n      next(function (done) {\n        var error = res.error;\n        if (!error) {\n          return done();\n        }\n        log.error(\"OpenLogin - RPC Error: \".concat(error.message), error);\n        return done();\n      });\n    } catch (error) {\n      log.error(\"OpenLogin - RPC Error thrown: \".concat(error.message), error);\n      res.error = new SerializableError({\n        code: -32603,\n        message: error.message\n      });\n      end();\n    }\n  };\n}\nfunction createStreamMiddleware() {\n  var idMap = {};\n  function readNoop() {\n    return false;\n  }\n  var events = new SafeEventEmitter();\n  function processResponse(res) {\n    var context = idMap[res.id];\n    if (!context) {\n      throw new Error(\"StreamMiddleware - Unknown response id \\\"\".concat(res.id, \"\\\"\"));\n    }\n    delete idMap[res.id];\n    // copy whole res onto original res\n    Object.assign(context.res, res);\n    // run callback on empty stack,\n    // prevent internal stream-handler from catching errors\n    setTimeout(context.end);\n  }\n  function processNotification(res) {\n    events.emit(\"notification\", res);\n  }\n  function processMessage(res, _encoding, cb) {\n    var err;\n    try {\n      var isNotification = !res.id;\n      if (isNotification) {\n        processNotification(res);\n      } else {\n        processResponse(res);\n      }\n    } catch (_err) {\n      err = _err;\n    }\n    // continue processing stream\n    cb(err);\n  }\n  var stream = new Duplex({\n    objectMode: true,\n    read: readNoop,\n    write: processMessage\n  });\n  var middleware = function middleware(req, res, next, end) {\n    // write req to stream\n    stream.push(req);\n    // register request on id map\n    idMap[req.id] = {\n      req: req,\n      res: res,\n      next: next,\n      end: end\n    };\n  };\n  return {\n    events: events,\n    middleware: middleware,\n    stream: stream\n  };\n}\nfunction createScaffoldMiddleware(handlers) {\n  return function (req, res, next, end) {\n    var handler = handlers[req.method];\n    // if no handler, return\n    if (handler === undefined) {\n      return next();\n    }\n    // if handler is fn, call as middleware\n    if (typeof handler === \"function\") {\n      return handler(req, res, next, end);\n    }\n    // if handler is some other value, use as result\n    res.result = handler;\n    return end();\n  };\n}\nfunction createIdRemapMiddleware() {\n  return function (req, res, next, _end) {\n    var originalId = req.id;\n    var newId = randomId();\n    req.id = newId;\n    res.id = newId;\n    next(function (done) {\n      req.id = originalId;\n      res.id = originalId;\n      done();\n    });\n  };\n}\nfunction createLoggerMiddleware(logger) {\n  return function (req, res, next, _) {\n    logger.debug(\"REQ\", req, \"RES\", res);\n    next();\n  };\n}\nfunction createAsyncMiddleware(asyncMiddleware) {\n  return /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(req, res, next, end) {\n      var resolveNextPromise, nextPromise, returnHandlerCallback, nextWasCalled, asyncNext;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              // nextPromise is the key to the implementation\n              // it is resolved by the return handler passed to the\n              // \"next\" function\n              nextPromise = new Promise(function (resolve) {\n                resolveNextPromise = resolve;\n              });\n              returnHandlerCallback = null;\n              nextWasCalled = false; // This will be called by the consumer's async middleware.\n              asyncNext = /*#__PURE__*/function () {\n                var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n                  return _regeneratorRuntime.wrap(function _callee$(_context) {\n                    while (1) {\n                      switch (_context.prev = _context.next) {\n                        case 0:\n                          nextWasCalled = true;\n                          // We pass a return handler to next(). When it is called by the engine,\n                          // the consumer's async middleware will resume executing.\n                          next(function (runReturnHandlersCallback) {\n                            // This callback comes from JRPCEngine._runReturnHandlers\n                            returnHandlerCallback = runReturnHandlersCallback;\n                            resolveNextPromise();\n                          });\n                          _context.next = 4;\n                          return nextPromise;\n                        case 4:\n                        case \"end\":\n                          return _context.stop();\n                      }\n                    }\n                  }, _callee);\n                }));\n                return function asyncNext() {\n                  return _ref2.apply(this, arguments);\n                };\n              }();\n              _context2.prev = 4;\n              _context2.next = 7;\n              return asyncMiddleware(req, res, asyncNext);\n            case 7:\n              if (!nextWasCalled) {\n                _context2.next = 13;\n                break;\n              }\n              _context2.next = 10;\n              return nextPromise;\n            case 10:\n              // we must wait until the return handler is called\n              returnHandlerCallback(null);\n              _context2.next = 14;\n              break;\n            case 13:\n              end(null);\n            case 14:\n              _context2.next = 19;\n              break;\n            case 16:\n              _context2.prev = 16;\n              _context2.t0 = _context2[\"catch\"](4);\n              if (returnHandlerCallback) {\n                returnHandlerCallback(_context2.t0);\n              } else {\n                end(_context2.t0);\n              }\n            case 19:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, null, [[4, 16]]);\n    }));\n    return function (_x, _x2, _x3, _x4) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _createSuper$3(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$3(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$3() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n/**\n * A JSON-RPC request and response processor.\n * Give it a stack of middleware, pass it requests, and get back responses.\n */\nvar JRPCEngine = /*#__PURE__*/function (_SafeEventEmitter) {\n  _inherits(JRPCEngine, _SafeEventEmitter);\n  var _super = _createSuper$3(JRPCEngine);\n  function JRPCEngine() {\n    var _this;\n    _classCallCheck(this, JRPCEngine);\n    _this = _super.call(this);\n    _defineProperty(_assertThisInitialized(_this), \"_middleware\", void 0);\n    _this._middleware = [];\n    return _this;\n  }\n  /**\n   * Serially executes the given stack of middleware.\n   *\n   * @returns An array of any error encountered during middleware execution,\n   * a boolean indicating whether the request was completed, and an array of\n   * middleware-defined return handlers.\n   */\n  _createClass(JRPCEngine, [{\n    key: \"push\",\n    value:\n    /**\n     * Add a middleware function to the engine's middleware stack.\n     *\n     * @param middleware - The middleware function to add.\n     */\n    function push(middleware) {\n      this._middleware.push(middleware);\n    }\n  }, {\n    key: \"handle\",\n    value: function handle(req, cb) {\n      if (cb && typeof cb !== \"function\") {\n        throw new Error('\"callback\" must be a function if provided.');\n      }\n      if (Array.isArray(req)) {\n        if (cb) {\n          return this._handleBatch(req, cb);\n        }\n        return this._handleBatch(req);\n      }\n      if (cb) {\n        return this._handle(req, cb);\n      }\n      return this._promiseHandle(req);\n    }\n    /**\n     * Returns this engine as a middleware function that can be pushed to other\n     * engines.\n     *\n     * @returns This engine as a middleware function.\n     */\n  }, {\n    key: \"asMiddleware\",\n    value: function asMiddleware() {\n      var _this2 = this;\n      return /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(req, res, next, end) {\n          var _yield$JRPCEngine$_ru, _yield$JRPCEngine$_ru2, middlewareError, isComplete, returnHandlers;\n          return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  _context2.prev = 0;\n                  _context2.next = 3;\n                  return JRPCEngine._runAllMiddleware(req, res, _this2._middleware);\n                case 3:\n                  _yield$JRPCEngine$_ru = _context2.sent;\n                  _yield$JRPCEngine$_ru2 = _slicedToArray(_yield$JRPCEngine$_ru, 3);\n                  middlewareError = _yield$JRPCEngine$_ru2[0];\n                  isComplete = _yield$JRPCEngine$_ru2[1];\n                  returnHandlers = _yield$JRPCEngine$_ru2[2];\n                  if (!isComplete) {\n                    _context2.next = 12;\n                    break;\n                  }\n                  _context2.next = 11;\n                  return JRPCEngine._runReturnHandlers(returnHandlers);\n                case 11:\n                  return _context2.abrupt(\"return\", end(middlewareError));\n                case 12:\n                  return _context2.abrupt(\"return\", next( /*#__PURE__*/function () {\n                    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(handlerCallback) {\n                      return _regeneratorRuntime.wrap(function _callee$(_context) {\n                        while (1) {\n                          switch (_context.prev = _context.next) {\n                            case 0:\n                              _context.prev = 0;\n                              _context.next = 3;\n                              return JRPCEngine._runReturnHandlers(returnHandlers);\n                            case 3:\n                              _context.next = 8;\n                              break;\n                            case 5:\n                              _context.prev = 5;\n                              _context.t0 = _context[\"catch\"](0);\n                              return _context.abrupt(\"return\", handlerCallback(_context.t0));\n                            case 8:\n                              return _context.abrupt(\"return\", handlerCallback());\n                            case 9:\n                            case \"end\":\n                              return _context.stop();\n                          }\n                        }\n                      }, _callee, null, [[0, 5]]);\n                    }));\n                    return function (_x5) {\n                      return _ref2.apply(this, arguments);\n                    };\n                  }()));\n                case 15:\n                  _context2.prev = 15;\n                  _context2.t0 = _context2[\"catch\"](0);\n                  return _context2.abrupt(\"return\", end(_context2.t0));\n                case 18:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2, null, [[0, 15]]);\n        }));\n        return function (_x, _x2, _x3, _x4) {\n          return _ref.apply(this, arguments);\n        };\n      }();\n    }\n  }, {\n    key: \"_handleBatch\",\n    value: function () {\n      var _handleBatch2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(reqs, cb) {\n        var responses;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.prev = 0;\n                _context3.next = 3;\n                return Promise.all(\n                // 1. Begin executing each request in the order received\n                reqs.map(this._promiseHandle.bind(this)));\n              case 3:\n                responses = _context3.sent;\n                if (!cb) {\n                  _context3.next = 6;\n                  break;\n                }\n                return _context3.abrupt(\"return\", cb(null, responses));\n              case 6:\n                return _context3.abrupt(\"return\", responses);\n              case 9:\n                _context3.prev = 9;\n                _context3.t0 = _context3[\"catch\"](0);\n                if (!cb) {\n                  _context3.next = 13;\n                  break;\n                }\n                return _context3.abrupt(\"return\", cb(_context3.t0));\n              case 13:\n                throw _context3.t0;\n              case 14:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[0, 9]]);\n      }));\n      function _handleBatch(_x6, _x7) {\n        return _handleBatch2.apply(this, arguments);\n      }\n      return _handleBatch;\n    }()\n    /**\n     * A promise-wrapped _handle.\n     */\n  }, {\n    key: \"_promiseHandle\",\n    value: function _promiseHandle(req) {\n      var _this3 = this;\n      return new Promise(function (resolve) {\n        _this3._handle(req, function (_err, res) {\n          // There will always be a response, and it will always have any error\n          // that is caught and propagated.\n          resolve(res);\n        });\n      });\n    }\n    /**\n     * Ensures that the request object is valid, processes it, and passes any\n     * error and the response object to the given callback.\n     *\n     * Does not reject.\n     */\n  }, {\n    key: \"_handle\",\n    value: function () {\n      var _handle2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(callerReq, cb) {\n        var _error2, _error3, req, res, error;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!(!callerReq || Array.isArray(callerReq) || _typeof(callerReq) !== \"object\")) {\n                  _context4.next = 3;\n                  break;\n                }\n                _error2 = new SerializableError({\n                  code: -32603,\n                  message: \"request must be plain object\"\n                });\n                return _context4.abrupt(\"return\", cb(_error2, {\n                  id: undefined,\n                  jsonrpc: \"2.0\",\n                  error: _error2\n                }));\n              case 3:\n                if (!(typeof callerReq.method !== \"string\")) {\n                  _context4.next = 6;\n                  break;\n                }\n                _error3 = new SerializableError({\n                  code: -32603,\n                  message: \"method must be string\"\n                });\n                return _context4.abrupt(\"return\", cb(_error3, {\n                  id: callerReq.id,\n                  jsonrpc: \"2.0\",\n                  error: _error3\n                }));\n              case 6:\n                req = _objectSpread$1({}, callerReq);\n                res = {\n                  id: req.id,\n                  jsonrpc: req.jsonrpc\n                };\n                error = null;\n                _context4.prev = 9;\n                _context4.next = 12;\n                return this._processRequest(req, res);\n              case 12:\n                _context4.next = 17;\n                break;\n              case 14:\n                _context4.prev = 14;\n                _context4.t0 = _context4[\"catch\"](9);\n                // A request handler error, a re-thrown middleware error, or something\n                // unexpected.\n                error = _context4.t0;\n              case 17:\n                if (error) {\n                  // Ensure no result is present on an errored response\n                  delete res.result;\n                  if (!res.error) {\n                    res.error = serializeError(error);\n                  }\n                }\n                return _context4.abrupt(\"return\", cb(error, res));\n              case 19:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[9, 14]]);\n      }));\n      function _handle(_x8, _x9) {\n        return _handle2.apply(this, arguments);\n      }\n      return _handle;\n    }()\n    /**\n     * For the given request and response, runs all middleware and their return\n     * handlers, if any, and ensures that internal request processing semantics\n     * are satisfied.\n     */\n  }, {\n    key: \"_processRequest\",\n    value: function () {\n      var _processRequest2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(req, res) {\n        var _yield$JRPCEngine$_ru3, _yield$JRPCEngine$_ru4, error, isComplete, returnHandlers;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return JRPCEngine._runAllMiddleware(req, res, this._middleware);\n              case 2:\n                _yield$JRPCEngine$_ru3 = _context5.sent;\n                _yield$JRPCEngine$_ru4 = _slicedToArray(_yield$JRPCEngine$_ru3, 3);\n                error = _yield$JRPCEngine$_ru4[0];\n                isComplete = _yield$JRPCEngine$_ru4[1];\n                returnHandlers = _yield$JRPCEngine$_ru4[2];\n                // Throw if \"end\" was not called, or if the response has neither a result\n                // nor an error.\n                JRPCEngine._checkForCompletion(req, res, isComplete);\n                // The return handlers should run even if an error was encountered during\n                // middleware processing.\n                _context5.next = 10;\n                return JRPCEngine._runReturnHandlers(returnHandlers);\n              case 10:\n                if (!error) {\n                  _context5.next = 12;\n                  break;\n                }\n                throw error;\n              case 12:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n      function _processRequest(_x10, _x11) {\n        return _processRequest2.apply(this, arguments);\n      }\n      return _processRequest;\n    }()\n  }], [{\n    key: \"_runAllMiddleware\",\n    value: function () {\n      var _runAllMiddleware2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(req, res, middlewareStack) {\n        var returnHandlers, error, isComplete, _iterator, _step, middleware, _yield$JRPCEngine$_ru5, _yield$JRPCEngine$_ru6;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                returnHandlers = [];\n                error = null;\n                isComplete = false; // Go down stack of middleware, call and collect optional returnHandlers\n                _iterator = _createForOfIteratorHelper(middlewareStack);\n                _context6.prev = 4;\n                _iterator.s();\n              case 6:\n                if ((_step = _iterator.n()).done) {\n                  _context6.next = 18;\n                  break;\n                }\n                middleware = _step.value;\n                _context6.next = 10;\n                return JRPCEngine._runMiddleware(req, res, middleware, returnHandlers);\n              case 10:\n                _yield$JRPCEngine$_ru5 = _context6.sent;\n                _yield$JRPCEngine$_ru6 = _slicedToArray(_yield$JRPCEngine$_ru5, 2);\n                error = _yield$JRPCEngine$_ru6[0];\n                isComplete = _yield$JRPCEngine$_ru6[1];\n                if (!isComplete) {\n                  _context6.next = 16;\n                  break;\n                }\n                return _context6.abrupt(\"break\", 18);\n              case 16:\n                _context6.next = 6;\n                break;\n              case 18:\n                _context6.next = 23;\n                break;\n              case 20:\n                _context6.prev = 20;\n                _context6.t0 = _context6[\"catch\"](4);\n                _iterator.e(_context6.t0);\n              case 23:\n                _context6.prev = 23;\n                _iterator.f();\n                return _context6.finish(23);\n              case 26:\n                return _context6.abrupt(\"return\", [error, isComplete, returnHandlers.reverse()]);\n              case 27:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, null, [[4, 20, 23, 26]]);\n      }));\n      function _runAllMiddleware(_x12, _x13, _x14) {\n        return _runAllMiddleware2.apply(this, arguments);\n      }\n      return _runAllMiddleware;\n    }()\n    /**\n     * Runs an individual middleware.\n     *\n     * @returns An array of any error encountered during middleware exection,\n     * and a boolean indicating whether the request should end.\n     */\n  }, {\n    key: \"_runMiddleware\",\n    value: function _runMiddleware(req, res, middleware, returnHandlers) {\n      return new Promise(function (resolve) {\n        var end = function end(err) {\n          var error = err || res.error;\n          if (error) {\n            res.error = serializeError(error);\n          }\n          // True indicates that the request should end\n          resolve([error, true]);\n        };\n        var next = function next(returnHandler) {\n          if (res.error) {\n            end(res.error);\n          } else {\n            if (returnHandler) {\n              if (typeof returnHandler !== \"function\") {\n                end(new SerializableError({\n                  code: -32603,\n                  message: \"JRPCEngine: 'next' return handlers must be functions\"\n                }));\n              }\n              returnHandlers.push(returnHandler);\n            }\n            // False indicates that the request should not end\n            resolve([null, false]);\n          }\n        };\n        try {\n          middleware(req, res, next, end);\n        } catch (error) {\n          end(error);\n        }\n      });\n    }\n    /**\n     * Serially executes array of return handlers. The request and response are\n     * assumed to be in their scope.\n     */\n  }, {\n    key: \"_runReturnHandlers\",\n    value: function () {\n      var _runReturnHandlers2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(handlers) {\n        var _iterator2, _step2, _loop;\n        return _regeneratorRuntime.wrap(function _callee7$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _iterator2 = _createForOfIteratorHelper(handlers);\n                _context8.prev = 1;\n                _loop = /*#__PURE__*/_regeneratorRuntime.mark(function _loop() {\n                  var handler;\n                  return _regeneratorRuntime.wrap(function _loop$(_context7) {\n                    while (1) {\n                      switch (_context7.prev = _context7.next) {\n                        case 0:\n                          handler = _step2.value;\n                          _context7.next = 3;\n                          return new Promise(function (resolve, reject) {\n                            handler(function (err) {\n                              return err ? reject(err) : resolve();\n                            });\n                          });\n                        case 3:\n                        case \"end\":\n                          return _context7.stop();\n                      }\n                    }\n                  }, _loop);\n                });\n                _iterator2.s();\n              case 4:\n                if ((_step2 = _iterator2.n()).done) {\n                  _context8.next = 8;\n                  break;\n                }\n                return _context8.delegateYield(_loop(), \"t0\", 6);\n              case 6:\n                _context8.next = 4;\n                break;\n              case 8:\n                _context8.next = 13;\n                break;\n              case 10:\n                _context8.prev = 10;\n                _context8.t1 = _context8[\"catch\"](1);\n                _iterator2.e(_context8.t1);\n              case 13:\n                _context8.prev = 13;\n                _iterator2.f();\n                return _context8.finish(13);\n              case 16:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee7, null, [[1, 10, 13, 16]]);\n      }));\n      function _runReturnHandlers(_x15) {\n        return _runReturnHandlers2.apply(this, arguments);\n      }\n      return _runReturnHandlers;\n    }()\n    /**\n     * Throws an error if the response has neither a result nor an error, or if\n     * the \"isComplete\" flag is falsy.\n     */\n  }, {\n    key: \"_checkForCompletion\",\n    value: function _checkForCompletion(req, res, isComplete) {\n      if (!(\"result\" in res) && !(\"error\" in res)) {\n        throw new SerializableError({\n          code: -32603,\n          message: \"Response has no error or result for request\"\n        });\n      }\n      if (!isComplete) {\n        throw new SerializableError({\n          code: -32603,\n          message: \"Nothing ended request\"\n        });\n      }\n    }\n  }]);\n  return JRPCEngine;\n}(SafeEventEmitter);\nfunction mergeMiddleware(middlewareStack) {\n  var engine = new JRPCEngine();\n  middlewareStack.forEach(function (middleware) {\n    return engine.push(middleware);\n  });\n  return engine.asMiddleware();\n}\nfunction createEngineStream(opts) {\n  if (!opts || !opts.engine) {\n    throw new Error(\"Missing engine parameter!\");\n  }\n  var engine = opts.engine;\n  // eslint-disable-next-line prefer-const\n  var stream;\n  function read() {\n    return undefined;\n  }\n  function write(req, _encoding, cb) {\n    engine.handle(req, function (_err, res) {\n      stream.push(res);\n    });\n    cb();\n  }\n  stream = new Duplex({\n    objectMode: true,\n    read: read,\n    write: write\n  });\n  // forward notifications\n  if (engine.on) {\n    engine.on(\"notification\", function (message) {\n      stream.push(message);\n    });\n  }\n  return stream;\n}\n\nfunction _createSuper$2(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$2(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$2() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nvar Substream = /*#__PURE__*/function (_Duplex) {\n  _inherits(Substream, _Duplex);\n  var _super = _createSuper$2(Substream);\n  function Substream(_ref) {\n    var _this;\n    var parent = _ref.parent,\n      name = _ref.name;\n    _classCallCheck(this, Substream);\n    _this = _super.call(this, {\n      objectMode: true\n    });\n    _defineProperty(_assertThisInitialized(_this), \"_parent\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"_name\", void 0);\n    _this._parent = parent;\n    _this._name = name;\n    return _this;\n  }\n  /**\n   * Explicitly sets read operations to a no-op.\n   */\n  _createClass(Substream, [{\n    key: \"_read\",\n    value: function _read() {\n      return undefined;\n    }\n    /**\n     * Called when data should be written to this writable stream.\n     *\n     * @param chunk - Arbitrary object to write\n     * @param encoding - Encoding to use when writing payload\n     * @param callback - Called when writing is complete or an error occurs\n     */\n  }, {\n    key: \"_write\",\n    value: function _write(chunk, _encoding, callback) {\n      this._parent.push({\n        name: this._name,\n        data: chunk\n      });\n      callback();\n    }\n  }]);\n  return Substream;\n}(Duplex);\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$1() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nvar IGNORE_SUBSTREAM = Symbol(\"IGNORE_SUBSTREAM\");\nvar ObjectMultiplex = /*#__PURE__*/function (_Duplex) {\n  _inherits(ObjectMultiplex, _Duplex);\n  var _super = _createSuper$1(ObjectMultiplex);\n  function ObjectMultiplex() {\n    var _this;\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, ObjectMultiplex);\n    _this = _super.call(this, _objectSpread(_objectSpread({}, opts), {}, {\n      objectMode: true\n    }));\n    _defineProperty(_assertThisInitialized(_this), \"_substreams\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"getStream\", void 0);\n    _this._substreams = {};\n    return _this;\n  }\n  _createClass(ObjectMultiplex, [{\n    key: \"createStream\",\n    value: function createStream(name) {\n      // validate name\n      if (!name) {\n        throw new Error(\"ObjectMultiplex - name must not be empty\");\n      }\n      if (this._substreams[name]) {\n        throw new Error(\"ObjectMultiplex - Substream for name \\\"\".concat(name, \"\\\" already exists\"));\n      }\n      // create substream\n      var substream = new Substream({\n        parent: this,\n        name: name\n      });\n      this._substreams[name] = substream;\n      // listen for parent stream to end\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      anyStreamEnd(this, function (_error) {\n        return substream.destroy(_error || undefined);\n      });\n      return substream;\n    }\n    // ignore streams (dont display orphaned data warning)\n  }, {\n    key: \"ignoreStream\",\n    value: function ignoreStream(name) {\n      // validate name\n      if (!name) {\n        throw new Error(\"ObjectMultiplex - name must not be empty\");\n      }\n      if (this._substreams[name]) {\n        throw new Error(\"ObjectMultiplex - Substream for name \\\"\".concat(name, \"\\\" already exists\"));\n      }\n      // set\n      this._substreams[name] = IGNORE_SUBSTREAM;\n    }\n  }, {\n    key: \"_read\",\n    value: function _read() {\n      return undefined;\n    }\n  }, {\n    key: \"_write\",\n    value: function _write(chunk, _encoding, callback) {\n      var name = chunk.name,\n        data = chunk.data;\n      if (!name) {\n        window.console.warn(\"ObjectMultiplex - malformed chunk without name \\\"\".concat(chunk, \"\\\"\"));\n        return callback();\n      }\n      // get corresponding substream\n      var substream = this._substreams[name];\n      if (!substream) {\n        window.console.warn(\"ObjectMultiplex - orphaned data for stream \\\"\".concat(name, \"\\\"\"));\n        return callback();\n      }\n      // push data into substream\n      if (substream !== IGNORE_SUBSTREAM) {\n        substream.push(data);\n      }\n      return callback();\n    }\n  }]);\n  return ObjectMultiplex;\n}(Duplex);\n// util\nfunction anyStreamEnd(stream, _cb) {\n  var cb = once(_cb);\n  eos(stream, {\n    readable: false\n  }, cb);\n  eos(stream, {\n    writable: false\n  }, cb);\n}\nfunction setupMultiplex(stream) {\n  var mux = new ObjectMultiplex();\n  mux.getStream = function streamHelper(name) {\n    if (this._substreams[name]) {\n      return this._substreams[name];\n    }\n    return this.createStream(name);\n  };\n  pump(stream, mux, stream, function (err) {\n    if (err) window.console.error(err);\n  });\n  return mux;\n}\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nvar PostMessageStream = /*#__PURE__*/function (_BasePostMessageStrea) {\n  _inherits(PostMessageStream, _BasePostMessageStrea);\n  var _super = _createSuper(PostMessageStream);\n  function PostMessageStream() {\n    _classCallCheck(this, PostMessageStream);\n    return _super.apply(this, arguments);\n  }\n  _createClass(PostMessageStream, [{\n    key: \"_postMessage\",\n    value: function _postMessage(data) {\n      var originConstraint = this._targetOrigin;\n      if (_typeof(data) === \"object\") {\n        var dataObj = data;\n        if (_typeof(dataObj.data) === \"object\") {\n          var dataObjData = dataObj.data;\n          if (Array.isArray(dataObjData.params) && dataObjData.params.length > 0) {\n            var dataObjDataParam = dataObjData.params[0];\n            if (dataObjDataParam._origin) {\n              originConstraint = dataObjDataParam._origin;\n            }\n            // add a constraint for the response\n            dataObjDataParam._origin = window.location.origin;\n          }\n        }\n      }\n      this._targetWindow.postMessage({\n        target: this._target,\n        data: data\n      }, originConstraint);\n    }\n  }]);\n  return PostMessageStream;\n}(BasePostMessageStream);\n\nexport { BasePostMessageStream, IGNORE_SUBSTREAM, JRPCEngine, ObjectMultiplex, PostMessageStream, SafeEventEmitter, SerializableError, Substream, createAsyncMiddleware, createEngineStream, createErrorMiddleware, createIdRemapMiddleware, createLoggerMiddleware, createScaffoldMiddleware, createStreamMiddleware, getRpcPromiseCallback, mergeMiddleware, setupMultiplex };\n//# sourceMappingURL=openloginJrpc.esm.js.map\n",null,null,null,null,null,null,null,"/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (root, definition) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        define(definition);\n    } else if (typeof module === 'object' && module.exports) {\n        module.exports = definition();\n    } else {\n        root.log = definition();\n    }\n}(this, function () {\n    \"use strict\";\n\n    // Slightly dubious tricks to cut down minimized file size\n    var noop = function() {};\n    var undefinedType = \"undefined\";\n    var isIE = (typeof window !== undefinedType) && (typeof window.navigator !== undefinedType) && (\n        /Trident\\/|MSIE /.test(window.navigator.userAgent)\n    );\n\n    var logMethods = [\n        \"trace\",\n        \"debug\",\n        \"info\",\n        \"warn\",\n        \"error\"\n    ];\n\n    // Cross-browser bind equivalent that works at least back to IE6\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === 'function') {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\n                };\n            }\n        }\n    }\n\n    // Trace() doesn't print the message in IE, so for that case we need to wrap it\n    function traceForIE() {\n        if (console.log) {\n            if (console.log.apply) {\n                console.log.apply(console, arguments);\n            } else {\n                // In old IE, native console methods themselves don't have apply().\n                Function.prototype.apply.apply(console.log, [console, arguments]);\n            }\n        }\n        if (console.trace) console.trace();\n    }\n\n    // Build the best logging method possible for this env\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\n    function realMethod(methodName) {\n        if (methodName === 'debug') {\n            methodName = 'log';\n        }\n\n        if (typeof console === undefinedType) {\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (methodName === 'trace' && isIE) {\n            return traceForIE;\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, 'log');\n        } else {\n            return noop;\n        }\n    }\n\n    // These private functions always need `this` to be set properly\n\n    function replaceLoggingMethods(level, loggerName) {\n        /*jshint validthis:true */\n        for (var i = 0; i < logMethods.length; i++) {\n            var methodName = logMethods[i];\n            this[methodName] = (i < level) ?\n                noop :\n                this.methodFactory(methodName, level, loggerName);\n        }\n\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n    }\n\n    // In old IE versions, the console isn't present until you first open it.\n    // We build realMethod() replacements here that regenerate logging methods\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n        return function () {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this, level, loggerName);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n\n    // By default, we use closely bound real methods wherever possible, and\n    // otherwise we wait for a console to appear, and then try again.\n    function defaultMethodFactory(methodName, level, loggerName) {\n        /*jshint validthis:true */\n        return realMethod(methodName) ||\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n\n    function Logger(name, defaultLevel, factory) {\n      var self = this;\n      var currentLevel;\n      defaultLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\n\n      var storageKey = \"loglevel\";\n      if (typeof name === \"string\") {\n        storageKey += \":\" + name;\n      } else if (typeof name === \"symbol\") {\n        storageKey = undefined;\n      }\n\n      function persistLevelIfPossible(levelNum) {\n          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n\n          if (typeof window === undefinedType || !storageKey) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage[storageKey] = levelName;\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n          } catch (ignore) {}\n      }\n\n      function getPersistedLevel() {\n          var storedLevel;\n\n          if (typeof window === undefinedType || !storageKey) return;\n\n          try {\n              storedLevel = window.localStorage[storageKey];\n          } catch (ignore) {}\n\n          // Fallback to cookies if local storage gives us nothing\n          if (typeof storedLevel === undefinedType) {\n              try {\n                  var cookie = window.document.cookie;\n                  var location = cookie.indexOf(\n                      encodeURIComponent(storageKey) + \"=\");\n                  if (location !== -1) {\n                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n                  }\n              } catch (ignore) {}\n          }\n\n          // If the stored level is not valid, treat it as if nothing was stored.\n          if (self.levels[storedLevel] === undefined) {\n              storedLevel = undefined;\n          }\n\n          return storedLevel;\n      }\n\n      function clearPersistedLevel() {\n          if (typeof window === undefinedType || !storageKey) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage.removeItem(storageKey);\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC\";\n          } catch (ignore) {}\n      }\n\n      /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */\n\n      self.name = name;\n\n      self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\n          \"ERROR\": 4, \"SILENT\": 5};\n\n      self.methodFactory = factory || defaultMethodFactory;\n\n      self.getLevel = function () {\n          return currentLevel;\n      };\n\n      self.setLevel = function (level, persist) {\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n              level = self.levels[level.toUpperCase()];\n          }\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n              currentLevel = level;\n              if (persist !== false) {  // defaults to true\n                  persistLevelIfPossible(level);\n              }\n              replaceLoggingMethods.call(self, level, name);\n              if (typeof console === undefinedType && level < self.levels.SILENT) {\n                  return \"No console available for logging\";\n              }\n          } else {\n              throw \"log.setLevel() called with invalid level: \" + level;\n          }\n      };\n\n      self.setDefaultLevel = function (level) {\n          defaultLevel = level;\n          if (!getPersistedLevel()) {\n              self.setLevel(level, false);\n          }\n      };\n\n      self.resetLevel = function () {\n          self.setLevel(defaultLevel, false);\n          clearPersistedLevel();\n      };\n\n      self.enableAll = function(persist) {\n          self.setLevel(self.levels.TRACE, persist);\n      };\n\n      self.disableAll = function(persist) {\n          self.setLevel(self.levels.SILENT, persist);\n      };\n\n      // Initialize with the right level\n      var initialLevel = getPersistedLevel();\n      if (initialLevel == null) {\n          initialLevel = defaultLevel;\n      }\n      self.setLevel(initialLevel, false);\n    }\n\n    /*\n     *\n     * Top-level API\n     *\n     */\n\n    var defaultLogger = new Logger();\n\n    var _loggersByName = {};\n    defaultLogger.getLogger = function getLogger(name) {\n        if ((typeof name !== \"symbol\" && typeof name !== \"string\") || name === \"\") {\n          throw new TypeError(\"You must supply a name when creating a logger.\");\n        }\n\n        var logger = _loggersByName[name];\n        if (!logger) {\n          logger = _loggersByName[name] = new Logger(\n            name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n        }\n        return logger;\n    };\n\n    // Grab the current global log variable in case of overwrite\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if (typeof window !== undefinedType &&\n               window.log === defaultLogger) {\n            window.log = _log;\n        }\n\n        return defaultLogger;\n    };\n\n    defaultLogger.getLoggers = function getLoggers() {\n        return _loggersByName;\n    };\n\n    // ES6 default export, for compatibility\n    defaultLogger['default'] = defaultLogger;\n\n    return defaultLogger;\n}));\n","import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport merge from 'lodash.merge';\nimport logLevel, { levels } from 'loglevel';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nconst log = logLevel.getLogger(\"http-helpers\");\nlog.setLevel(levels.INFO);\nlet apiKey = \"torus-default\";\nlet embedHost = \"\"; // #region API Keys\n\nconst gatewayAuthHeader = \"x-api-key\";\nconst gatewayEmbedHostHeader = \"x-embed-host\";\nlet sentry = null;\nconst tracingOrigins = [];\nconst tracingPaths = [];\nfunction enableSentryTracing(_sentry, _tracingOrigins, _tracingPaths) {\n  sentry = _sentry;\n  tracingOrigins.push(..._tracingOrigins);\n  tracingPaths.push(..._tracingPaths);\n}\nfunction setEmbedHost(embedHost_) {\n  embedHost = embedHost_;\n}\nfunction clearEmbedHost() {\n  embedHost = \"\";\n}\nfunction getEmbedHost() {\n  return embedHost;\n}\nfunction setAPIKey(apiKey_) {\n  apiKey = apiKey_;\n}\nfunction clearAPIKey() {\n  apiKey = \"torus-default\";\n}\nfunction getAPIKey() {\n  return apiKey;\n} // #endregion\n\nfunction setLogLevel(level) {\n  log.setLevel(level);\n}\n\nasync function fetchAndTrace(url, init) {\n  let _url = null;\n\n  try {\n    _url = new URL(url);\n  } catch (error) {}\n\n  if (sentry && _url && (tracingOrigins.includes(_url.origin) || tracingPaths.includes(_url.pathname))) {\n    const transaction = sentry.startTransaction({\n      name: url\n    });\n    const span = transaction.startChild({\n      op: \"http\"\n    }); // This function returns a Span\n\n    const response = await fetch(url, init);\n    span.finish(); // Remember that only finished spans will be sent with the transaction\n\n    transaction.finish(); // Finishing the transaction will send it to Sentry\n\n    return response;\n  }\n\n  return fetch(url, init);\n}\n\nfunction getApiKeyHeaders() {\n  const headers = {};\n  if (apiKey) headers[gatewayAuthHeader] = apiKey;\n  if (embedHost) headers[gatewayEmbedHostHeader] = embedHost;\n  return headers;\n}\n\nfunction debugLogResponse(response) {\n  log.info(\"Response: \".concat(response.status, \" \").concat(response.statusText));\n  log.info(\"Url: \".concat(response.url));\n}\n\nconst promiseTimeout = (ms, promise) => {\n  const timeout = new Promise((resolve, reject) => {\n    const id = setTimeout(() => {\n      clearTimeout(id);\n      reject(new Error(\"Timed out in \".concat(ms, \"ms\")));\n    }, ms);\n  });\n  return Promise.race([promise, timeout]);\n};\nconst get = async function (url) {\n  let options_ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let customOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const defaultOptions = {\n    mode: \"cors\",\n    headers: {}\n  };\n\n  if (customOptions.useAPIKey) {\n    defaultOptions.headers = _objectSpread(_objectSpread({}, defaultOptions.headers), getApiKeyHeaders());\n  }\n\n  const options = merge(defaultOptions, options_, {\n    method: \"GET\"\n  });\n  const response = await fetchAndTrace(url, options);\n\n  if (response.ok) {\n    return response.json();\n  }\n\n  debugLogResponse(response);\n  throw response;\n};\nconst post = function (url) {\n  let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let options_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let customOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const defaultOptions = {\n    mode: \"cors\",\n    headers: {\n      \"Content-Type\": \"application/json; charset=utf-8\"\n    }\n  };\n\n  if (customOptions.useAPIKey) {\n    defaultOptions.headers = _objectSpread(_objectSpread({}, defaultOptions.headers), getApiKeyHeaders());\n  }\n\n  const options = merge(defaultOptions, options_, {\n    method: \"POST\"\n  }); // deep merge changes the structure of form data and url encoded data ,\n  // so we should not deepmerge body data\n\n  if (customOptions.isUrlEncodedData) {\n    // for multipart request browser/client will add multipart content type\n    // along with multipart boundary , so for multipart request send\n    // content-type: undefined or send with multipart boundary if already known\n    options.body = data; // If url encoded data, this must not be the content type\n\n    if (options.headers[\"Content-Type\"] === \"application/json; charset=utf-8\") delete options.headers[\"Content-Type\"];\n  } else {\n    options.body = JSON.stringify(data);\n  }\n\n  return promiseTimeout(customOptions.timeout || 60000, fetchAndTrace(url, options).then(response => {\n    if (response.ok) {\n      return response.json();\n    }\n\n    debugLogResponse(response);\n    throw response;\n  }));\n};\nconst patch = async function (url) {\n  let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let options_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let customOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const defaultOptions = {\n    mode: \"cors\",\n    headers: {\n      \"Content-Type\": \"application/json; charset=utf-8\"\n    }\n  }; // for multipart request browser/client will add multipart content type\n  // along with multipart boundary , so for multipart request send\n  // content-type: undefined or send with multipart boundary if already known\n\n  if (customOptions.useAPIKey) {\n    defaultOptions.headers = _objectSpread(_objectSpread({}, defaultOptions.headers), getApiKeyHeaders());\n  }\n\n  const options = merge(defaultOptions, options_, {\n    method: \"PATCH\"\n  }); // deep merge changes the structure of form data and url encoded data ,\n  // so we should not deepmerge body data\n\n  if (customOptions.isUrlEncodedData) {\n    // for multipart request browser/client will add multipart content type\n    // along with multipart boundary , so for multipart request send\n    // content-type: undefined or send with multipart boundary if already known\n    options.body = data; // If url encoded data, this must not be the content type\n\n    if (options.headers[\"Content-Type\"] === \"application/json; charset=utf-8\") delete options.headers[\"Content-Type\"];\n  } else {\n    options.body = JSON.stringify(data);\n  }\n\n  const response = await fetchAndTrace(url, options);\n\n  if (response.ok) {\n    return response.json();\n  }\n\n  debugLogResponse(response);\n  throw response;\n};\nconst put = async function (url) {\n  let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let options_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let customOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const defaultOptions = {\n    mode: \"cors\",\n    headers: {\n      \"Content-Type\": \"application/json; charset=utf-8\"\n    }\n  }; // for multipart request browser/client will add multipart content type\n  // along with multipart boundary , so for multipart request send\n  // content-type: undefined or send with multipart boundary if already known\n\n  if (customOptions.useAPIKey) {\n    defaultOptions.headers = _objectSpread(_objectSpread({}, defaultOptions.headers), getApiKeyHeaders());\n  }\n\n  const options = merge(defaultOptions, options_, {\n    method: \"PUT\"\n  }); // deep merge changes the structure of form data and url encoded data ,\n  // so we should not deepmerge body data\n\n  if (customOptions.isUrlEncodedData) {\n    // for multipart request browser/client will add multipart content type\n    // along with multipart boundary , so for multipart request send\n    // content-type: undefined or send with multipart boundary if already known\n    options.body = data; // If url encoded data, this must not be the content type\n\n    if (options.headers[\"Content-Type\"] === \"application/json; charset=utf-8\") delete options.headers[\"Content-Type\"];\n  } else {\n    options.body = JSON.stringify(data);\n  }\n\n  const response = await fetchAndTrace(url, options);\n\n  if (response.ok) {\n    return response.json();\n  }\n\n  debugLogResponse(response);\n  throw response;\n};\nconst remove = async function (url) {\n  let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let options_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let customOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const defaultOptions = {\n    mode: \"cors\",\n    headers: {\n      \"Content-Type\": \"application/json; charset=utf-8\"\n    }\n  }; // for multipart request browser/client will add multipart content type\n  // along with multipart boundary , so for multipart request send\n  // content-type: undefined or send with multipart boundary if already known\n\n  if (customOptions.useAPIKey) {\n    defaultOptions.headers = _objectSpread(_objectSpread({}, defaultOptions.headers), getApiKeyHeaders());\n  }\n\n  const options = merge(defaultOptions, options_, {\n    method: \"DELETE\"\n  });\n\n  if (customOptions.isUrlEncodedData) {\n    // for multipart request browser/client will add multipart content type\n    // along with multipart boundary , so for multipart request send\n    // content-type: undefined or send with multipart boundary if already known\n    options.body = data; // If url encoded data, this must not be the content type\n\n    if (options.headers[\"Content-Type\"] === \"application/json; charset=utf-8\") delete options.headers[\"Content-Type\"];\n  } else {\n    options.body = JSON.stringify(data);\n  }\n\n  const response = await fetchAndTrace(url, options);\n\n  if (response.ok) {\n    return response.json();\n  }\n\n  debugLogResponse(response);\n  throw response;\n};\nconst generateJsonRPCObject = (method, parameters) => ({\n  jsonrpc: \"2.0\",\n  method,\n  id: 10,\n  params: parameters\n});\nconst promiseRace = function (url, options) {\n  let timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 60000;\n  return Promise.race([get(url, options), new Promise((resolve, reject) => {\n    setTimeout(() => {\n      reject(new Error(\"timed out\"));\n    }, timeout);\n  })]);\n};\n\nexport { clearAPIKey, clearEmbedHost, enableSentryTracing, gatewayAuthHeader, gatewayEmbedHostHeader, generateJsonRPCObject, get, getAPIKey, getEmbedHost, patch, post, promiseRace, promiseTimeout, put, remove, setAPIKey, setEmbedHost, setLogLevel };\n//# sourceMappingURL=httpHelpers.esm.js.map\n","import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { BaseController, createEventEmitterProxy, providerFromEngine } from '@toruslabs/base-controllers';\nimport { WalletInitializationError } from '@web3auth/base';\nimport { ethErrors } from 'eth-rpc-errors';\nimport { JRPCEngine, createScaffoldMiddleware, createAsyncMiddleware } from '@toruslabs/openlogin-jrpc';\nimport getCreateRandomId from 'json-rpc-random-id';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass BaseProvider extends BaseController {\n  // should be Assigned in setupProvider\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config,\n      state\n    });\n\n    _defineProperty(this, \"_providerEngineProxy\", null);\n\n    if (!config.chainConfig) throw WalletInitializationError.invalidProviderConfigError(\"Please provide chainConfig\");\n    if (!config.chainConfig.chainId) throw WalletInitializationError.invalidProviderConfigError(\"Please provide chainId inside chainConfig\");\n    if (!config.chainConfig.rpcTarget) throw WalletInitializationError.invalidProviderConfigError(\"Please provide rpcTarget inside chainConfig\");\n    this.defaultState = {\n      chainId: \"loading\"\n    };\n    this.defaultConfig = {\n      chainConfig: config.chainConfig,\n      networks: {\n        [config.chainConfig.chainId]: config.chainConfig\n      }\n    };\n    super.initialize();\n  }\n\n  get provider() {\n    return this._providerEngineProxy;\n  }\n\n  set provider(_) {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  addChain(chainConfig) {\n    if (!chainConfig.chainId) throw ethErrors.rpc.invalidParams(\"chainId is required\");\n    if (!chainConfig.rpcTarget) throw ethErrors.rpc.invalidParams(\"chainId is required\");\n    this.configure({\n      networks: _objectSpread(_objectSpread({}, this.config.networks), {}, {\n        [chainConfig.chainId]: chainConfig\n      })\n    });\n  }\n\n  getChainConfig(chainId) {\n    var _this$config$networks;\n\n    const chainConfig = (_this$config$networks = this.config.networks) === null || _this$config$networks === void 0 ? void 0 : _this$config$networks[chainId];\n    if (!chainConfig) throw ethErrors.rpc.invalidRequest(\"Chain \".concat(chainId, \" is not supported, please add chainConfig for it\"));\n    return chainConfig;\n  }\n\n  getProviderEngineProxy() {\n    return this._providerEngineProxy;\n  }\n\n  updateProviderEngineProxy(providerEngineProxy) {\n    if (this._providerEngineProxy) {\n      this._providerEngineProxy.setTarget(providerEngineProxy);\n    } else {\n      this._providerEngineProxy = createEventEmitterProxy(providerEngineProxy);\n    }\n  }\n\n}\n\nclass CommonPrivateKeyProvider {\n  constructor() {\n    _defineProperty(this, \"_providerEngineProxy\", null);\n  }\n\n  get provider() {\n    return this._providerEngineProxy;\n  }\n\n  set provider(_) {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  addChain(_) {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  async setupProvider(privKey) {\n    const privKeyMiddleware = this.getPrivKeyMiddleware(privKey);\n    const engine = new JRPCEngine();\n    engine.push(privKeyMiddleware);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n  }\n\n  async switchChain(_) {\n    return Promise.resolve();\n  }\n\n  getProviderEngineProxy() {\n    return this._providerEngineProxy;\n  }\n\n  updateProviderEngineProxy(providerEngineProxy) {\n    if (this._providerEngineProxy) {\n      this._providerEngineProxy.setTarget(providerEngineProxy);\n    } else {\n      this._providerEngineProxy = createEventEmitterProxy(providerEngineProxy);\n    }\n  }\n\n  getPrivKeyMiddleware(privKey) {\n    const middleware = {\n      getPrivatekey: async () => {\n        return privKey;\n      }\n    };\n    return this.createPrivKeyMiddleware(middleware);\n  }\n\n  createPrivKeyMiddleware(_ref) {\n    let {\n      getPrivatekey\n    } = _ref;\n\n    async function getPrivatekeyHandler(_, res) {\n      res.result = await getPrivatekey();\n    }\n\n    return createScaffoldMiddleware({\n      private_key: createAsyncMiddleware(getPrivatekeyHandler)\n    });\n  }\n\n}\n\n_defineProperty(CommonPrivateKeyProvider, \"getProviderInstance\", async params => {\n  const providerFactory = new CommonPrivateKeyProvider();\n  await providerFactory.setupProvider(params.privKey);\n  return providerFactory;\n});\n\nconst createRandomId = getCreateRandomId();\n\nexport { BaseProvider, CommonPrivateKeyProvider, createRandomId };\n//# sourceMappingURL=baseProvider.esm.js.map\n",null,null,"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { SafeEventEmitter, JRPCEngine, createAsyncMiddleware, mergeMiddleware, createScaffoldMiddleware } from '@toruslabs/openlogin-jrpc';\nimport { serializeError, ethErrors } from 'eth-rpc-errors';\nimport getCreateRandomId from 'json-rpc-random-id';\nimport { BigNumber } from 'bignumber.js';\nimport { fromSigned, bufferToInt, toUnsigned, stripHexPrefix, addHexPrefix, hashPersonalMessage, ecsign, intToBuffer } from 'ethereumjs-util';\nimport log from 'loglevel';\nimport { BroadcastChannel } from '@toruslabs/broadcast-channel';\nimport { get, post, patch, remove } from '@toruslabs/http-helpers';\nimport bowser from 'bowser';\nimport { cloneDeep, pickBy, omitBy } from 'lodash';\n\nfunction ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$3(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n/**\n * Controller class that provides configuration, state management, and subscriptions\n */\n\nclass BaseController extends SafeEventEmitter {\n  /**\n   * Default options used to configure this controller\n   */\n\n  /**\n   * Default state set on this controller\n   */\n\n  /**\n   * Determines if listeners are notified of state changes\n   */\n\n  /**\n   * Name of this controller used during composition\n   */\n\n  /**\n   * Creates a BaseController instance. Both initial state and initial\n   * configuration options are merged with defaults upon initialization.\n   *\n   * @param config - Initial options used to configure this controller\n   * @param state - Initial state to set on this controller\n   */\n  constructor(_ref) {\n    let {\n      config = {},\n      state = {}\n    } = _ref;\n    super(); // Use assign since generics can't be spread: https://git.io/vpRhY\n\n    _defineProperty(this, \"defaultConfig\", {});\n\n    _defineProperty(this, \"defaultState\", {});\n\n    _defineProperty(this, \"disabled\", false);\n\n    _defineProperty(this, \"name\", \"BaseController\");\n\n    _defineProperty(this, \"initialConfig\", void 0);\n\n    _defineProperty(this, \"initialState\", void 0);\n\n    _defineProperty(this, \"internalConfig\", this.defaultConfig);\n\n    _defineProperty(this, \"internalState\", this.defaultState);\n\n    this.initialState = state;\n    this.initialConfig = config;\n  }\n  /**\n   * Retrieves current controller configuration options\n   *\n   * @returns - Current configuration\n   */\n\n\n  get config() {\n    return this.internalConfig;\n  }\n  /**\n   * Retrieves current controller state\n   *\n   * @returns - Current state\n   */\n\n\n  get state() {\n    return this.internalState;\n  }\n  /**\n   * Updates controller configuration\n   *\n   * @param config - New configuration options\n   * @param overwrite - Overwrite config instead of merging\n   * @param fullUpdate - Boolean that defines if the update is partial or not\n   */\n\n\n  configure(config) {\n    let overwrite = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let fullUpdate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n    if (fullUpdate) {\n      this.internalConfig = overwrite ? config : Object.assign(this.internalConfig, config);\n\n      for (const key in this.internalConfig) {\n        if (typeof this.internalConfig[key] !== \"undefined\") {\n          this[key] = this.internalConfig[key];\n        }\n      }\n    } else {\n      for (const key in config) {\n        /* istanbul ignore else */\n        if (typeof this.internalConfig[key] !== \"undefined\") {\n          this.internalConfig[key] = config[key];\n          this[key] = config[key];\n        }\n      }\n    }\n  }\n  /**\n   * Updates controller state\n   *\n   * @param state - New state\n   * @param overwrite - Overwrite state instead of merging\n   */\n\n\n  update(state) {\n    let overwrite = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    this.internalState = overwrite ? _objectSpread$3({}, state) : _objectSpread$3(_objectSpread$3({}, this.internalState), state);\n    this.emit(\"store\", this.internalState);\n  }\n  /**\n   * Enables the controller. This sets each config option as a member\n   * variable on this instance and triggers any defined setters. This\n   * also sets initial state and triggers any listeners.\n   *\n   * @returns - This controller instance\n   */\n\n\n  initialize() {\n    this.internalState = this.defaultState;\n    this.internalConfig = this.defaultConfig;\n    this.configure(this.initialConfig);\n    this.update(this.initialState);\n    return this;\n  }\n\n}\n\nconst sec = 1000;\n\nconst calculateSum = (accumulator, currentValue) => accumulator + currentValue;\n\nconst blockTrackerEvents = [\"sync\", \"latest\"];\nclass BaseBlockTracker extends BaseController {\n  constructor(_ref) {\n    let {\n      config = {},\n      state = {}\n    } = _ref;\n    super({\n      config,\n      state\n    }); // config\n\n    _defineProperty(this, \"name\", \"BaseBlockTracker\");\n\n    _defineProperty(this, \"_blockResetTimeout\", void 0);\n\n    this.defaultState = {\n      _currentBlock: {\n        idempotencyKey: \"\"\n      },\n      _isRunning: false\n    };\n    this.defaultConfig = {\n      blockResetDuration: 20 * sec\n    };\n    this.initialize(); // bind functions for internal use\n\n    this._onNewListener = this._onNewListener.bind(this);\n    this._onRemoveListener = this._onRemoveListener.bind(this);\n    this._resetCurrentBlock = this._resetCurrentBlock.bind(this); // listen for handler changes\n\n    this._setupInternalEvents();\n  }\n\n  isRunning() {\n    return this.state._isRunning;\n  }\n\n  getCurrentBlock() {\n    return this.state._currentBlock;\n  }\n\n  async getLatestBlock() {\n    // return if available\n    if (this.state._currentBlock) {\n      return this.state._currentBlock;\n    } // wait for a new latest block\n\n\n    const latestBlock = await new Promise(resolve => this.once(\"latest\", newState => {\n      if (newState._currentBlock) {\n        resolve(newState._currentBlock);\n      }\n    })); // return newly set current block\n\n    return latestBlock;\n  } // dont allow module consumer to remove our internal event listeners\n\n\n  removeAllListeners(eventName) {\n    if (eventName) {\n      super.removeAllListeners(eventName);\n    } else {\n      super.removeAllListeners();\n    } // re-add internal events\n\n\n    this._setupInternalEvents(); // trigger stop check just in case\n\n\n    this._onRemoveListener();\n\n    return this;\n  }\n  /**\n   * To be implemented in subclass.\n   */\n\n\n  _start() {// default behavior is noop\n  }\n  /**\n   * To be implemented in subclass.\n   */\n\n\n  _end() {// default behavior is noop\n  }\n\n  _newPotentialLatest(newBlock) {\n    const currentBlock = this.state._currentBlock; // only update if blok number is higher\n\n    if (currentBlock && newBlock.idempotencyKey === currentBlock.idempotencyKey) {\n      return;\n    }\n\n    this._setCurrentBlock(newBlock);\n  }\n\n  _setupInternalEvents() {\n    // first remove listeners for idempotency\n    this.removeListener(\"newListener\", this._onNewListener);\n    this.removeListener(\"removeListener\", this._onRemoveListener); // then add them\n\n    this.on(\"removeListener\", this._onRemoveListener);\n    this.on(\"newListener\", this._onNewListener);\n  }\n\n  _onNewListener() {\n    this._maybeStart();\n  }\n\n  _onRemoveListener() {\n    // `removeListener` is called *after* the listener is removed\n    if (this._getBlockTrackerEventCount() > 0) {\n      return;\n    }\n\n    this._maybeEnd();\n  }\n\n  _maybeStart() {\n    if (this.state._isRunning) {\n      return;\n    }\n\n    this.state._isRunning = true; // cancel setting latest block to stale\n\n    this._cancelBlockResetTimeout();\n\n    this._start();\n  }\n\n  _maybeEnd() {\n    if (!this.state._isRunning) {\n      return;\n    }\n\n    this.state._isRunning = false;\n\n    this._setupBlockResetTimeout();\n\n    this._end();\n  }\n\n  _getBlockTrackerEventCount() {\n    return blockTrackerEvents.map(eventName => this.listenerCount(eventName)).reduce(calculateSum);\n  }\n\n  _setCurrentBlock(newBlock) {\n    const oldBlock = this.state._currentBlock;\n    this.update({\n      _currentBlock: newBlock\n    });\n    this.emit(\"latest\", newBlock);\n    this.emit(\"sync\", {\n      oldBlock,\n      newBlock\n    });\n  }\n\n  _setupBlockResetTimeout() {\n    // clear any existing timeout\n    this._cancelBlockResetTimeout(); // clear latest block when stale\n\n\n    this._blockResetTimeout = setTimeout(this._resetCurrentBlock, this.config.blockResetDuration); // nodejs - dont hold process open\n\n    if (this._blockResetTimeout.unref) {\n      this._blockResetTimeout.unref();\n    }\n  }\n\n  _cancelBlockResetTimeout() {\n    if (this._blockResetTimeout) {\n      clearTimeout(this._blockResetTimeout);\n    }\n  }\n\n  _resetCurrentBlock() {\n    this.update({\n      _currentBlock: {\n        idempotencyKey: \"\"\n      }\n    });\n  }\n\n}\n\nconst filterNoop = () => true;\n\nconst internalEvents = [\"newListener\", \"removeListener\"];\n\nconst externalEventFilter = name => !internalEvents.includes(name);\n\nfunction getRawListeners(eventEmitter, name) {\n  // prefer native\n  return eventEmitter.rawListeners(name);\n}\n\nfunction createEventEmitterProxy(initialTarget, opts) {\n  // parse options\n  const finalOpts = opts || {};\n  let eventFilter = finalOpts.eventFilter || filterNoop;\n  if (typeof eventFilter === \"string\" && eventFilter === \"skipInternal\") eventFilter = externalEventFilter;\n  if (typeof eventFilter !== \"function\") throw new Error(\"createEventEmitterProxy - Invalid eventFilter\");\n  let target = initialTarget;\n\n  let setTarget = newTarget => {\n    const oldTarget = target;\n    target = newTarget;\n    oldTarget.eventNames().filter(eventFilter).forEach(name => {\n      getRawListeners(oldTarget, name).forEach(handler => newTarget.on(name, handler));\n    }); // remove old listeners\n\n    oldTarget.removeAllListeners();\n  };\n\n  const proxy = new Proxy({}, {\n    get: (_, name) => {\n      // override `setTarget` access\n      if (name === \"setTarget\") return setTarget;\n      return target[name];\n    },\n    set: (_, name, value) => {\n      // allow `setTarget` overrides\n      if (name === \"setTarget\") {\n        setTarget = value;\n        return true;\n      }\n\n      target[name] = value;\n      return true;\n    }\n  });\n  return proxy;\n}\n\nfunction createSwappableProxy(initialTarget) {\n  let target = initialTarget;\n\n  let setTarget = newTarget => {\n    target = newTarget;\n  };\n\n  const proxy = new Proxy({}, {\n    get: (_, name) => {\n      // override `setTarget` access\n      if (name === \"setTarget\") return setTarget;\n      return target[name];\n    },\n    set: (_, name, value) => {\n      // allow `setTarget` overrides\n      if (name === \"setTarget\") {\n        setTarget = value;\n        return true;\n      }\n\n      target[name] = value;\n      return true;\n    }\n  });\n  return proxy;\n}\n\nconst POLLING_INTERVAL = 600000;\nclass BaseCurrencyController extends BaseController {\n  constructor(_ref) {\n    let {\n      config = {},\n      state\n    } = _ref;\n    super({\n      config,\n      state\n    });\n    this.defaultState = {\n      currentCurrency: \"usd\",\n      conversionRate: 0,\n      conversionDate: \"N/A\",\n      nativeCurrency: \"ETH\"\n    };\n    this.defaultConfig = {\n      pollInterval: POLLING_INTERVAL\n    };\n    this.initialize();\n  } //\n  // PUBLIC METHODS\n  //\n\n\n  getNativeCurrency() {\n    return this.state.nativeCurrency;\n  }\n\n  setNativeCurrency(nativeCurrency) {\n    this.update({\n      nativeCurrency,\n      ticker: nativeCurrency\n    });\n  }\n\n  getCurrentCurrency() {\n    return this.state.currentCurrency;\n  }\n\n  setCurrentCurrency(currentCurrency) {\n    this.update({\n      currentCurrency\n    });\n  }\n  /**\n   * A getter for the conversionRate property\n   *\n   * @returns The conversion rate from ETH to the selected currency.\n   *\n   */\n\n\n  getConversionRate() {\n    return this.state.conversionRate;\n  }\n\n  setConversionRate(conversionRate) {\n    this.update({\n      conversionRate\n    });\n  }\n  /**\n   * A getter for the conversionDate property\n   *\n   * @returns The date at which the conversion rate was set. Expressed in milliseconds since midnight of\n   * January 1, 1970\n   *\n   */\n\n\n  getConversionDate() {\n    return this.state.conversionDate;\n  }\n\n  setConversionDate(conversionDate) {\n    this.update({\n      conversionDate\n    });\n  }\n\n}\n\nfunction ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nconst createRandomId = getCreateRandomId();\nfunction providerFromEngine(engine) {\n  const provider = new SafeEventEmitter(); // handle both rpc send methods\n\n  provider.sendAsync = async req => {\n    const res = await engine.handle(req);\n\n    if (res.error) {\n      var _res$error, _res$error2;\n\n      const err = serializeError(res.error, {\n        fallbackError: {\n          message: ((_res$error = res.error) === null || _res$error === void 0 ? void 0 : _res$error.message) || res.error.toString(),\n          code: ((_res$error2 = res.error) === null || _res$error2 === void 0 ? void 0 : _res$error2.code) || -32603\n        }\n      });\n      throw ethErrors.rpc.internal(err);\n    }\n\n    return res.result;\n  }; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  provider.send = (req, callback) => {\n    if (typeof callback !== \"function\") {\n      throw new Error('Must provide callback to \"send\" method.');\n    }\n\n    engine.handle(req, callback);\n  }; // forward notifications\n\n\n  if (engine.on) {\n    engine.on(\"notification\", message => {\n      provider.emit(\"data\", null, message);\n    });\n  }\n\n  provider.request = async args => {\n    const req = _objectSpread$2(_objectSpread$2({}, args), {}, {\n      id: createRandomId(),\n      jsonrpc: \"2.0\"\n    });\n\n    const res = await provider.sendAsync(req);\n    return res;\n  };\n\n  return provider;\n}\nfunction providerFromMiddleware(middleware) {\n  const engine = new JRPCEngine();\n  engine.push(middleware);\n  const provider = providerFromEngine(engine);\n  return provider;\n}\nfunction providerAsMiddleware(provider) {\n  return async (req, res, _next, end) => {\n    // send request to provider\n    try {\n      const providerRes = await provider.sendAsync(req);\n      res.result = providerRes;\n      return end();\n    } catch (error) {\n      return end(error.message);\n    }\n  };\n}\n\nconst FEATURES_PROVIDER_CHANGE_WINDOW = {\n  height: 660,\n  width: 375\n};\nconst FEATURES_DEFAULT_WALLET_WINDOW = {\n  height: 740,\n  width: 1315\n};\nconst FEATURES_DEFAULT_POPUP_WINDOW = {\n  height: 700,\n  width: 1200\n};\nconst FEATURES_CONFIRM_WINDOW = {\n  height: 700,\n  width: 450\n};\nconst POPUP_LOADED = \"popup_loaded\";\nconst POPUP_RESULT = \"popup_result\";\nconst SETUP_COMPLETE = \"setup_complete\";\nconst ACTIVITY_ACTION_ALL = \"walletActivity.allTransactions\";\nconst ACTIVITY_ACTION_SEND = \"walletActivity.send\";\nconst ACTIVITY_ACTION_BURN = \"walletActivity.burn\";\nconst ACTIVITY_ACTION_RECEIVE = \"walletActivity.receive\";\nconst ACTIVITY_ACTION_TOPUP = \"walletActivity.topup\";\nconst ACTIVITY_PERIOD_ALL = \"walletActivity.all\";\nconst ACTIVITY_PERIOD_WEEK_ONE = \"walletActivity.lastOneWeek\";\nconst ACTIVITY_PERIOD_MONTH_ONE = \"walletActivity.lastOneMonth\";\nconst ACTIVITY_PERIOD_MONTH_SIX = \"walletActivity.lastSixMonts\";\nconst ACTIVITY_STATUS_SUCCESSFUL = \"walletActivity.successful\";\nconst ACTIVITY_STATUS_UNSUCCESSFUL = \"walletActivity.unsuccessful\";\nconst ACTIVITY_STATUS_PENDING = \"walletActivity.pending\";\nconst ACTIVITY_STATUS_CANCELLED = \"walletActivity.cancelled\";\nconst ACTIVITY_STATUS_CANCELLING = \"walletActivity.cancelling\";\nconst COMMUNICATION_NOTIFICATIONS = {\n  IFRAME_STATUS: \"iframe_status\",\n  // Tell embed to create the window\n  CREATE_WINDOW: \"create_window\",\n  // Tell embed to close the window\n  CLOSE_WINDOW: \"close_window\",\n  USER_LOGGED_IN: \"user_logged_in\",\n  USER_LOGGED_OUT: \"user_logged_out\"\n};\nconst COMMUNICATION_JRPC_METHODS = {\n  LOGOUT: \"logout\",\n  WALLET_INSTANCE_ID: \"wallet_instance_id\",\n  USER_INFO: \"user_info\",\n  SET_PROVIDER: \"set_provider\",\n  TOPUP: \"topup\",\n  IFRAME_STATUS: \"iframe_status\",\n  // embed has opened the window as requested\n  OPENED_WINDOW: \"opened_window\",\n  // user has closed the window from embed's side\n  CLOSED_WINDOW: \"closed_window\",\n  GET_PROVIDER_STATE: \"get_provider_state\",\n  LOGIN_WITH_PRIVATE_KEY: \"login_with_private_key\"\n};\nconst PROVIDER_JRPC_METHODS = {\n  GET_PROVIDER_STATE: \"wallet_get_provider_state\"\n};\nconst PROVIDER_NOTIFICATIONS = {\n  ACCOUNTS_CHANGED: \"wallet_accounts_changed\",\n  CHAIN_CHANGED: \"wallet_chain_changed\",\n  UNLOCK_STATE_CHANGED: \"wallet_unlock_state_changed\"\n};\nconst BROADCAST_CHANNELS = {\n  REDIRECT_CHANNEL: \"redirect_channel\",\n  PROVIDER_CHANGE_CHANNEL: \"torus_provider_change_channel\",\n  TRANSACTION_CHANNEL: \"torus_channel\",\n  MESSAGE_CHANNEL: \"torus_message_channel\",\n  WALLET_LOGOUT_CHANNEL: \"wallet_logout_channel\",\n  WALLET_SELECTED_ADDRESS_CHANNEL: \"wallet_selected_address_channel\",\n  WALLET_NETWORK_CHANGE_CHANNEL: \"wallet_network_change_channel\",\n  WALLET_ACCOUNT_IMPORT_CHANNEL: \"wallet_account_import_channel\",\n  THEME_CHANGE: \"theme_change_channel\"\n};\nconst BROADCAST_CHANNELS_MSGS = {\n  LOGOUT: \"logout\",\n  ACCOUNT_IMPORTED: \"account_imported\",\n  SELECTED_ADDRESS_CHANGE: \"selected_address_change\",\n  NETWORK_CHANGE: \"network_change\",\n  SET_THEME: \"set_theme\"\n};\n\nfunction createChangeProviderMiddlewareMiddleware(_ref) {\n  let {\n    changeProvider\n  } = _ref;\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== COMMUNICATION_JRPC_METHODS.SET_PROVIDER) return next();\n    if (!changeProvider) throw new Error(\"CommunicationMiddleware - opts.changeProvider not provided\");\n    response.result = await changeProvider(request);\n  });\n}\nfunction createTopupMiddleware(_ref2) {\n  let {\n    topup\n  } = _ref2;\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== COMMUNICATION_JRPC_METHODS.TOPUP) return next();\n    if (!topup) throw new Error(\"CommunicationMiddleware - opts.topup not provided\");\n    response.result = await topup(request);\n  });\n}\nfunction createGenericJRPCMiddleware(targetMethod, handler) {\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== targetMethod) return next();\n    if (!handler) throw new Error(\"CommunicationMiddleware - \".concat(targetMethod, \" not provided\"));\n    const result = await handler(request);\n\n    if (!result) {\n      return next();\n    }\n\n    response.result = result;\n    return undefined;\n  });\n}\nfunction createCommunicationMiddleware(providerHandlers) {\n  const {\n    getUserInfo,\n    getWalletInstanceId,\n    topup,\n    logout,\n    changeProvider,\n    setIFrameStatus,\n    handleWindowRpc,\n    getProviderState,\n    loginWithPrivateKey\n  } = providerHandlers;\n  return mergeMiddleware([createChangeProviderMiddlewareMiddleware({\n    changeProvider\n  }), createTopupMiddleware({\n    topup\n  }), createScaffoldMiddleware({\n    [COMMUNICATION_JRPC_METHODS.LOGOUT]: logout,\n    [COMMUNICATION_JRPC_METHODS.WALLET_INSTANCE_ID]: getWalletInstanceId,\n    [COMMUNICATION_JRPC_METHODS.USER_INFO]: getUserInfo,\n    [COMMUNICATION_JRPC_METHODS.IFRAME_STATUS]: setIFrameStatus,\n    // Do this in the orchestrator because communicationWindowManager needs to be passed into PopupHandlers\n    [COMMUNICATION_JRPC_METHODS.OPENED_WINDOW]: handleWindowRpc,\n    [COMMUNICATION_JRPC_METHODS.CLOSED_WINDOW]: handleWindowRpc,\n    [COMMUNICATION_JRPC_METHODS.GET_PROVIDER_STATE]: getProviderState\n  }), createGenericJRPCMiddleware(COMMUNICATION_JRPC_METHODS.LOGIN_WITH_PRIVATE_KEY, loginWithPrivateKey)]);\n}\n\nclass BaseEmbedController extends BaseController {\n  constructor(_ref) {\n    let {\n      config = {},\n      state\n    } = _ref;\n    super({\n      config,\n      state\n    });\n\n    _defineProperty(this, \"_communicationProviderProxy\", void 0);\n\n    this.defaultState = {\n      buttonPosition: \"bottom-right\",\n      isIFrameFullScreen: true,\n      apiKey: \"torus-default\",\n      oauthModalVisibility: false,\n      loginInProgress: false,\n      dappMetadata: {\n        name: \"\",\n        icon: \"\"\n      }\n    };\n    this.initialize();\n  }\n  /**\n   * Called by orchestrator once while initializing the class\n   * @param handlers - JRPC handlers for provider\n   * @returns - provider - Returns the providerProxy\n   */\n\n\n  initializeProvider(handlers) {\n    const engine = new JRPCEngine();\n    const communicationMiddleware = createCommunicationMiddleware(handlers);\n    engine.push(communicationMiddleware);\n    const communicationProvider = providerFromEngine(engine);\n    this.setCommunicationProvider(communicationProvider);\n  }\n\n  setCommunicationProvider(communicationProvider) {\n    if (this._communicationProviderProxy) {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      this._communicationProviderProxy.setTarget(communicationProvider);\n    } else {\n      this._communicationProviderProxy = createSwappableProxy(communicationProvider);\n    }\n  }\n\n}\n\nclass CommunicationWindowManager extends SafeEventEmitter {\n  constructor() {\n    super(...arguments);\n\n    _defineProperty(this, \"handleWindowRpc\", (request, response, next, end) => {\n      const {\n        method,\n        params\n      } = request;\n\n      if (method === COMMUNICATION_JRPC_METHODS.OPENED_WINDOW) {\n        const {\n          windowId\n        } = params; // I've been informed that a window has been opened\n\n        this.emit(\"\".concat(windowId, \":opened\"));\n        response.result = true;\n        end();\n      } else if (method === COMMUNICATION_JRPC_METHODS.CLOSED_WINDOW) {\n        const {\n          windowId\n        } = params; // I've been informed that a window has been closed\n\n        this.emit(\"\".concat(windowId, \":closed\"));\n        response.result = true;\n        end();\n      } else {\n        next();\n      }\n    });\n  }\n\n}\n\nconst LOGIN_PROVIDER = {\n  GOOGLE: \"google\",\n  FACEBOOK: \"facebook\",\n  REDDIT: \"reddit\",\n  DISCORD: \"discord\",\n  TWITCH: \"twitch\",\n  APPLE: \"apple\",\n  LINE: \"line\",\n  GITHUB: \"github\",\n  KAKAO: \"kakao\",\n  LINKEDIN: \"linkedin\",\n  TWITTER: \"twitter\",\n  WEIBO: \"weibo\",\n  WECHAT: \"wechat\",\n  EMAIL_PASSWORDLESS: \"email_passwordless\"\n};\nconst PAYMENT_PROVIDER = {\n  MOONPAY: \"moonpay\",\n  WYRE: \"wyre\",\n  RAMPNETWORK: \"rampnetwork\",\n  XANPOOL: \"xanpool\",\n  MERCURYO: \"mercuryo\",\n  TRANSAK: \"transak\"\n};\n\nconst getTxStatusText = txStatus => {\n  switch (txStatus) {\n    case \"rejected\":\n    case \"unapproved\":\n    case \"failed\":\n      return ACTIVITY_STATUS_UNSUCCESSFUL;\n\n    case \"confirmed\":\n      return ACTIVITY_STATUS_SUCCESSFUL;\n\n    case \"submitted\":\n      return ACTIVITY_STATUS_PENDING;\n\n    case \"cancelled\":\n      return ACTIVITY_STATUS_CANCELLED;\n\n    default:\n      return \"\";\n  }\n};\n\n/**\n * General utility functions\n */\n\nfunction intToHex(i) {\n  const hex = i.toString(16);\n  return \"0x\".concat(hex);\n}\n/**\n * Returns a random number. Don't use for cryptographic purposes.\n * @returns a random number\n */\n\nconst randomId = () => Math.random().toString(36).slice(2);\n/**\n * Pads the front of the given hex string with zeroes until it reaches the\n * target length. If the input string is already longer than or equal to the\n * target length, it is returned unmodified.\n *\n * If the input string is \"0x\"-prefixed or not a hex string, an error will be\n * thrown.\n *\n * @param hexString - The hexadecimal string to pad with zeroes.\n * @param targetLength - The target length of the hexadecimal string.\n * @returns The input string front-padded with zeroes, or the original string\n * if it was already greater than or equal to to the target length.\n */\n\nfunction padWithZeroes(hexString, targetLength) {\n  if (hexString !== \"\" && !/^[a-f0-9]+$/iu.test(hexString)) {\n    throw new Error(\"Expected an unprefixed hex string. Received: \".concat(hexString));\n  }\n\n  if (targetLength < 0) {\n    throw new Error(\"Expected a non-negative integer target length. Received: \".concat(targetLength));\n  }\n\n  return String.prototype.padStart.call(hexString, targetLength, \"0\");\n}\n/**\n * Concatenate an extended ECDSA signature into a hex string.\n *\n * @param v - The 'v' portion of the signature.\n * @param r - The 'r' portion of the signature.\n * @param s - The 's' portion of the signature.\n * @returns The concatenated ECDSA signature.\n */\n\nfunction concatSig(v, r, s) {\n  const rSig = fromSigned(r);\n  const sSig = fromSigned(s);\n  const vSig = bufferToInt(v);\n  const rStr = padWithZeroes(toUnsigned(rSig).toString(\"hex\"), 64);\n  const sStr = padWithZeroes(toUnsigned(sSig).toString(\"hex\"), 64);\n  const vStr = stripHexPrefix(intToHex(vSig));\n  return addHexPrefix(rStr.concat(sStr, vStr));\n}\nfunction timeout$1(duration) {\n  return new Promise(resolve => {\n    const timeoutRef = window.setTimeout(() => {\n      resolve();\n      window.clearTimeout(timeoutRef);\n    }, duration);\n  });\n}\nconst getHeaders = jwt => {\n  return {\n    headers: {\n      Authorization: \"Bearer \".concat(jwt),\n      \"Content-Type\": \"application/json; charset=utf-8\"\n    }\n  };\n};\n/**\n * Text/number formatting utilities\n */\n\nconst formatSmallNumbers = function (number) {\n  let currency = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"usd\";\n  let noTilde = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  const finalNumber = BigNumber.isBigNumber(number) ? number.toNumber() : number;\n  if (!Number.isFinite(finalNumber)) return \"\";\n  const value = currency.toLowerCase() === \"usd\" ? parseFloat(Number(finalNumber).toFixed(2)) : parseFloat(Number(finalNumber).toFixed(5));\n  const tilde = value > 0 ? \"~ \" : \"\";\n  return \"\".concat(currency.toLowerCase() === \"usd\" || noTilde ? \"\" : tilde).concat(Number(value), \" \").concat(currency.toUpperCase());\n};\nconst addressSlicer = function (address) {\n  let sliceLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;\n\n  if (address.length < 11) {\n    return address;\n  }\n\n  if (typeof address !== \"string\") return \"\";\n  return \"\".concat(address.slice(0, sliceLength), \"...\").concat(address.slice(-sliceLength));\n};\nconst significantDigits = function (number) {\n  let perc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  let length_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;\n  let input = !BigNumber.isBigNumber(number) ? new BigNumber(number) : number;\n  if (input.isZero()) return input;\n\n  if (perc) {\n    input = input.times(new BigNumber(100));\n  }\n\n  let depth;\n\n  if (input.gte(new BigNumber(1))) {\n    depth = length_;\n  } else {\n    depth = length_ - 1 + Math.ceil(Math.log10(new BigNumber(\"1\").div(input).toNumber()));\n  }\n\n  const shift = new BigNumber(10).pow(new BigNumber(depth));\n  const roundedNumber = Math.round(shift.times(input).toNumber()) / shift.toNumber();\n  return roundedNumber;\n};\nconst formatDate = inputDate => {\n  const monthList = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n  const date = new Date(inputDate);\n  const day = date.getDate();\n  const month = monthList[date.getMonth()];\n  const year = date.getFullYear();\n  return \"\".concat(day, \" \").concat(month, \" \").concat(year);\n};\nconst formatTime = time => {\n  return new Date(time).toTimeString().slice(0, 8);\n};\n/**\n * Network utilities\n */\n\nconst transactionMatchesNetwork = (transaction, chainId) => {\n  if (typeof transaction.chainId !== \"undefined\") {\n    return transaction.chainId === chainId;\n  }\n\n  return false;\n};\n/**\n * Signing utils\n */\n\nconst hashMessage = message => {\n  const bufferedMessage = Buffer.from(message, \"utf8\");\n  const el = hashPersonalMessage(bufferedMessage);\n  return el;\n};\nconst signMessage = (privateKey, data) => {\n  const privKey = Buffer.from(privateKey, \"hex\");\n  const message = stripHexPrefix(data);\n  const msgSig = ecsign(Buffer.from(message, \"hex\"), privKey);\n  const rawMsgSig = concatSig(intToBuffer(msgSig.v), msgSig.r, msgSig.s);\n  return rawMsgSig;\n};\n/**\n * popup handler utils\n */\n\nfunction getPopupFeatures(_ref) {\n  let {\n    width: w,\n    height: h\n  } = _ref;\n  // Fixes dual-screen position                             Most browsers      Firefox\n  const dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : window.screenX;\n  const dualScreenTop = window.screenTop !== undefined ? window.screenTop : window.screenY;\n  const width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : window.screen.width;\n  const height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : window.screen.height;\n  const systemZoom = 1; // No reliable estimate\n\n  const left = Math.abs((width - w) / 2 / systemZoom + dualScreenLeft);\n  const top = Math.abs((height - h) / 2 / systemZoom + dualScreenTop);\n  const features = \"titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=\".concat(h / systemZoom, \",width=\").concat(w / systemZoom, \",top=\").concat(top, \",left=\").concat(left);\n  return features;\n}\nconst broadcastChannelOptions = {\n  // type: 'localstorage', // (optional) enforce a type, oneOf['native', 'idb', 'localstorage', 'node']\n  webWorkerSupport: false // (optional) set this to false if you know that your channel will never be used in a WebWorker (increases performance)\n\n};\nfunction getCustomDeviceInfo() {\n  var _navigator;\n\n  if ((_navigator = navigator) !== null && _navigator !== void 0 && _navigator.brave) {\n    return {\n      browser: \"Brave\"\n    };\n  }\n}\nclass UserError extends Error {}\nconst handleRedirectParameters = (hash, queryParameters) => {\n  const hashParameters = {};\n  const hashUrl = new URL(\"\".concat(window.location.origin, \"/?\").concat(hash.slice(1)));\n  hashUrl.searchParams.forEach((value, key) => {\n    hashParameters[key] = value;\n  });\n  let instanceParameters = {};\n  let error = \"\";\n\n  if (!queryParameters.windowId) {\n    if (Object.keys(hashParameters).length > 0 && hashParameters.state) {\n      instanceParameters = JSON.parse(window.atob(decodeURIComponent(decodeURIComponent(hashParameters.state)))) || {};\n      error = hashParameters.error_description || hashParameters.error || error;\n    } else if (Object.keys(queryParameters).length > 0 && queryParameters.state) {\n      instanceParameters = JSON.parse(window.atob(decodeURIComponent(decodeURIComponent(queryParameters.state)))) || {};\n      if (queryParameters.error) error = queryParameters.error;\n    }\n  }\n\n  return {\n    error,\n    instanceParameters,\n    hashParameters\n  };\n};\nfunction sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nclass BaseKeyringController extends BaseController {\n  constructor(_ref) {\n    var _state$wallets;\n\n    let {\n      config = {},\n      state\n    } = _ref;\n    super({\n      config,\n      state\n    });\n    this.defaultState = {\n      wallets: (_state$wallets = state.wallets) !== null && _state$wallets !== void 0 ? _state$wallets : []\n    };\n    this.initialize();\n  } // for signing auth message\n\n\n  signAuthMessage(address, message) {\n    const keyring = this.state.wallets.find(x => x.address === address);\n\n    if (!keyring) {\n      throw new Error(\"key does not exist\");\n    }\n\n    const hashedMessage = hashMessage(message).toString(\"hex\");\n    const rawMessageSig = signMessage(keyring.privateKey, hashedMessage);\n    return rawMessageSig;\n  }\n\n}\n\nconst RETRIABLE_ERRORS = [// ignore server overload errors\n\"Gateway timeout\", \"ETIMEDOUT\", // ignore server sent html error pages\n// or truncated json responses\n\"failed to parse response body\", // ignore errors where http req failed to establish\n\"Failed to fetch\"];\n\nfunction checkForHttpErrors(fetchRes) {\n  // check for errors\n  switch (fetchRes.status) {\n    case 405:\n      throw ethErrors.rpc.methodNotFound();\n\n    case 418:\n      throw ethErrors.rpc.internal({\n        message: \"Request is being rate limited.\"\n      });\n\n    case 503:\n    case 504:\n      throw ethErrors.rpc.internal({\n        message: \"Gateway timeout. The request took too long to process.\" + \"This can happen when querying over too wide a block range.\"\n      });\n  }\n}\n\nfunction timeout(duration) {\n  return new Promise(resolve => setTimeout(resolve, duration));\n}\n\nfunction parseResponse(fetchRes, body) {\n  // check for error code\n  if (fetchRes.status !== 200) {\n    throw ethErrors.rpc.internal({\n      message: \"Non-200 status code: '\".concat(fetchRes.status, \"'\"),\n      data: body\n    });\n  } // check for rpc error\n\n\n  if (body.error) {\n    throw ethErrors.rpc.internal({\n      data: body.error\n    });\n  } // return successful result\n\n\n  return body.result;\n}\n\nfunction createFetchConfigFromReq(_ref) {\n  let {\n    req,\n    rpcTarget,\n    originHttpHeaderKey\n  } = _ref;\n  const parsedUrl = new URL(rpcTarget); // prepare payload\n  // copy only canonical json rpc properties\n\n  const payload = {\n    id: req.id,\n    jsonrpc: req.jsonrpc,\n    method: req.method,\n    params: req.params\n  }; // extract 'origin' parameter from request\n\n  const originDomain = req.origin; // serialize request body\n\n  const serializedPayload = JSON.stringify(payload); // configure fetch params\n\n  const fetchParams = {\n    method: \"POST\",\n    headers: {\n      Accept: \"application/json\",\n      \"Content-Type\": \"application/json\"\n    },\n    body: serializedPayload\n  }; // optional: add request origin as header\n\n  if (originHttpHeaderKey && originDomain) {\n    fetchParams.headers[originHttpHeaderKey] = originDomain;\n  }\n\n  return {\n    fetchUrl: parsedUrl.href,\n    fetchParams\n  };\n}\nfunction createFetchMiddleware(_ref2) {\n  let {\n    rpcTarget,\n    originHttpHeaderKey\n  } = _ref2;\n  return createAsyncMiddleware(async (req, res, _next) => {\n    const {\n      fetchUrl,\n      fetchParams\n    } = createFetchConfigFromReq({\n      req,\n      rpcTarget,\n      originHttpHeaderKey\n    }); // attempt request multiple times\n\n    const maxAttempts = 5;\n    const retryInterval = 1000;\n\n    for (let attempt = 0; attempt < maxAttempts; attempt++) {\n      try {\n        const fetchRes = await fetch(fetchUrl, fetchParams); // check for http errrors\n\n        checkForHttpErrors(fetchRes); // parse response body\n\n        const fetchBody = await fetchRes.json();\n        const result = parseResponse(fetchRes, fetchBody); // set result and exit retry loop\n\n        res.result = result;\n        return;\n      } catch (err) {\n        const errMsg = err.toString();\n        const isRetriable = RETRIABLE_ERRORS.some(phrase => errMsg.includes(phrase)); // re-throw error if not retriable\n\n        if (!isRetriable) {\n          throw err;\n        }\n      } // delay before retrying\n\n\n      await timeout(retryInterval);\n    }\n  });\n}\n\nfunction createLoggerMiddleware(options) {\n  return function loggerMiddleware(request, response, next) {\n    next(callback => {\n      if (response.error) {\n        log.warn(\"Error in RPC response:\\n\", response);\n      }\n\n      if (request.isTorusInternal) return;\n      log.info(\"RPC (\".concat(options.origin, \"):\"), request, \"->\", response);\n      callback();\n    });\n  };\n}\n\nfunction createOriginMiddleware(options) {\n  return function originMiddleware(request, _, next) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    request.origin = options.origin;\n    next();\n  };\n}\n\nclass BroadcastChannelHandler {\n  constructor(channelPrefix) {\n    _defineProperty(this, \"bc\", void 0);\n\n    _defineProperty(this, \"channel\", void 0);\n\n    const queryParameters = new URLSearchParams(window.location.search);\n    const instanceId = queryParameters.get(\"instanceId\");\n    this.channel = \"\".concat(channelPrefix, \"_\").concat(instanceId);\n    this.bc = new BroadcastChannel(this.channel, broadcastChannelOptions);\n  }\n\n  getMessageFromChannel() {\n    return new Promise((resolve, reject) => {\n      this.bc.addEventListener(\"message\", async ev => {\n        this.bc.close();\n\n        if (ev.error) {\n          reject(ev.error);\n        } else {\n          resolve(ev.data);\n        }\n      });\n      this.bc.postMessage({\n        data: {\n          type: POPUP_LOADED\n        }\n      });\n    });\n  }\n\n}\n\nclass StreamWindow extends BaseController {\n  // if window has been closed by users\n  constructor(_ref) {\n    let {\n      config,\n      state = {}\n    } = _ref;\n    super({\n      config,\n      state\n    });\n\n    _defineProperty(this, \"closed\", false);\n\n    this.initialize();\n  }\n\n  async open() {\n    return new Promise((resolve, reject) => {\n      const {\n        communicationEngine,\n        communicationWindowManager\n      } = this.config;\n      let popupSuccess = false;\n      communicationWindowManager.once(\"\".concat(this.state.windowId, \":closed\"), () => {\n        this.closed = true;\n      }); // Window is not open yet\n\n      if (!this.state.windowId) {\n        this.update({\n          windowId: randomId()\n        });\n        communicationWindowManager.once(\"\".concat(this.state.windowId, \":opened\"), () => {\n          resolve(this);\n        }); // Tell the other party to create a window by prompting the user to click on something\n\n        communicationEngine.emit(\"notification\", {\n          method: COMMUNICATION_NOTIFICATIONS.CREATE_WINDOW,\n          params: {\n            windowId: this.state.windowId,\n            url: this.state.url.href\n          }\n        });\n      } else {\n        // Send this window with `windowId` the url to open via bc\n        const bc = new BroadcastChannel(this.state.windowId, broadcastChannelOptions);\n        bc.addEventListener(\"message\", async ev => {\n          try {\n            log.info(ev, \"receiving data on channel: \".concat(bc.name));\n            const {\n              error\n            } = ev;\n\n            if (error) {\n              // Popup says some error. so, we say it's not really opened\n              reject(new Error(error));\n              return;\n            }\n\n            const {\n              message\n            } = ev.data;\n\n            if (message === POPUP_LOADED) {\n              popupSuccess = true;\n              await bc.postMessage({\n                data: {\n                  url: this.state.url.href,\n                  message: \"\" // No need of a msg\n\n                }\n              });\n              resolve(this);\n              bc.close();\n            }\n          } catch (error) {\n            reject(error);\n            bc.close(); // Something went wrong. so, we close that window\n\n            this.close();\n          }\n        }); // We don't know if the other end is ready to receive this msg. So, we keep writing until it receives and sends back something\n        // we need backoff strategy\n        // we need to wait for first attempt to succeed/fail until the second attempt\n        // If we get 429, we need to wait for a while and then try again\n\n        const postMsg = async () => {\n          // this never throws\n          const localResponse = await bc.postMessage({\n            data: {\n              message: SETUP_COMPLETE\n            }\n          });\n          return localResponse;\n        };\n\n        let currentDelay = bc.type === \"server\" ? 1000 : 200;\n\n        const recursiveFn = async () => {\n          if (!popupSuccess && !this.closed) {\n            const localResponse = await postMsg();\n\n            if (bc.type === \"server\") {\n              const serverResponse = localResponse;\n\n              if (serverResponse.status >= 400) {\n                // We need to wait for a while and then try again\n                currentDelay = Math.round(currentDelay * 1.5);\n              }\n            }\n\n            await sleep(currentDelay);\n            await recursiveFn();\n          }\n        };\n\n        recursiveFn();\n      }\n    });\n  }\n\n  close() {\n    const {\n      communicationEngine\n    } = this.config;\n    communicationEngine.emit(\"notification\", {\n      method: COMMUNICATION_NOTIFICATIONS.CLOSE_WINDOW,\n      params: {\n        windowId: this.state.windowId\n      }\n    });\n  }\n\n}\n\n/*\nScenarios:\n1. Open a normal popup window and no communication with it - Use PopupHandler\n2. Open a popup window and communicate with it - Use PopupWithBcHandler (can initiate communication by waiting for window to open or not)\n\n3. If window is already opened, pass in windowId to the popup handler.\n   This will establish communication with the popup window and sends it a new url to redirect to\n\n\nIf you're trying to open a window and it gets blocked (happens if you're in iframe or delay b/w click and opening window),\nStreamWindow is invoked and it writes in a channel to display a message to the user\n\nOnce user clicks on that modal/dialog, we pre-open the window and pass in the windowId (goes to 3)\n*/\n\n/**\n * Handles popup window management.\n * For broadcast channel communication, use url with `instanceId` coded into state parameter.\n * This state parameter will be passed across redirects according to OAuth spec.\n */\n\nclass PopupHandler extends BaseController {\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config,\n      state\n    }); // this.id = randomId()\n    // Add in dapp storage key to all popups as a hash parameter\n\n    this.defaultConfig = {\n      dappStorageKey: \"\",\n      features: getPopupFeatures(FEATURES_DEFAULT_POPUP_WINDOW),\n      target: \"_blank\",\n      communicationEngine: null,\n      communicationWindowManager: null\n    };\n    this.defaultState = {\n      windowTimer: null,\n      window: null,\n      iClosedWindow: false,\n      windowId: \"\",\n      url: state.url\n    };\n    this.initialize();\n\n    this._setupTimer();\n  }\n\n  async open() {\n    // if window is already open\n    const {\n      target,\n      features,\n      dappStorageKey,\n      communicationEngine,\n      communicationWindowManager\n    } = this.config;\n    const {\n      windowId,\n      url\n    } = this.state;\n\n    if (dappStorageKey) {\n      const urlHashParams = new URLSearchParams(url.hash.slice(1));\n      urlHashParams.append(\"dappStorageKey\", dappStorageKey);\n      url.hash = urlHashParams.toString();\n      this.update({\n        url\n      });\n    } // No window has been pre-opened\n\n\n    if (!windowId) {\n      // try to open a window first\n      let localWindow = window.open(url.href, target, features);\n\n      if (!localWindow) {\n        // if it's blocked, open StreamWindow\n        localWindow = new StreamWindow({\n          config: {\n            communicationEngine,\n            communicationWindowManager\n          },\n          state: {\n            url\n          }\n        });\n        localWindow.open();\n      }\n\n      this.update({\n        window: localWindow\n      });\n      return;\n    } // A window has been pre-opened with a query parameter `windowId`\n\n\n    const localWindow = new StreamWindow({\n      config: {\n        communicationEngine,\n        communicationWindowManager\n      },\n      state: {\n        url,\n        windowId\n      }\n    });\n    this.update({\n      window: localWindow\n    });\n    await localWindow.open();\n  }\n\n  close() {\n    this.update({\n      iClosedWindow: true\n    });\n    const {\n      window\n    } = this.state;\n    if (window) window.close();\n  }\n\n  _setupTimer() {\n    const timer = window.setInterval(() => {\n      const {\n        window,\n        windowTimer,\n        iClosedWindow\n      } = this.state;\n\n      if (window && window.closed) {\n        if (windowTimer) clearInterval(windowTimer);\n\n        if (!iClosedWindow) {\n          this.emit(\"close\");\n        }\n\n        this.update({\n          iClosedWindow: false,\n          window: null\n        });\n      }\n\n      if (window === null && windowTimer) clearInterval(windowTimer);\n    }, 500);\n    this.update({\n      windowTimer: timer\n    });\n  }\n\n}\n\nclass PopupStoreChannel {\n  constructor(_ref) {\n    let {\n      instanceId,\n      handleLogout,\n      handleAccountImport,\n      handleNetworkChange,\n      handleSelectedAddressChange,\n      handleThemeChange\n    } = _ref;\n\n    _defineProperty(this, \"handleLogout\", void 0);\n\n    _defineProperty(this, \"handleAccountImport\", void 0);\n\n    _defineProperty(this, \"handleNetworkChange\", void 0);\n\n    _defineProperty(this, \"handleThemeChange\", void 0);\n\n    _defineProperty(this, \"handleSelectedAddressChange\", void 0);\n\n    _defineProperty(this, \"instanceId\", void 0);\n\n    this.instanceId = instanceId;\n    this.handleLogout = handleLogout;\n    this.handleAccountImport = handleAccountImport;\n    this.handleNetworkChange = handleNetworkChange;\n    this.handleSelectedAddressChange = handleSelectedAddressChange;\n    this.handleThemeChange = handleThemeChange;\n  }\n\n  setupStoreChannels() {\n    this.logoutChannel();\n    this.importAccountChannel();\n    this.networkChangeChannel();\n    this.selectedAddressChangeChannel();\n    this.themeChangedChannel();\n  }\n\n  logoutChannel() {\n    const logoutChannel = new BroadcastChannel(\"\".concat(BROADCAST_CHANNELS.WALLET_LOGOUT_CHANNEL, \"_\").concat(this.instanceId), broadcastChannelOptions);\n    logoutChannel.addEventListener(\"message\", ev => {\n      var _ev$data;\n\n      log.info(\"received logout message\", ev);\n\n      if (!ev.error && ((_ev$data = ev.data) === null || _ev$data === void 0 ? void 0 : _ev$data.type) === BROADCAST_CHANNELS_MSGS.LOGOUT) {\n        log.info(\"Logging Out\");\n        this.handleLogout();\n      }\n    });\n  }\n\n  importAccountChannel() {\n    const walletAccountImportChannel = new BroadcastChannel(\"\".concat(BROADCAST_CHANNELS.WALLET_ACCOUNT_IMPORT_CHANNEL, \"_\").concat(this.instanceId), broadcastChannelOptions);\n    walletAccountImportChannel.addEventListener(\"message\", ev => {\n      var _ev$data2;\n\n      if (!ev.error && ((_ev$data2 = ev.data) === null || _ev$data2 === void 0 ? void 0 : _ev$data2.type) === BROADCAST_CHANNELS_MSGS.ACCOUNT_IMPORTED) {\n        var _ev$data3;\n\n        this.handleAccountImport((_ev$data3 = ev.data) === null || _ev$data3 === void 0 ? void 0 : _ev$data3.privKey);\n      }\n    });\n  }\n\n  networkChangeChannel() {\n    const walletAccountImportChannel = new BroadcastChannel(\"\".concat(BROADCAST_CHANNELS.WALLET_NETWORK_CHANGE_CHANNEL, \"_\").concat(this.instanceId), broadcastChannelOptions);\n    walletAccountImportChannel.addEventListener(\"message\", ev => {\n      var _ev$data4;\n\n      if (!ev.error && ((_ev$data4 = ev.data) === null || _ev$data4 === void 0 ? void 0 : _ev$data4.type) === BROADCAST_CHANNELS_MSGS.NETWORK_CHANGE) {\n        var _ev$data5;\n\n        this.handleNetworkChange((_ev$data5 = ev.data) === null || _ev$data5 === void 0 ? void 0 : _ev$data5.network);\n      }\n    });\n  }\n\n  themeChangedChannel() {\n    const walletAccountImportChannel = new BroadcastChannel(\"\".concat(BROADCAST_CHANNELS.THEME_CHANGE, \"_\").concat(this.instanceId), broadcastChannelOptions);\n    walletAccountImportChannel.addEventListener(\"message\", ev => {\n      var _ev$data6;\n\n      log.info({\n        ev\n      });\n\n      if (!ev.error && ((_ev$data6 = ev.data) === null || _ev$data6 === void 0 ? void 0 : _ev$data6.type) === BROADCAST_CHANNELS_MSGS.SET_THEME) {\n        var _ev$data7;\n\n        this.handleThemeChange((_ev$data7 = ev.data) === null || _ev$data7 === void 0 ? void 0 : _ev$data7.theme);\n      }\n    });\n  }\n\n  selectedAddressChangeChannel() {\n    const walletAccountImportChannel = new BroadcastChannel(\"\".concat(BROADCAST_CHANNELS.WALLET_SELECTED_ADDRESS_CHANNEL, \"_\").concat(this.instanceId), broadcastChannelOptions);\n    walletAccountImportChannel.addEventListener(\"message\", ev => {\n      var _ev$data8;\n\n      if (!ev.error && ((_ev$data8 = ev.data) === null || _ev$data8 === void 0 ? void 0 : _ev$data8.type) === BROADCAST_CHANNELS_MSGS.SELECTED_ADDRESS_CHANGE) {\n        var _ev$data9;\n\n        this.handleSelectedAddressChange((_ev$data9 = ev.data) === null || _ev$data9 === void 0 ? void 0 : _ev$data9.selectedAddress);\n      }\n    });\n  }\n\n}\n\n/**\n * PopupWithBcHandler is a PopupHandler which uses broadcast channel to communicate with the popup window.\n */\n\nclass PopupWithBcHandler extends PopupHandler {\n  constructor(_ref) {\n    let {\n      config,\n      state,\n      instanceId\n    } = _ref;\n    super({\n      config,\n      state\n    });\n\n    _defineProperty(this, \"bc\", void 0);\n\n    this.bc = new BroadcastChannel(instanceId, broadcastChannelOptions);\n  }\n  /**\n   * Receives the data from popup window and closes the window\n   * @param successExtraFn - Extra function to be called after the data is received\n   * @returns The data to be received\n   */\n\n\n  handle(successExtraFn) {\n    return new Promise((resolve, reject) => {\n      const closeListener = () => {\n        this.bc.close();\n        reject(new UserError(\"user closed popup\"));\n        this.removeListener(\"close\", closeListener);\n      };\n\n      this.on(\"close\", closeListener);\n      this.bc.addEventListener(\"message\", async ev => {\n        log.info(ev, \"receiving data on channel: \".concat(this.bc.name));\n\n        try {\n          const {\n            error,\n            data\n          } = ev;\n\n          if (error) {\n            reject(new Error(error));\n            return;\n          }\n\n          if (successExtraFn) await successExtraFn.call(this, data);\n          resolve(data);\n        } catch (error) {\n          reject(error);\n        } finally {\n          this.bc.close();\n          this.close();\n        }\n      });\n      this.open().then(() => {\n        log.info(\"opened window \".concat(this.bc.name)); // Opened window. yay.  let the bc events do their job\n\n        return undefined;\n      }).catch(err => {\n        log.error(err, \"something went wrong while opening window\");\n        reject(err);\n      });\n    });\n  }\n  /**\n   * Use this if we have to send large payloads which don't fit in query/hash params.\n   * Waits for ack that popup window is ready to receive data.\n   * Receives the data from popup window and closes the window\n   * @param payload - The data to be sent to the popup window once we have ack that window is ready to receive data\n   * @param successExtraFn - Extra function to be called after the data is received\n   * @returns The data to be received\n   */\n\n\n  handleWithHandshake(payload, successExtraFn) {\n    return new Promise((resolve, reject) => {\n      const closeListener = () => {\n        this.bc.close();\n        reject(new UserError(\"user closed popup\"));\n        this.removeListener(\"close\", closeListener);\n      };\n\n      this.on(\"close\", closeListener);\n      this.bc.addEventListener(\"message\", async ev => {\n        try {\n          log.info(ev, \"receiving data on channel: \".concat(this.bc.name));\n          const {\n            error,\n            data\n          } = ev;\n\n          if (error) {\n            reject(new Error(error));\n            return;\n          } // Do handshake\n\n\n          const {\n            type = \"\"\n          } = data;\n\n          if (type === POPUP_LOADED) {\n            // Hack with generic to use the same type for both send and receive\n            await this.bc.postMessage({\n              data: payload\n            });\n          } else if (type === POPUP_RESULT) {\n            if (successExtraFn) await successExtraFn.call(this, data);\n            resolve(data); // Must only close the bc after result is done\n\n            this.bc.close();\n            this.close();\n          }\n        } catch (error) {\n          reject(error);\n          this.bc.close();\n          this.close();\n        }\n      });\n      this.open().then(() => {\n        log.info(\"opened window \".concat(this.bc.name)); // Opened window. yay.  let the bc events do their job\n\n        return undefined;\n      }).catch(err => {\n        log.error(err, \"something went wrong while opening window\");\n        reject(err);\n      });\n    });\n  }\n\n}\n\nclass RedirectHandler {\n  constructor() {\n    _defineProperty(this, \"error\", void 0);\n\n    _defineProperty(this, \"finalQueryParams\", {});\n\n    _defineProperty(this, \"instanceParameters\", void 0);\n\n    _defineProperty(this, \"hashParameters\", void 0);\n\n    const {\n      hash\n    } = window.location;\n    const queryParameters = new URLSearchParams(window.location.search);\n    queryParameters.forEach((value, key) => {\n      this.finalQueryParams[key] = value;\n    });\n    const {\n      error,\n      instanceParameters,\n      hashParameters\n    } = handleRedirectParameters(hash, this.finalQueryParams);\n    this.error = error;\n    this.instanceParameters = instanceParameters;\n    this.hashParameters = hashParameters;\n  }\n\n  async handle() {\n    return new Promise((resolve, reject) => {\n      const {\n        finalQueryParams,\n        instanceParameters,\n        hashParameters,\n        error\n      } = this;\n      let bc;\n\n      try {\n        if (!finalQueryParams.windowId) {\n          bc = new BroadcastChannel(\"\".concat(BROADCAST_CHANNELS.REDIRECT_CHANNEL, \"_\").concat(instanceParameters.instanceId), broadcastChannelOptions);\n          bc.addEventListener(\"message\", async ev => {\n            if (ev.error) {\n              reject(ev.error);\n              window.close();\n            } else {\n              resolve();\n              bc.close();\n              log.info(\"posted\", {\n                finalQueryParams,\n                hashParameters,\n                instanceParameters\n              });\n            }\n          });\n          bc.postMessage({\n            data: {\n              instanceParams: instanceParameters,\n              hashParams: hashParameters,\n              queryParams: finalQueryParams\n            },\n            error\n          });\n          setTimeout(() => {\n            resolve();\n            window.location.href = window.location.origin + window.location.search + window.location.hash;\n          }, 5000);\n        } else {\n          bc = new BroadcastChannel(\"\".concat(finalQueryParams.windowId), broadcastChannelOptions);\n          bc.addEventListener(\"message\", async ev => {\n            const {\n              url,\n              message\n            } = ev.data;\n\n            if (url) {\n              resolve();\n              window.location.href = url;\n            } else if (message === SETUP_COMPLETE) {\n              await bc.postMessage({\n                data: {\n                  windowId: finalQueryParams.windowId,\n                  message: POPUP_LOADED\n                }\n              });\n            }\n\n            if (ev.error && ev.error !== \"\") {\n              log.error(ev.error);\n              resolve();\n              bc.close();\n            }\n          });\n        }\n      } catch (err) {\n        log.info(err, \"something went wrong\");\n        reject(err);\n        if (bc) bc.close();\n        window.close();\n      }\n    });\n  }\n\n}\n\nconst ACTIVITY_ACTION = {\n  ACTIVITY_ACTION_ALL: \"walletActivity.allTransactions\",\n  ACTIVITY_ACTION_SEND: \"walletActivity.send\",\n  ACTIVITY_ACTION_RECEIVE: \"walletActivity.receive\",\n  ACTIVITY_ACTION_TOPUP: \"walletActivity.topup\"\n};\nconst ACCOUNT_CATEGORY = {\n  NORMAL: \"normal\",\n  THRESHOLD: \"threshold\",\n  IMPORTED: \"imported\"\n};\n\nfunction ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nconst DEFAULT_INTERVAL = 180 * 1000;\nconst DEFAULT_PREFERENCES = {\n  selectedCurrency: \"USD\",\n  theme: \"dark\",\n  locale: \"en-US\",\n  accountType: ACCOUNT_CATEGORY.NORMAL,\n  contacts: [],\n  jwtToken: \"\",\n  fetchedPastTx: [],\n  pastTransactions: [],\n  paymentTx: [],\n  defaultPublicAddress: \"\",\n  customTokens: [],\n  customNfts: [],\n  crashReport: true,\n  userInfo: {\n    aggregateVerifier: \"\",\n    email: \"\",\n    name: \"\",\n    profileImage: \"\",\n    typeOfLogin: LOGIN_PROVIDER.GOOGLE,\n    verifier: \"\",\n    verifierId: \"\"\n  }\n};\n/**\n * Controller that stores shared settings and exposes convenience methods\n */\n\nclass BasePreferencesController extends BaseController {\n  /**\n   * Name of this controller used during composition\n   */\n\n  /**\n   * Creates a PreferencesController instance\n   *\n   * @param config - Initial options used to configure this controller\n   * @param state - Initial state to set on this controller\n   */\n  constructor(_ref) {\n    let {\n      config,\n      state,\n      defaultPreferences,\n      signAuthMessage\n    } = _ref;\n    super({\n      config,\n      state\n    });\n\n    _defineProperty(this, \"name\", \"PreferencesController\");\n\n    _defineProperty(this, \"iframeOrigin\", void 0);\n\n    _defineProperty(this, \"signAuthMessage\", void 0);\n\n    _defineProperty(this, \"defaultPreferences\", void 0);\n\n    if (!config.api) {\n      throw new Error(\"PreferencesController - no api specified in config.\");\n    }\n\n    this.defaultState = {\n      identities: {},\n      selectedAddress: \"\",\n      lastErrorMessage: \"\",\n      lastSuccessMessage: \"\"\n    };\n    this.defaultConfig = {\n      api: config.api,\n      pollInterval: DEFAULT_INTERVAL\n    };\n    this.initialize();\n    this.defaultPreferences = _objectSpread$1(_objectSpread$1({}, DEFAULT_PREFERENCES), defaultPreferences);\n    this.signAuthMessage = signAuthMessage;\n  }\n\n  setIframeOrigin(origin) {\n    this.iframeOrigin = origin;\n  }\n\n  getAddressState(address) {\n    const selectedAddress = address || this.state.selectedAddress;\n    return this.state.identities[selectedAddress];\n  }\n  /**\n   * Sets selected address\n   *\n   * @param selectedAddress - casper account hash\n   */\n\n\n  setSelectedAddress(selectedAddress) {\n    this.update({\n      selectedAddress\n    });\n  }\n\n  async getUser(address) {\n    const user = await get(\"\".concat(this.config.api, \"/user?fetchTx=false\"), this.headers(address), {\n      useAPIKey: true\n    });\n    return user.data;\n  }\n\n  async createUser(params) {\n    const {\n      selectedCurrency,\n      theme,\n      verifier,\n      verifierId,\n      locale,\n      address,\n      idToken\n    } = params;\n    const userPayload = {\n      default_currency: selectedCurrency,\n      theme,\n      verifier,\n      verifier_id: verifierId,\n      locale,\n      idToken\n    };\n    await post(\"\".concat(this.config.api, \"/user\"), userPayload, this.headers(address), {\n      useAPIKey: true\n    });\n    this.updateState({\n      theme,\n      defaultPublicAddress: address,\n      selectedCurrency,\n      locale\n    }, address);\n  }\n\n  async storeUserLogin(params) {\n    const {\n      verifierId,\n      verifier,\n      options,\n      address,\n      idToken\n    } = params;\n\n    if (!options.rehydrate) {\n      const browser = bowser.getParser(window.navigator.userAgent);\n      const specialBrowser = getCustomDeviceInfo();\n      const recordLoginPayload = {\n        os: browser.getOSName(),\n        os_version: browser.getOSVersion() || \"unidentified\",\n        browser: (specialBrowser === null || specialBrowser === void 0 ? void 0 : specialBrowser.browser) || browser.getBrowserName() || \"unidentified\",\n        browser_version: browser.getBrowserVersion() || \"unidentified\",\n        platform: browser.getPlatform().type || \"desktop\",\n        hostname: this.iframeOrigin,\n        verifier,\n        verifier_id: verifierId,\n        idToken\n      };\n      await post(\"\".concat(this.config.api, \"/user/recordLogin\"), recordLoginPayload, this.headers(address), {\n        useAPIKey: true\n      });\n    }\n  }\n\n  async setCrashReport(isEnabled) {\n    var _this$getAddressState;\n\n    if (isEnabled === ((_this$getAddressState = this.getAddressState()) === null || _this$getAddressState === void 0 ? void 0 : _this$getAddressState.crashReport)) return true;\n\n    try {\n      await patch(\"\".concat(this.config.api, \"/user\"), {\n        enable_crash_reporter: isEnabled\n      }, this.headers(), {\n        useAPIKey: true\n      });\n      this.updateState({\n        crashReport: isEnabled\n      });\n      return true;\n    } catch (error) {\n      log.error(error);\n      return false;\n    }\n  }\n\n  async setUserTheme(theme) {\n    var _this$getAddressState2;\n\n    if (theme === ((_this$getAddressState2 = this.getAddressState()) === null || _this$getAddressState2 === void 0 ? void 0 : _this$getAddressState2.theme)) return true;\n\n    try {\n      await patch(\"\".concat(this.config.api, \"/user\"), {\n        theme\n      }, this.headers(), {\n        useAPIKey: true\n      });\n      this.updateState({\n        theme\n      });\n      return true;\n    } catch (error) {\n      log.error(error);\n      return false;\n    }\n  }\n\n  async setUserLocale(locale) {\n    var _this$getAddressState3;\n\n    if (locale === ((_this$getAddressState3 = this.getAddressState()) === null || _this$getAddressState3 === void 0 ? void 0 : _this$getAddressState3.locale)) return;\n\n    try {\n      await patch(\"\".concat(this.config.api, \"/user\"), {\n        locale\n      }, this.headers(), {\n        useAPIKey: true\n      });\n      this.updateState({\n        locale\n      });\n      return true;\n    } catch (error) {\n      log.error(\"unable to set locale\", error);\n      return false;\n    }\n  }\n\n  async setSelectedCurrency(payload) {\n    var _this$getAddressState4;\n\n    if (payload.selectedCurrency === ((_this$getAddressState4 = this.getAddressState()) === null || _this$getAddressState4 === void 0 ? void 0 : _this$getAddressState4.selectedCurrency)) return true;\n\n    try {\n      await patch(\"\".concat(this.config.api, \"/user\"), {\n        default_currency: payload.selectedCurrency\n      }, this.headers(), {\n        useAPIKey: true\n      });\n      this.updateState({\n        selectedCurrency: payload.selectedCurrency\n      });\n      return true;\n    } catch (error) {\n      log.error(error);\n      return false;\n    }\n  }\n\n  async addContact(contact) {\n    try {\n      var _this$getAddressState5;\n\n      const response = await post(\"\".concat(this.config.api, \"/contact\"), contact, this.headers(), {\n        useAPIKey: true\n      });\n      this.updateState({\n        contacts: [...(((_this$getAddressState5 = this.getAddressState()) === null || _this$getAddressState5 === void 0 ? void 0 : _this$getAddressState5.contacts) || []), response.data]\n      });\n      return true;\n    } catch (error) {\n      log.error(\"unable to add contact\", error);\n      return false;\n    }\n  }\n\n  async deleteContact(contactId) {\n    try {\n      var _this$getAddressState6;\n\n      const response = await remove(\"\".concat(this.config.api, \"/contact/\").concat(contactId), {}, this.headers(), {\n        useAPIKey: true\n      });\n      const finalContacts = (_this$getAddressState6 = this.getAddressState()) === null || _this$getAddressState6 === void 0 ? void 0 : _this$getAddressState6.contacts.filter(contact => contact.id !== response.data.id);\n      if (finalContacts) this.updateState({\n        contacts: [...finalContacts]\n      });\n      return true;\n    } catch (error) {\n      log.error(\"unable to delete contact\", error);\n      return false;\n    }\n  }\n\n  async revokeDiscord(idToken) {\n    try {\n      const resp = await post(\"\".concat(this.config.api, \"/revoke/discord\"), {\n        token: idToken\n      }, this.headers(), {\n        useAPIKey: true\n      });\n      log.info(resp);\n    } catch (error) {\n      log.error(error);\n    }\n  }\n\n  async patchPastTx(body, address) {\n    try {\n      const response = await patch(\"\".concat(this.config.api, \"/transaction\"), body, this.headers(address), {\n        useAPIKey: true\n      });\n      log.info(\"successfully patched\", response);\n    } catch (error) {\n      log.error(\"unable to patch tx\", error);\n    }\n  }\n\n  async postPastTx(tx, address) {\n    try {\n      const response = await post(\"\".concat(this.config.api, \"/transaction\"), tx, this.headers(address), {\n        useAPIKey: true\n      });\n      log.info(\"successfully posted tx\", response);\n      return response;\n    } catch (error) {\n      log.error(error, \"unable to insert transaction\");\n    }\n  }\n\n  async getWalletOrders(address) {\n    try {\n      const response = await get(\"\".concat(this.config.api, \"/transaction\"), this.headers(address), {\n        useAPIKey: true\n      });\n      return response.success ? response.data ? response.data : [] : [];\n    } catch (error) {\n      log.error(\"unable to get wallet orders tx\", error);\n      return [];\n    }\n  }\n\n  async getTopUpOrders(address) {\n    try {\n      const response = await get(\"\".concat(this.config.commonApiHost, \"/transaction\"), this.headers(address), {\n        useAPIKey: true\n      });\n      return response.data || [];\n    } catch (error) {\n      log.error(\"unable to fetch past Top up orders\", error);\n    }\n  }\n\n  async getBillBoardData() {\n    try {\n      const response = await get(\"\".concat(this.config.api, \"/billboard\"), this.headers(), {\n        useAPIKey: true\n      });\n      return response.success ? response.data : [];\n    } catch (error) {\n      log.error(\"unable to get billboard data\", error);\n      return [];\n    }\n  }\n\n  async getMessageForSigning(publicAddress) {\n    const response = await post(\"\".concat(this.config.api, \"/auth/message\"), {\n      public_address: publicAddress\n    }, {}, {\n      useAPIKey: true\n    });\n    return response.message;\n  }\n\n  async getTwitterId(payload) {\n    const res = await get(\"\".concat(this.config.api, \"/twitter?screen_name=\").concat(payload.nick), this.headers(), {\n      useAPIKey: true\n    });\n    return \"\".concat(payload.typeOfLogin.toLowerCase(), \"|\").concat(res.data.toString());\n  }\n\n  async sendEmail(payload) {\n    return post(\"\".concat(this.config.api, \"/transaction/sendemail\"), payload.emailObject, this.headers(), {\n      useAPIKey: true\n    });\n  }\n\n  async refreshJwt() {\n    const address = this.state.selectedAddress;\n    const messageToSign = await this.getMessageForSigning(address);\n    if (!messageToSign.startsWith(this.config.signInPrefix)) throw new Error(\"Cannot sign on invalid message\");\n    const signedMessage = this.signAuthMessage(address, messageToSign);\n    const response = await post(\"\".concat(this.config.api, \"/auth/verify\"), {\n      public_address: address,\n      signed_message: signedMessage\n    }, {}, {\n      useAPIKey: true\n    });\n    this.updateState({\n      jwtToken: response.token\n    }, address);\n  }\n\n  async getDappList() {\n    try {\n      const response = await get(\"\".concat(this.config.api, \"/dapps\"), this.headers(), {\n        useAPIKey: true\n      });\n      return response.success ? response.data : [];\n    } catch (error) {\n      log.error(\"unable to get billboard data\", error);\n      return [];\n    }\n  }\n\n  async init(address, userInfo, jwtToken) {\n    let response = {\n      token: jwtToken\n    };\n    if (this.getAddressState(address)) return;\n\n    if (!jwtToken) {\n      const messageToSign = await this.getMessageForSigning(address);\n      if (!messageToSign.startsWith(this.config.signInPrefix)) throw new Error(\"Cannot sign on invalid message\");\n      const signedMessage = this.signAuthMessage(address, messageToSign);\n      response = await post(\"\".concat(this.config.api, \"/auth/verify\"), {\n        public_address: address,\n        signed_message: signedMessage\n      }, {}, {\n        useAPIKey: true\n      });\n    }\n\n    this.updateState({\n      jwtToken: response.token,\n      userInfo\n    }, address);\n  }\n\n  updateState(preferences, address) {\n    const selectedAddress = address || this.state.selectedAddress;\n    const currentState = this.getAddressState(selectedAddress) || cloneDeep(this.defaultPreferences);\n\n    const mergedState = _objectSpread$1(_objectSpread$1({}, currentState), preferences);\n\n    this.update({\n      identities: _objectSpread$1(_objectSpread$1({}, this.state.identities), {}, {\n        [selectedAddress]: mergedState\n      })\n    });\n    return mergedState;\n  }\n\n  headers(address) {\n    var _this$getAddressState7;\n\n    const selectedAddress = address || this.state.selectedAddress;\n    return getHeaders(((_this$getAddressState7 = this.getAddressState(selectedAddress)) === null || _this$getAddressState7 === void 0 ? void 0 : _this$getAddressState7.jwtToken) || \"\");\n  }\n\n}\n\n/**\n * The status of the transaction. Each status represents the state of the transaction internally\n * in the wallet. Some of these correspond with the state of the transaction on the network, but\n * some are wallet-specific.\n */\nvar TransactionStatus;\n\n(function (TransactionStatus) {\n  TransactionStatus[\"approved\"] = \"approved\";\n  TransactionStatus[\"cancelled\"] = \"cancelled\";\n  TransactionStatus[\"confirmed\"] = \"confirmed\";\n  TransactionStatus[\"failed\"] = \"failed\";\n  TransactionStatus[\"finalized\"] = \"finalized\";\n  TransactionStatus[\"processed\"] = \"processed\";\n  TransactionStatus[\"rejected\"] = \"rejected\";\n  TransactionStatus[\"signed\"] = \"signed\";\n  TransactionStatus[\"submitted\"] = \"submitted\";\n  TransactionStatus[\"unapproved\"] = \"unapproved\";\n  TransactionStatus[\"dropped\"] = \"dropped\";\n  TransactionStatus[\"expired\"] = \"expired\";\n})(TransactionStatus || (TransactionStatus = {}));\n\nconst TRANSACTION_TYPES = {\n  CONTRACT_INTERACTION: \"contractInteraction\",\n  DEPLOY_CONTRACT: \"contractDeployment\",\n  WASM_BASED_DEPLOY: \"wasmBasedDeploy\",\n  STANDARD_TRANSACTION: \"transaction\",\n  STANDARD_PAYMENT_TRANSACTION: \"payment_transaction\" // specific to chains like solana and casper\n\n};\nconst TX_EVENTS = {\n  TX_WARNING: \"tx:warning\",\n  TX_ERROR: \"tx:error\",\n  TX_FAILED: \"tx:failed\",\n  TX_CONFIRMED: \"tx:confirmed\",\n  TX_DROPPED: \"tx:dropped\",\n  TX_EXPIRED: \"tx:expired\",\n  TX_STATUS_UPDATE: \"tx:status_update\",\n  TX_UNAPPROVED: \"tx:unapproved\"\n};\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass BaseTransactionStateManager extends BaseController {\n  constructor(_ref) {\n    let {\n      config,\n      state,\n      getCurrentChainId\n    } = _ref;\n    super({\n      config,\n      state\n    });\n\n    _defineProperty(this, \"getCurrentChainId\", void 0);\n\n    this.defaultConfig = {\n      txHistoryLimit: 40\n    };\n    this.defaultState = {\n      transactions: {},\n      unapprovedTxs: {},\n      currentNetworkTxsList: []\n    };\n    this.initialize();\n    this.getCurrentChainId = getCurrentChainId;\n  }\n\n  getUnapprovedTxList() {\n    const chainId = this.getCurrentChainId();\n    return pickBy(this.state.transactions, transaction => transaction.status === TransactionStatus.unapproved && transactionMatchesNetwork(transaction, chainId));\n  }\n\n  getTransaction(txId) {\n    const {\n      transactions\n    } = this.state;\n    return transactions[txId];\n  }\n\n  updateTransaction(txMeta) {\n    // commit txMeta to state\n    const txId = txMeta.id;\n    txMeta.updated_at = new Date().toISOString();\n    this.update({\n      transactions: _objectSpread(_objectSpread({}, this.state.transactions), {}, {\n        [txId]: txMeta\n      })\n    });\n  }\n\n  setTxStatusRejected(txId) {\n    this._setTransactionStatus(txId, TransactionStatus.rejected);\n\n    this._deleteTransaction(txId);\n  }\n  /**\n   * The implementing controller can override this functionality and add custom logic + call super.()\n   */\n\n\n  setTxStatusUnapproved(txId) {\n    this._setTransactionStatus(txId, TransactionStatus.unapproved);\n  }\n\n  setTxStatusApproved(txId) {\n    this._setTransactionStatus(txId, TransactionStatus.approved);\n  }\n\n  setTxStatusSigned(txId) {\n    this._setTransactionStatus(txId, TransactionStatus.signed);\n  }\n\n  setTxStatusSubmitted(txId) {\n    this._setTransactionStatus(txId, TransactionStatus.submitted);\n  }\n\n  setTxStatusDropped(txId) {\n    this._setTransactionStatus(txId, TransactionStatus.dropped);\n  }\n\n  setTxStatusExpired(txId) {\n    this._setTransactionStatus(txId, TransactionStatus.expired);\n  }\n\n  setTxStatusConfirmed(txId) {\n    this._setTransactionStatus(txId, TransactionStatus.confirmed);\n  }\n\n  setTxStatusFailed(txId, error_) {\n    const error = !error_ ? new Error(\"Internal torus failure\") : error_;\n    const txMeta = this.getTransaction(txId);\n    txMeta.error = error;\n    this.updateTransaction(txMeta);\n\n    this._setTransactionStatus(txId, TransactionStatus.failed);\n  }\n  /**\n   * Method to determine if the transaction is in a final state\n   * @param status - Transaction status\n   * @returns boolean if the transaction is in a final state\n   */\n\n\n  isFinalState(status) {\n    return status === TransactionStatus.rejected || status === TransactionStatus.submitted || status === TransactionStatus.confirmed || status === TransactionStatus.failed || status === TransactionStatus.cancelled || status === TransactionStatus.expired;\n  }\n  /**\n   * Filters out the unapproved transactions from state\n   */\n\n\n  clearUnapprovedTxs() {\n    this.update({\n      transactions: omitBy(this.state.transactions, transaction => transaction.status === TransactionStatus.unapproved)\n    });\n  }\n  /**\n   * will append new transactions to old txns.\n   */\n\n\n  _addTransactionsToState(transactions) {\n    this.update({\n      transactions: transactions.reduce((result, newTx) => {\n        result[newTx.id] = newTx;\n        return result;\n      }, this.state.transactions)\n    });\n  }\n  /**\n   * will set new txns, override existing if any in state.\n   */\n\n\n  _setTransactionsToState(transactions) {\n    this.update({\n      transactions: transactions.reduce((result, newTx) => {\n        result[newTx.id] = newTx;\n        return result;\n      }, {})\n    });\n  }\n\n  _deleteTransaction(targetTransactionId) {\n    const {\n      transactions\n    } = this.state;\n    delete transactions[targetTransactionId];\n    this.update({\n      transactions\n    });\n  }\n\n  _deleteTransactions(targetTransactionIds) {\n    const {\n      transactions\n    } = this.state;\n    targetTransactionIds.forEach(transactionId => {\n      delete transactions[transactionId];\n    });\n    this.update({\n      transactions\n    });\n  }\n\n  _setTransactionStatus(txId, status) {\n    const txMeta = this.getTransaction(txId);\n\n    if (!txMeta) {\n      return;\n    }\n\n    txMeta.status = status; // only updating status so no validation required on txn.\n\n    this.updateTransaction(txMeta);\n    this.emit(TX_EVENTS.TX_STATUS_UPDATE, {\n      txId,\n      status\n    });\n\n    if (this.isFinalState(status)) {\n      this.emit(\"\".concat(txMeta.id, \":finished\"), txMeta);\n    } else {\n      this.emit(\"\".concat(txMeta.id, \":\").concat(status), txId);\n    }\n  }\n\n}\n\nexport { ACCOUNT_CATEGORY, ACTIVITY_ACTION, ACTIVITY_ACTION_ALL, ACTIVITY_ACTION_BURN, ACTIVITY_ACTION_RECEIVE, ACTIVITY_ACTION_SEND, ACTIVITY_ACTION_TOPUP, ACTIVITY_PERIOD_ALL, ACTIVITY_PERIOD_MONTH_ONE, ACTIVITY_PERIOD_MONTH_SIX, ACTIVITY_PERIOD_WEEK_ONE, ACTIVITY_STATUS_CANCELLED, ACTIVITY_STATUS_CANCELLING, ACTIVITY_STATUS_PENDING, ACTIVITY_STATUS_SUCCESSFUL, ACTIVITY_STATUS_UNSUCCESSFUL, BROADCAST_CHANNELS, BROADCAST_CHANNELS_MSGS, BaseBlockTracker, BaseController, BaseCurrencyController, BaseEmbedController, BaseKeyringController, BasePreferencesController, BaseTransactionStateManager, BroadcastChannelHandler, COMMUNICATION_JRPC_METHODS, COMMUNICATION_NOTIFICATIONS, CommunicationWindowManager, DEFAULT_PREFERENCES, FEATURES_CONFIRM_WINDOW, FEATURES_DEFAULT_POPUP_WINDOW, FEATURES_DEFAULT_WALLET_WINDOW, FEATURES_PROVIDER_CHANGE_WINDOW, LOGIN_PROVIDER, PAYMENT_PROVIDER, POPUP_LOADED, POPUP_RESULT, PROVIDER_JRPC_METHODS, PROVIDER_NOTIFICATIONS, PopupHandler, PopupStoreChannel, PopupWithBcHandler, RedirectHandler, SETUP_COMPLETE, StreamWindow, TRANSACTION_TYPES, TX_EVENTS, TransactionStatus, UserError, addressSlicer, broadcastChannelOptions, concatSig, createChangeProviderMiddlewareMiddleware, createCommunicationMiddleware, createEventEmitterProxy, createFetchConfigFromReq, createFetchMiddleware, createGenericJRPCMiddleware, createLoggerMiddleware, createOriginMiddleware, createRandomId, createSwappableProxy, createTopupMiddleware, formatDate, formatSmallNumbers, formatTime, getCustomDeviceInfo, getHeaders, getPopupFeatures, getTxStatusText, handleRedirectParameters, hashMessage, intToHex, padWithZeroes, providerAsMiddleware, providerFromEngine, providerFromMiddleware, randomId, signMessage, significantDigits, sleep, timeout$1 as timeout, transactionMatchesNetwork };\n//# sourceMappingURL=baseControllers.esm.js.map\n",null,null,null,null,null,null,null,null,"import loglevel from 'loglevel';\nimport _typeof from '@babel/runtime/helpers/typeof';\nimport _slicedToArray from '@babel/runtime/helpers/slicedToArray';\nimport _asyncToGenerator from '@babel/runtime/helpers/asyncToGenerator';\nimport _classCallCheck from '@babel/runtime/helpers/classCallCheck';\nimport _createClass from '@babel/runtime/helpers/createClass';\nimport _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport _regeneratorRuntime from '@babel/runtime/regenerator';\nimport { sign, getPublic, encrypt, decrypt } from '@toruslabs/eccrypto';\nimport { get } from '@toruslabs/http-helpers';\nimport { setupMultiplex, PostMessageStream, createStreamMiddleware, JRPCEngine, createIdRemapMiddleware, SafeEventEmitter, getRpcPromiseCallback } from '@toruslabs/openlogin-jrpc';\nimport { base64url, keccak, safeatob, randomId, jsonToBase64 } from '@toruslabs/openlogin-utils';\nimport merge from 'lodash.merge';\nimport _assertThisInitialized from '@babel/runtime/helpers/assertThisInitialized';\nimport _inherits from '@babel/runtime/helpers/inherits';\nimport _possibleConstructorReturn from '@babel/runtime/helpers/possibleConstructorReturn';\nimport _getPrototypeOf from '@babel/runtime/helpers/getPrototypeOf';\nimport pump from 'pump';\n\nvar modalDOMElementID = \"openlogin-modal\";\nvar storeKey = \"openlogin_store\";\nvar UX_MODE = {\n  POPUP: \"popup\",\n  REDIRECT: \"redirect\"\n};\nvar OPENLOGIN_METHOD = {\n  LOGIN: \"openlogin_login\",\n  LOGOUT: \"openlogin_logout\",\n  CHECK_3PC_SUPPORT: \"openlogin_check_3PC_support\",\n  SET_PID_DATA: \"openlogin_set_pid_data\",\n  GET_DATA: \"openlogin_get_data\"\n};\nvar ALLOWED_INTERACTIONS = {\n  POPUP: \"popup\",\n  REDIRECT: \"redirect\",\n  JRPC: \"jrpc\"\n};\nvar OPENLOGIN_NETWORK = {\n  MAINNET: \"mainnet\",\n  TESTNET: \"testnet\",\n  CYAN: \"cyan\",\n  DEVELOPMENT: \"development\",\n  SK_TESTNET: \"sk_testnet\"\n};\nvar SUPPORTED_KEY_CURVES = {\n  SECP256K1: \"secp256k1\",\n  ED25519: \"ed25519\"\n};\nvar LOGIN_PROVIDER = {\n  GOOGLE: \"google\",\n  FACEBOOK: \"facebook\",\n  REDDIT: \"reddit\",\n  DISCORD: \"discord\",\n  TWITCH: \"twitch\",\n  APPLE: \"apple\",\n  LINE: \"line\",\n  GITHUB: \"github\",\n  KAKAO: \"kakao\",\n  LINKEDIN: \"linkedin\",\n  TWITTER: \"twitter\",\n  WEIBO: \"weibo\",\n  WECHAT: \"wechat\",\n  EMAIL_PASSWORDLESS: \"email_passwordless\",\n  WEBAUTHN: \"webauthn\",\n  JWT: \"jwt\"\n};\nvar MFA_LEVELS = {\n  DEFAULT: \"default\",\n  OPTIONAL: \"optional\",\n  MANDATORY: \"mandatory\",\n  NONE: \"none\"\n};\n\nloglevel.setLevel(\"error\");\nvar log = loglevel.getLogger(\"openlogin\");\n\nfunction documentReady() {\n  return _documentReady.apply(this, arguments);\n}\nfunction _documentReady() {\n  _documentReady = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            return _context.abrupt(\"return\", new Promise(function (resolve) {\n              if (document.readyState !== \"loading\") {\n                resolve();\n              } else {\n                document.addEventListener(\"DOMContentLoaded\", function () {\n                  resolve();\n                });\n              }\n            }));\n          case 1:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _documentReady.apply(this, arguments);\n}\nvar htmlToElement = function htmlToElement(html) {\n  var template = window.document.createElement(\"template\");\n  var trimmedHtml = html.trim(); // Never return a text node of whitespace as the result\n  template.innerHTML = trimmedHtml;\n  return template.content.firstChild;\n};\nfunction whitelistUrl(_x, _x2, _x3) {\n  return _whitelistUrl.apply(this, arguments);\n}\nfunction _whitelistUrl() {\n  _whitelistUrl = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(clientId, appKey, origin) {\n    var appKeyBuf, sig;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            appKeyBuf = Buffer.from(appKey.padStart(64, \"0\"), \"hex\");\n            if (!(base64url.encode(getPublic(appKeyBuf)) !== clientId)) {\n              _context2.next = 3;\n              break;\n            }\n            throw new Error(\"appKey mismatch\");\n          case 3:\n            _context2.next = 5;\n            return sign(appKeyBuf, Buffer.from(keccak(\"keccak256\").update(origin).digest(\"hex\"), \"hex\"));\n          case 5:\n            sig = _context2.sent;\n            return _context2.abrupt(\"return\", base64url.encode(sig));\n          case 7:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _whitelistUrl.apply(this, arguments);\n}\nfunction getHashQueryParams() {\n  var replaceUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  var result = {};\n  var url = new URL(window.location.href);\n  url.searchParams.forEach(function (value, key) {\n    if (key !== \"result\") {\n      result[key] = value;\n    }\n  });\n  var queryResult = url.searchParams.get(\"result\");\n  if (queryResult) {\n    try {\n      var queryParams = JSON.parse(safeatob(queryResult));\n      Object.keys(queryParams).forEach(function (key) {\n        result[key] = queryParams[key];\n      });\n    } catch (error) {\n      log.error(error);\n    }\n  }\n  var hash = url.hash.substring(1);\n  var hashUrl = new URL(\"\".concat(window.location.origin, \"/?\").concat(hash));\n  hashUrl.searchParams.forEach(function (value, key) {\n    if (key !== \"result\") {\n      result[key] = value;\n    }\n  });\n  var hashResult = hashUrl.searchParams.get(\"result\");\n  if (hashResult) {\n    try {\n      var hashParams = JSON.parse(safeatob(hashResult));\n      Object.keys(hashParams).forEach(function (key) {\n        result[key] = hashParams[key];\n      });\n    } catch (error) {\n      log.error(error);\n    }\n  }\n  if (replaceUrl) {\n    var cleanUrl = window.location.origin + window.location.pathname;\n    window.history.replaceState(null, \"\", cleanUrl);\n  }\n  return result;\n}\nfunction awaitReq(id, windowRef) {\n  return new Promise(function (resolve, reject) {\n    if (!windowRef) {\n      reject(new Error(\"Unable to open window\"));\n      return;\n    }\n    var closedByHandler = false;\n    var closedMonitor = setInterval(function () {\n      if (!closedByHandler && windowRef.closed) {\n        clearInterval(closedMonitor);\n        reject(new Error(\"user closed popup\"));\n      }\n    }, 500);\n    var handler = function handler(ev) {\n      var pid = ev.data.pid;\n      if (id !== pid) return;\n      window.removeEventListener(\"message\", handler);\n      closedByHandler = true;\n      clearInterval(closedMonitor);\n      windowRef.close();\n      if (ev.data.data && ev.data.data.error) {\n        reject(new Error(ev.data.data.error));\n      } else {\n        resolve(ev.data.data);\n      }\n    };\n    window.addEventListener(\"message\", handler);\n  });\n}\nfunction constructURL(params) {\n  var baseURL = params.baseURL,\n    query = params.query,\n    hash = params.hash;\n  var url = new URL(baseURL);\n  if (query) {\n    Object.keys(query).forEach(function (key) {\n      url.searchParams.append(key, query[key]);\n    });\n  }\n  if (hash) {\n    var h = new URL(constructURL({\n      baseURL: baseURL,\n      query: hash\n    })).searchParams.toString();\n    url.hash = h;\n  }\n  return url.toString();\n}\nfunction storageAvailable(type) {\n  var storageExists = false;\n  var storageLength = 0;\n  var storage;\n  try {\n    storage = window[type];\n    storageExists = true;\n    storageLength = storage.length;\n    var x = \"__storage_test__\";\n    storage.setItem(x, x);\n    storage.removeItem(x);\n    return true;\n  } catch (error) {\n    return error && (\n    // everything except Firefox\n    error.code === 22 ||\n    // Firefox\n    error.code === 1014 ||\n    // test name field too, because code might not be present\n    // everything except Firefox\n    error.name === \"QuotaExceededErro r\" ||\n    // Firefox\n    error.name === \"NS_ERROR_DOM_QUOTA_REACHED\") &&\n    // acknowledge QuotaExceededError only if there's something already stored\n    storageExists && storageLength !== 0;\n  }\n}\nvar sessionStorageAvailable = storageAvailable(\"sessionStorage\");\nvar localStorageAvailable = storageAvailable(\"localStorage\");\nfunction preloadIframe(url) {\n  try {\n    if (typeof document === \"undefined\") return;\n    var openloginIframeHtml = document.createElement(\"link\");\n    openloginIframeHtml.href = url;\n    openloginIframeHtml.crossOrigin = \"anonymous\";\n    openloginIframeHtml.type = \"text/html\";\n    openloginIframeHtml.rel = \"prefetch\";\n    if (openloginIframeHtml.relList && openloginIframeHtml.relList.supports) {\n      if (openloginIframeHtml.relList.supports(\"prefetch\")) {\n        document.head.appendChild(openloginIframeHtml);\n      }\n    }\n  } catch (error) {\n    log.error(error);\n  }\n}\nfunction getPopupFeatures() {\n  // Fixes dual-screen position                             Most browsers      Firefox\n  var dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : window.screenX;\n  var dualScreenTop = window.screenTop !== undefined ? window.screenTop : window.screenY;\n  var w = 1200;\n  var h = 700;\n  var width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : window.screen.width;\n  var height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : window.screen.height;\n  var systemZoom = 1; // No reliable estimate\n  var left = Math.abs((width - w) / 2 / systemZoom + dualScreenLeft);\n  var top = Math.abs((height - h) / 2 / systemZoom + dualScreenTop);\n  var features = \"titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=\".concat(h / systemZoom, \",width=\").concat(w / systemZoom, \",top=\").concat(top, \",left=\").concat(left);\n  return features;\n}\n\nvar handleStream = function handleStream(handle, eventName, handler) {\n  var handlerWrapper = function handlerWrapper(chunk) {\n    handler(chunk);\n    handle.removeListener(eventName, handlerWrapper);\n  };\n  handle.on(eventName, handlerWrapper);\n};\nvar Modal = /*#__PURE__*/function () {\n  function Modal(modalUrl) {\n    _classCallCheck(this, Modal);\n    _defineProperty(this, \"modalUrl\", void 0);\n    _defineProperty(this, \"iframeElem\", void 0);\n    _defineProperty(this, \"initialized\", false);\n    _defineProperty(this, \"modalZIndex\", 99999);\n    _defineProperty(this, \"mux\", void 0);\n    _defineProperty(this, \"verifierStream\", void 0);\n    this.modalUrl = modalUrl;\n  }\n  _createClass(Modal, [{\n    key: \"init\",\n    value: function () {\n      var _init = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.initIFrame(this.modalUrl);\n              case 2:\n                this.setupStream();\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function init() {\n        return _init.apply(this, arguments);\n      }\n      return init;\n    }()\n  }, {\n    key: \"setupStream\",\n    value: function setupStream() {\n      if (this.iframeElem === null) throw new Error(\"iframe is null\");\n      this.mux = setupMultiplex(new PostMessageStream({\n        name: \"modal_iframe_rpc\",\n        target: \"modal_rpc\",\n        targetWindow: this.iframeElem.contentWindow,\n        targetOrigin: new URL(this.modalUrl).origin\n      }));\n      this.verifierStream = this.mux.createStream(\"verifier\");\n    }\n  }, {\n    key: \"initIFrame\",\n    value: function () {\n      var _initIFrame = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(src) {\n        var _this = this;\n        var documentIFrameElem;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return documentReady();\n              case 2:\n                documentIFrameElem = document.getElementById(modalDOMElementID);\n                if (documentIFrameElem) {\n                  documentIFrameElem.remove();\n                  log.info(\"already initialized, removing previous modal iframe\");\n                }\n                this.iframeElem = htmlToElement(\"<iframe\\n        id=\".concat(modalDOMElementID, \"\\n        class=\\\"torusIframe\\\"\\n        src=\\\"\").concat(src, \"\\\"\\n        style=\\\"display: none; position: fixed; top: 0; right: 0; width: 100%;\\n        height: 100%; border: none; border-radius: 0; z-index: \").concat(this.modalZIndex.toString(), \"\\\"\\n      ></iframe>\"));\n                this._hideModal();\n                document.body.appendChild(this.iframeElem);\n                return _context2.abrupt(\"return\", new Promise(function (resolve) {\n                  _this.iframeElem.onload = function () {\n                    _this.initialized = true;\n                    resolve();\n                  };\n                }));\n              case 8:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n      function initIFrame(_x) {\n        return _initIFrame.apply(this, arguments);\n      }\n      return initIFrame;\n    }()\n  }, {\n    key: \"_showModal\",\n    value: function _showModal() {\n      var style = {};\n      style.display = \"block\";\n      style.position = \"fixed\";\n      style.width = \"100%\";\n      style.height = \"100%\";\n      style.top = \"0px\";\n      style.right = \"0px\";\n      style.left = \"0px\";\n      style.bottom = \"0px\";\n      style.border = \"0\";\n      style[\"z-index\"] = this.modalZIndex;\n      this.iframeElem.setAttribute(\"style\", Object.entries(style).map(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n          k = _ref2[0],\n          v = _ref2[1];\n        return \"\".concat(k, \":\").concat(v);\n      }).join(\";\"));\n    }\n  }, {\n    key: \"_hideModal\",\n    value: function _hideModal() {\n      var style = {};\n      style.display = \"none\";\n      style.position = \"fixed\";\n      style.width = \"100%\";\n      style.height = \"100%\";\n      style.top = \"0px\";\n      style.right = \"0px\";\n      style.left = \"0px\";\n      style.bottom = \"0px\";\n      style.border = \"0\";\n      style[\"z-index\"] = this.modalZIndex;\n      this.iframeElem.setAttribute(\"style\", Object.entries(style).map(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n          k = _ref4[0],\n          v = _ref4[1];\n        return \"\".concat(k, \":\").concat(v);\n      }).join(\";\"));\n    }\n  }, {\n    key: \"_prompt\",\n    value: function () {\n      var _prompt2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(clientId, whiteLabel, loginConfig, cb) {\n        var _this2 = this;\n        var modalHandler;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                this._showModal();\n                modalHandler = function modalHandler(chunk) {\n                  _this2._hideModal();\n                  cb(chunk);\n                };\n                handleStream(this.verifierStream, \"data\", modalHandler);\n                this.verifierStream.write({\n                  name: \"prompt\",\n                  clientId: clientId,\n                  whiteLabel: whiteLabel,\n                  loginConfig: loginConfig\n                });\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n      function _prompt(_x2, _x3, _x4, _x5) {\n        return _prompt2.apply(this, arguments);\n      }\n      return _prompt;\n    }()\n  }, {\n    key: \"cleanup\",\n    value: function () {\n      var _cleanup = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var documentIFrameElem;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return documentReady();\n              case 2:\n                documentIFrameElem = document.getElementById(modalDOMElementID);\n                if (documentIFrameElem) {\n                  documentIFrameElem.remove();\n                  this.iframeElem = null;\n                }\n                this.initialized = false;\n              case 5:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n      function cleanup() {\n        return _cleanup.apply(this, arguments);\n      }\n      return cleanup;\n    }()\n  }]);\n  return Modal;\n}();\n\nvar MemoryStore = /*#__PURE__*/function () {\n  function MemoryStore() {\n    _classCallCheck(this, MemoryStore);\n    _defineProperty(this, \"store\", {});\n  }\n  _createClass(MemoryStore, [{\n    key: \"getItem\",\n    value: function getItem(key) {\n      return this.store[key] || null;\n    }\n  }, {\n    key: \"setItem\",\n    value: function setItem(key, value) {\n      this.store[key] = value;\n    }\n  }]);\n  return MemoryStore;\n}();\n\nvar OpenLoginStore = /*#__PURE__*/function () {\n  // eslint-disable-next-line no-use-before-define\n\n  function OpenLoginStore(storage, _storeKey) {\n    _classCallCheck(this, OpenLoginStore);\n    _defineProperty(this, \"_storeKey\", storeKey);\n    _defineProperty(this, \"storage\", void 0);\n    this.storage = storage;\n    this._storeKey = _storeKey || storeKey;\n    try {\n      if (!storage.getItem(_storeKey || storeKey)) {\n        this.resetStore();\n      }\n    } catch (error) {\n      // Storage is not available\n    }\n  }\n  _createClass(OpenLoginStore, [{\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this.storage.getItem(this._storeKey);\n    }\n  }, {\n    key: \"resetStore\",\n    value: function resetStore() {\n      var currStore = this.getStore();\n      this.storage.setItem(this._storeKey, JSON.stringify({}));\n      return currStore;\n    }\n  }, {\n    key: \"getStore\",\n    value: function getStore() {\n      return JSON.parse(this.storage.getItem(this._storeKey));\n    }\n  }, {\n    key: \"get\",\n    value: function get(key) {\n      var store = JSON.parse(this.storage.getItem(this._storeKey));\n      return store[key];\n    }\n  }, {\n    key: \"set\",\n    value: function set(key, value) {\n      var store = JSON.parse(this.storage.getItem(this._storeKey));\n      store[key] = value;\n      this.storage.setItem(this._storeKey, JSON.stringify(store));\n    }\n  }], [{\n    key: \"getInstance\",\n    value: function getInstance(storeNamespace) {\n      var storageKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"local\";\n      if (!this.instance) {\n        var storage = new MemoryStore();\n        if (storageKey === \"local\" && localStorageAvailable) {\n          storage = localStorage;\n        }\n        if (storageKey === \"session\" && sessionStorageAvailable) {\n          storage = sessionStorage;\n        }\n        var finalStoreKey = storeNamespace ? \"\".concat(storeKey, \"_\").concat(storeNamespace) : storeKey;\n        this.instance = new this(storage, finalStoreKey);\n      }\n      return this.instance;\n    }\n  }]);\n  return OpenLoginStore;\n}();\n_defineProperty(OpenLoginStore, \"instance\", void 0);\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nvar Provider = /*#__PURE__*/function (_SafeEventEmitter) {\n  _inherits(Provider, _SafeEventEmitter);\n  var _super = _createSuper(Provider);\n  function Provider() {\n    var _this;\n    _classCallCheck(this, Provider);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _super.call.apply(_super, [this].concat(args));\n    _defineProperty(_assertThisInitialized(_this), \"iframeElem\", null);\n    _defineProperty(_assertThisInitialized(_this), \"rpcStream\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"iframeUrl\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"rpcEngine\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"initialized\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"mux\", void 0);\n    return _this;\n  }\n  _createClass(Provider, [{\n    key: \"init\",\n    value: function init(_ref) {\n      var iframeElem = _ref.iframeElem,\n        iframeUrl = _ref.iframeUrl;\n      this.iframeElem = iframeElem;\n      this.iframeUrl = iframeUrl;\n      this.setupStream();\n      this.initialized = true;\n    }\n  }, {\n    key: \"setupStream\",\n    value: function setupStream() {\n      if (this.iframeElem === null) throw new Error(\"iframe is null\");\n      this.rpcStream = new PostMessageStream({\n        name: \"embed_rpc\",\n        target: \"iframe_rpc\",\n        targetWindow: this.iframeElem.contentWindow,\n        targetOrigin: new URL(this.iframeUrl).origin\n      });\n      this.mux = setupMultiplex(this.rpcStream);\n      var JRPCConnection = createStreamMiddleware();\n      pump(JRPCConnection.stream, this.mux.createStream(\"jrpc\"), JRPCConnection.stream, function (error) {\n        log.error(\"JRPC connection broken\", error);\n      });\n      var rpcEngine = new JRPCEngine();\n      rpcEngine.push(createIdRemapMiddleware());\n      rpcEngine.push(JRPCConnection.middleware);\n      this.rpcEngine = rpcEngine;\n    }\n  }, {\n    key: \"cleanup\",\n    value: function cleanup() {\n      this.iframeElem = null;\n      this.initialized = false;\n    }\n  }, {\n    key: \"_rpcRequest\",\n    value: function _rpcRequest(payload, callback) {\n      if (!payload.jsonrpc) {\n        payload.jsonrpc = \"2.0\";\n      }\n      if (!payload.id) {\n        payload.id = randomId();\n      }\n      this.rpcEngine.handle(payload, callback);\n    }\n  }]);\n  return Provider;\n}(SafeEventEmitter);\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\npreloadIframe(\"https://app.openlogin.com/sdk-modal\");\nvar OpenLogin = /*#__PURE__*/function () {\n  function OpenLogin(options) {\n    var _options$no3PC, _options$_startUrl, _options$_popupUrl, _options$redirectUrl, _options$uxMode, _options$replaceUrlOn, _options$originData, _options$whiteLabel, _options$loginConfig, _options$_storageServ, _options$_sessionName;\n    _classCallCheck(this, OpenLogin);\n    _defineProperty(this, \"provider\", void 0);\n    _defineProperty(this, \"state\", void 0);\n    _defineProperty(this, \"modal\", void 0);\n    this.provider = new Proxy(new Provider(), {\n      deleteProperty: function deleteProperty() {\n        return true;\n      } // work around for web3\n    });\n\n    if (!options._iframeUrl) {\n      if (options.network === OPENLOGIN_NETWORK.MAINNET) {\n        options._iframeUrl = \"https://app.openlogin.com\";\n      } else if (options.network === OPENLOGIN_NETWORK.CYAN) {\n        options._iframeUrl = \"https://cyan.openlogin.com\";\n      } else if (options.network === OPENLOGIN_NETWORK.TESTNET) {\n        options._iframeUrl = \"https://beta.openlogin.com\";\n      } else if (options.network === OPENLOGIN_NETWORK.SK_TESTNET) {\n        options._iframeUrl = \"https://beta-sk.openlogin.com\";\n      } else if (options.network === OPENLOGIN_NETWORK.DEVELOPMENT) {\n        options._iframeUrl = \"http://localhost:3000\";\n      }\n    }\n    if (!options._iframeUrl) {\n      throw new Error(\"unspecified network and iframeUrl\");\n    }\n    this.modal = new Modal(\"\".concat(options._iframeUrl, \"/sdk-modal\"));\n    this.initState(_objectSpread(_objectSpread({}, options), {}, {\n      no3PC: (_options$no3PC = options.no3PC) !== null && _options$no3PC !== void 0 ? _options$no3PC : false,\n      _iframeUrl: options._iframeUrl,\n      _startUrl: (_options$_startUrl = options._startUrl) !== null && _options$_startUrl !== void 0 ? _options$_startUrl : \"\".concat(options._iframeUrl, \"/start\"),\n      _popupUrl: (_options$_popupUrl = options._popupUrl) !== null && _options$_popupUrl !== void 0 ? _options$_popupUrl : \"\".concat(options._iframeUrl, \"/popup-window\"),\n      redirectUrl: (_options$redirectUrl = options.redirectUrl) !== null && _options$redirectUrl !== void 0 ? _options$redirectUrl : \"\".concat(window.location.protocol, \"//\").concat(window.location.host).concat(window.location.pathname),\n      uxMode: (_options$uxMode = options.uxMode) !== null && _options$uxMode !== void 0 ? _options$uxMode : UX_MODE.REDIRECT,\n      replaceUrlOnRedirect: (_options$replaceUrlOn = options.replaceUrlOnRedirect) !== null && _options$replaceUrlOn !== void 0 ? _options$replaceUrlOn : true,\n      originData: (_options$originData = options.originData) !== null && _options$originData !== void 0 ? _options$originData : _defineProperty({}, window.location.origin, \"\"),\n      whiteLabel: (_options$whiteLabel = options.whiteLabel) !== null && _options$whiteLabel !== void 0 ? _options$whiteLabel : {},\n      loginConfig: (_options$loginConfig = options.loginConfig) !== null && _options$loginConfig !== void 0 ? _options$loginConfig : {},\n      _storageServerUrl: (_options$_storageServ = options._storageServerUrl) !== null && _options$_storageServ !== void 0 ? _options$_storageServ : \"https://broadcast-server.tor.us\",\n      storageKey: options.storageKey === \"session\" ? \"session\" : \"local\",\n      _sessionNamespace: (_options$_sessionName = options._sessionNamespace) !== null && _options$_sessionName !== void 0 ? _options$_sessionName : \"\"\n    }));\n  }\n  _createClass(OpenLogin, [{\n    key: \"privKey\",\n    get: function get() {\n      return this.state.privKey ? this.state.privKey.padStart(64, \"0\") : \"\";\n    }\n  }, {\n    key: \"initState\",\n    value: function initState(options) {\n      this.state = {\n        uxMode: options.uxMode,\n        network: options.network,\n        store: OpenLoginStore.getInstance(options._sessionNamespace, options.storageKey),\n        iframeUrl: options._iframeUrl,\n        startUrl: options._startUrl,\n        popupUrl: options._popupUrl,\n        clientId: options.clientId,\n        redirectUrl: options.redirectUrl,\n        replaceUrlOnRedirect: options.replaceUrlOnRedirect,\n        originData: options.originData,\n        loginConfig: options.loginConfig,\n        support3PC: !options.no3PC,\n        whiteLabel: options.whiteLabel,\n        storageServerUrl: options._storageServerUrl,\n        sessionNamespace: options._sessionNamespace\n      };\n    }\n  }, {\n    key: \"init\",\n    value: function () {\n      var _init = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var params, res;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (this.state.network === OPENLOGIN_NETWORK.TESTNET) {\n                  // using console log because it shouldn't be affected by loglevel config\n                  // eslint-disable-next-line no-console\n                  console.log(\"%c WARNING! You are on testnet. Please set network: 'mainnet' in production\", \"color: #FF0000\");\n                }\n                _context.next = 3;\n                return Promise.all([this.modal.init(), this.updateOriginData()]);\n              case 3:\n                this.provider.init({\n                  iframeElem: this.modal.iframeElem,\n                  iframeUrl: this.state.iframeUrl\n                });\n                params = getHashQueryParams(this.state.replaceUrlOnRedirect);\n                if (params.sessionId) {\n                  this.state.store.set(\"sessionId\", params.sessionId);\n                }\n                _context.t0 = this;\n                _context.next = 9;\n                return this._getData();\n              case 9:\n                _context.t1 = _context.sent;\n                _context.t0._syncState.call(_context.t0, _context.t1);\n                if (!this.state.support3PC) {\n                  _context.next = 16;\n                  break;\n                }\n                _context.next = 14;\n                return this._check3PCSupport();\n              case 14:\n                res = _context.sent;\n                this.state.support3PC = !!res.support3PC;\n              case 16:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function init() {\n        return _init.apply(this, arguments);\n      }\n      return init;\n    }()\n  }, {\n    key: \"updateOriginData\",\n    value: function () {\n      var _updateOriginData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var filteredOriginData, _yield$Promise$all, _yield$Promise$all2, whitelist, whiteLabel;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                filteredOriginData = JSON.parse(JSON.stringify(this.state.originData));\n                Object.keys(filteredOriginData).forEach(function (key) {\n                  if (filteredOriginData[key] === \"\") delete filteredOriginData[key];\n                });\n                _context2.next = 4;\n                return Promise.all([this.getWhitelist(), this.getWhiteLabel()]);\n              case 4:\n                _yield$Promise$all = _context2.sent;\n                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);\n                whitelist = _yield$Promise$all2[0];\n                whiteLabel = _yield$Promise$all2[1];\n                this._syncState({\n                  originData: _objectSpread(_objectSpread({}, whitelist), filteredOriginData),\n                  whiteLabel: _objectSpread(_objectSpread({}, whiteLabel), this.state.whiteLabel)\n                });\n              case 9:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n      function updateOriginData() {\n        return _updateOriginData.apply(this, arguments);\n      }\n      return updateOriginData;\n    }()\n  }, {\n    key: \"getWhitelist\",\n    value: function () {\n      var _getWhitelist = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var clientId, url, res;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.prev = 0;\n                clientId = this.state.clientId;\n                if (clientId) {\n                  _context3.next = 4;\n                  break;\n                }\n                throw new Error(\"unspecified clientId\");\n              case 4:\n                url = new URL(\"https://api.developer.tor.us/whitelist\");\n                url.searchParams.append(\"project_id\", this.state.clientId);\n                url.searchParams.append(\"network\", this.state.network);\n                _context3.next = 9;\n                return get(url.href);\n              case 9:\n                res = _context3.sent;\n                return _context3.abrupt(\"return\", res.signed_urls);\n              case 13:\n                _context3.prev = 13;\n                _context3.t0 = _context3[\"catch\"](0);\n                return _context3.abrupt(\"return\", {});\n              case 16:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[0, 13]]);\n      }));\n      function getWhitelist() {\n        return _getWhitelist.apply(this, arguments);\n      }\n      return getWhitelist;\n    }()\n  }, {\n    key: \"getWhiteLabel\",\n    value: function () {\n      var _getWhiteLabel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var clientId, url, res;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.prev = 0;\n                clientId = this.state.clientId;\n                if (clientId) {\n                  _context4.next = 4;\n                  break;\n                }\n                throw new Error(\"unspecified clientId\");\n              case 4:\n                url = new URL(\"https://api.developer.tor.us/whitelabel\");\n                url.searchParams.append(\"project_id\", this.state.clientId);\n                _context4.next = 8;\n                return get(url.href);\n              case 8:\n                res = _context4.sent;\n                return _context4.abrupt(\"return\", res.whiteLabel);\n              case 12:\n                _context4.prev = 12;\n                _context4.t0 = _context4[\"catch\"](0);\n                return _context4.abrupt(\"return\", {});\n              case 15:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[0, 12]]);\n      }));\n      function getWhiteLabel() {\n        return _getWhiteLabel.apply(this, arguments);\n      }\n      return getWhiteLabel;\n    }()\n  }, {\n    key: \"login\",\n    value: function () {\n      var _login = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(params) {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (!(params !== null && params !== void 0 && params.loginProvider)) {\n                  _context5.next = 2;\n                  break;\n                }\n                return _context5.abrupt(\"return\", this._selectedLogin(params));\n              case 2:\n                return _context5.abrupt(\"return\", this._modal(params));\n              case 3:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n      function login(_x) {\n        return _login.apply(this, arguments);\n      }\n      return login;\n    }()\n  }, {\n    key: \"_selectedLogin\",\n    value: function () {\n      var _selectedLogin2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(params) {\n        var defaultParams, loginParams, res;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                defaultParams = {\n                  redirectUrl: this.state.redirectUrl\n                };\n                loginParams = _objectSpread(_objectSpread({\n                  loginProvider: params.loginProvider\n                }, defaultParams), params);\n                _context6.next = 4;\n                return this.request({\n                  method: OPENLOGIN_METHOD.LOGIN,\n                  allowedInteractions: [UX_MODE.REDIRECT, UX_MODE.POPUP],\n                  startUrl: this.state.startUrl,\n                  popupUrl: this.state.popupUrl,\n                  params: [loginParams]\n                });\n              case 4:\n                res = _context6.sent;\n                this.state.privKey = res.privKey;\n                if (!res.store) {\n                  _context6.next = 10;\n                  break;\n                }\n                this._syncState(res);\n                _context6.next = 16;\n                break;\n              case 10:\n                if (!(this.state.privKey && this.state.support3PC)) {\n                  _context6.next = 16;\n                  break;\n                }\n                _context6.t0 = this;\n                _context6.next = 14;\n                return this._getData();\n              case 14:\n                _context6.t1 = _context6.sent;\n                _context6.t0._syncState.call(_context6.t0, _context6.t1);\n              case 16:\n                return _context6.abrupt(\"return\", {\n                  privKey: this.privKey\n                });\n              case 17:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n      function _selectedLogin(_x2) {\n        return _selectedLogin2.apply(this, arguments);\n      }\n      return _selectedLogin;\n    }()\n  }, {\n    key: \"logout\",\n    value: function () {\n      var _logout = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n        var logoutParams,\n          params,\n          res,\n          _args7 = arguments;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                logoutParams = _args7.length > 0 && _args7[0] !== undefined ? _args7[0] : {};\n                params = {}; // defaults\n                params.redirectUrl = this.state.redirectUrl;\n                params._clientId = this.state.clientId;\n                params.sessionId = this.state.store.get(\"sessionId\");\n                if (logoutParams.clientId) {\n                  params._clientId = logoutParams.clientId;\n                }\n                if (logoutParams.redirectUrl !== undefined) {\n                  params.redirectUrl = logoutParams.redirectUrl;\n                }\n                _context7.next = 9;\n                return this.request({\n                  method: OPENLOGIN_METHOD.LOGOUT,\n                  params: [params],\n                  startUrl: this.state.startUrl,\n                  popupUrl: this.state.popupUrl,\n                  allowedInteractions: [ALLOWED_INTERACTIONS.JRPC]\n                });\n              case 9:\n                res = _context7.sent;\n                this.state.privKey = \"\";\n                return _context7.abrupt(\"return\", res);\n              case 12:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n      function logout() {\n        return _logout.apply(this, arguments);\n      }\n      return logout;\n    }()\n  }, {\n    key: \"request\",\n    value: function () {\n      var _request = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(args) {\n        var _params$0$redirectUrl;\n        var pid, params, session, startUrl, popupUrl, method, allowedInteractions, userData, sig, sessionId, u, windowRef, _u, _windowRef;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                pid = randomId();\n                params = args.params; // Note: _origin is added later in postMessageStream for jrpc requests\n                // do not add it here since its used for checking postMessage constraints\n                session = {};\n                if (!(params.length !== 1)) {\n                  _context8.next = 5;\n                  break;\n                }\n                throw new Error(\"request params array should have only one element\");\n              case 5:\n                startUrl = args.startUrl, popupUrl = args.popupUrl, method = args.method, allowedInteractions = args.allowedInteractions;\n                if (!(allowedInteractions.length === 0)) {\n                  _context8.next = 8;\n                  break;\n                }\n                throw new Error(\"no allowed interactions\");\n              case 8:\n                if (this.state.clientId) {\n                  session._clientId = this.state.clientId;\n                }\n                if (this.state.sessionNamespace) {\n                  session._sessionNamespace = this.state.sessionNamespace;\n                }\n                if (!this.privKey) {\n                  _context8.next = 18;\n                  break;\n                }\n                userData = {\n                  clientId: session._clientId,\n                  timestamp: Date.now().toString()\n                };\n                _context8.next = 14;\n                return sign(Buffer.from(this.privKey, \"hex\"), Buffer.from(keccak(\"keccak256\").update(JSON.stringify(userData)).digest(\"hex\"), \"hex\"));\n              case 14:\n                sig = _context8.sent;\n                session._user = getPublic(Buffer.from(this.privKey, \"hex\")).toString(\"hex\");\n                session._userSig = base64url.encode(sig);\n                session._userData = userData;\n              case 18:\n                session._originData = this.state.originData;\n                session._whiteLabelData = this.state.whiteLabel;\n                session._loginConfig = this.state.loginConfig;\n                session._sessionId = this.state.store.get(\"sessionId\");\n                if (!session._sessionId) {\n                  sessionId = randomId();\n                  session._sessionId = sessionId;\n                  this.state.store.set(\"sessionId\", sessionId);\n                }\n                // add in session data (allow overrides)\n                params = [_objectSpread(_objectSpread({}, session), params[0])];\n                // use JRPC where possible\n                if (!allowedInteractions.includes(ALLOWED_INTERACTIONS.JRPC)) {\n                  _context8.next = 26;\n                  break;\n                }\n                return _context8.abrupt(\"return\", this._jrpcRequest({\n                  method: method,\n                  params: params\n                }));\n              case 26:\n                // set origin\n                params[0]._origin = new URL((_params$0$redirectUrl = params[0].redirectUrl) !== null && _params$0$redirectUrl !== void 0 ? _params$0$redirectUrl : this.state.redirectUrl).origin;\n                // preset params\n                if (!this.state.support3PC) {\n                  _context8.next = 31;\n                  break;\n                }\n                _context8.next = 30;\n                return this._setPIDData(pid, params);\n              case 30:\n                // eslint-disable-next-line require-atomic-updates\n                params = [{}];\n              case 31:\n                if (!(!startUrl || !popupUrl)) {\n                  _context8.next = 33;\n                  break;\n                }\n                throw new Error(\"no url for redirect / popup flow\");\n              case 33:\n                if (!(this.state.uxMode === UX_MODE.REDIRECT)) {\n                  _context8.next = 43;\n                  break;\n                }\n                if (!allowedInteractions.includes(ALLOWED_INTERACTIONS.REDIRECT)) {\n                  _context8.next = 37;\n                  break;\n                }\n                // give time for synchronous methods to complete before redirect\n                setTimeout(function () {\n                  window.location.href = constructURL({\n                    baseURL: startUrl,\n                    hash: {\n                      b64Params: jsonToBase64(params[0]),\n                      _pid: pid,\n                      _method: method\n                    }\n                  });\n                }, 50);\n                return _context8.abrupt(\"return\", {});\n              case 37:\n                if (!allowedInteractions.includes(ALLOWED_INTERACTIONS.POPUP)) {\n                  _context8.next = 41;\n                  break;\n                }\n                u = new URL(constructURL({\n                  baseURL: popupUrl,\n                  hash: {\n                    b64Params: jsonToBase64(params[0]),\n                    _pid: pid,\n                    _method: method\n                  }\n                }));\n                windowRef = window.open(u.toString(), \"_blank\", getPopupFeatures());\n                return _context8.abrupt(\"return\", awaitReq(pid, windowRef));\n              case 41:\n                _context8.next = 50;\n                break;\n              case 43:\n                if (!allowedInteractions.includes(ALLOWED_INTERACTIONS.POPUP)) {\n                  _context8.next = 47;\n                  break;\n                }\n                _u = new URL(constructURL({\n                  baseURL: popupUrl,\n                  hash: {\n                    b64Params: jsonToBase64(params[0]),\n                    _pid: pid,\n                    _method: method\n                  }\n                }));\n                _windowRef = window.open(_u.toString(), \"_blank\", getPopupFeatures());\n                return _context8.abrupt(\"return\", awaitReq(pid, _windowRef));\n              case 47:\n                if (!allowedInteractions.includes(ALLOWED_INTERACTIONS.REDIRECT)) {\n                  _context8.next = 50;\n                  break;\n                }\n                // give time for synchronous methods to complete before redirect\n                setTimeout(function () {\n                  window.location.href = constructURL({\n                    baseURL: startUrl,\n                    hash: {\n                      b64Params: jsonToBase64(params[0]),\n                      _pid: pid,\n                      _method: method\n                    }\n                  });\n                }, 50);\n                return _context8.abrupt(\"return\", null);\n              case 50:\n                throw new Error(\"no matching allowed interactions\");\n              case 51:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n      function request(_x3) {\n        return _request.apply(this, arguments);\n      }\n      return request;\n    }()\n  }, {\n    key: \"_jrpcRequest\",\n    value: function () {\n      var _jrpcRequest2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(args) {\n        var _this = this;\n        var method, params;\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                if (!(!args || _typeof(args) !== \"object\" || Array.isArray(args))) {\n                  _context9.next = 2;\n                  break;\n                }\n                throw new Error(\"invalid request args\");\n              case 2:\n                method = args.method, params = args.params;\n                if (!(typeof method !== \"string\" || method.length === 0)) {\n                  _context9.next = 5;\n                  break;\n                }\n                throw new Error(\"invalid request method\");\n              case 5:\n                if (!(params === undefined || !Array.isArray(params))) {\n                  _context9.next = 7;\n                  break;\n                }\n                throw new Error(\"invalid request params\");\n              case 7:\n                if (params.length === 0) {\n                  params.push({});\n                }\n                return _context9.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  _this.provider._rpcRequest({\n                    method: method,\n                    params: params\n                  }, getRpcPromiseCallback(resolve, reject));\n                }));\n              case 9:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9);\n      }));\n      function _jrpcRequest(_x4) {\n        return _jrpcRequest2.apply(this, arguments);\n      }\n      return _jrpcRequest;\n    }()\n  }, {\n    key: \"_check3PCSupport\",\n    value: function () {\n      var _check3PCSupport2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10() {\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                return _context10.abrupt(\"return\", this._jrpcRequest({\n                  method: OPENLOGIN_METHOD.CHECK_3PC_SUPPORT,\n                  params: [{\n                    _originData: this.state.originData\n                  }]\n                }));\n              case 1:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n      function _check3PCSupport() {\n        return _check3PCSupport2.apply(this, arguments);\n      }\n      return _check3PCSupport;\n    }()\n  }, {\n    key: \"_setPIDData\",\n    value: function () {\n      var _setPIDData2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(pid, data) {\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                _context11.next = 2;\n                return this.request({\n                  allowedInteractions: [ALLOWED_INTERACTIONS.JRPC],\n                  method: OPENLOGIN_METHOD.SET_PID_DATA,\n                  params: [{\n                    pid: pid,\n                    data: data[0]\n                  }]\n                });\n              case 2:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n      function _setPIDData(_x5, _x6) {\n        return _setPIDData2.apply(this, arguments);\n      }\n      return _setPIDData;\n    }()\n  }, {\n    key: \"_getData\",\n    value: function () {\n      var _getData2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12() {\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                return _context12.abrupt(\"return\", this.request({\n                  allowedInteractions: [ALLOWED_INTERACTIONS.JRPC],\n                  method: OPENLOGIN_METHOD.GET_DATA,\n                  params: [{}]\n                }));\n              case 1:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n      function _getData() {\n        return _getData2.apply(this, arguments);\n      }\n      return _getData;\n    }()\n  }, {\n    key: \"_syncState\",\n    value: function _syncState(newState) {\n      var _this2 = this;\n      if (newState.store) {\n        if (_typeof(newState.store) !== \"object\") {\n          throw new Error(\"expected store to be an object\");\n        }\n        Object.keys(newState.store).forEach(function (key) {\n          _this2.state.store.set(key, newState.store[key]);\n        });\n      }\n      var store = this.state.store;\n      this.state = _objectSpread(_objectSpread(_objectSpread({}, this.state), newState), {}, {\n        store: store\n      });\n    }\n  }, {\n    key: \"_modal\",\n    value: function () {\n      var _modal2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14(params) {\n        var _this3 = this;\n        return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                return _context14.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  _this3.modal._prompt(_this3.state.clientId, _this3.state.whiteLabel, _this3.state.loginConfig, /*#__PURE__*/function () {\n                    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13(chunk) {\n                      var selectedLoginResponse;\n                      return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n                        while (1) {\n                          switch (_context13.prev = _context13.next) {\n                            case 0:\n                              if (!chunk.cancel) {\n                                _context13.next = 4;\n                                break;\n                              }\n                              reject(new Error(\"user canceled login\"));\n                              _context13.next = 14;\n                              break;\n                            case 4:\n                              _context13.prev = 4;\n                              _context13.next = 7;\n                              return _this3._selectedLogin(merge(params, chunk));\n                            case 7:\n                              selectedLoginResponse = _context13.sent;\n                              resolve(selectedLoginResponse);\n                              _context13.next = 14;\n                              break;\n                            case 11:\n                              _context13.prev = 11;\n                              _context13.t0 = _context13[\"catch\"](4);\n                              reject(_context13.t0);\n                            case 14:\n                            case \"end\":\n                              return _context13.stop();\n                          }\n                        }\n                      }, _callee13, null, [[4, 11]]);\n                    }));\n                    return function (_x8) {\n                      return _ref2.apply(this, arguments);\n                    };\n                  }());\n                }));\n              case 1:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14);\n      }));\n      function _modal(_x7) {\n        return _modal2.apply(this, arguments);\n      }\n      return _modal;\n    }()\n  }, {\n    key: \"_cleanup\",\n    value: function () {\n      var _cleanup2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee15() {\n        return _regeneratorRuntime.wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                _context15.next = 2;\n                return this.modal.cleanup();\n              case 2:\n                this.provider.cleanup();\n              case 3:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n      function _cleanup() {\n        return _cleanup2.apply(this, arguments);\n      }\n      return _cleanup;\n    }()\n  }, {\n    key: \"encrypt\",\n    value: function () {\n      var _encrypt2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee16(message, privateKey) {\n        var privKey;\n        return _regeneratorRuntime.wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                privKey = privateKey;\n                if (!privKey) {\n                  privKey = this.privKey;\n                }\n                // validations\n                if (/^[0-9a-fA-f]{64}$/.exec(privKey)) {\n                  _context16.next = 8;\n                  break;\n                }\n                if (!(privKey === \"\" || privKey === undefined)) {\n                  _context16.next = 7;\n                  break;\n                }\n                throw new Error(\"private key cannot be empty\");\n              case 7:\n                throw new Error(\"invalid private key in encrypt\");\n              case 8:\n                return _context16.abrupt(\"return\", encrypt(getPublic(Buffer.from(privKey, \"hex\")), message));\n              case 9:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n      function encrypt$1(_x9, _x10) {\n        return _encrypt2.apply(this, arguments);\n      }\n      return encrypt$1;\n    }()\n  }, {\n    key: \"decrypt\",\n    value: function () {\n      var _decrypt2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee17(ciphertext, privateKey) {\n        var privKey;\n        return _regeneratorRuntime.wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                privKey = privateKey;\n                if (!privKey) {\n                  privKey = this.privKey;\n                }\n                // validations\n                if (/^[0-9a-fA-f]{64}$/.exec(privKey)) {\n                  _context17.next = 8;\n                  break;\n                }\n                if (!(privKey === \"\" || privKey === undefined)) {\n                  _context17.next = 7;\n                  break;\n                }\n                throw new Error(\"private key cannot be empty\");\n              case 7:\n                throw new Error(\"invalid private key in decrypt\");\n              case 8:\n                return _context17.abrupt(\"return\", decrypt(Buffer.from(privKey, \"hex\"), ciphertext));\n              case 9:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n      function decrypt$1(_x11, _x12) {\n        return _decrypt2.apply(this, arguments);\n      }\n      return decrypt$1;\n    }()\n  }, {\n    key: \"getUserInfo\",\n    value: function () {\n      var _getUserInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee18() {\n        var storeData, userInfo;\n        return _regeneratorRuntime.wrap(function _callee18$(_context18) {\n          while (1) {\n            switch (_context18.prev = _context18.next) {\n              case 0:\n                if (!this.privKey) {\n                  _context18.next = 4;\n                  break;\n                }\n                storeData = this.state.store.getStore();\n                userInfo = {\n                  email: storeData.email || \"\",\n                  name: storeData.name || \"\",\n                  profileImage: storeData.profileImage || \"\",\n                  aggregateVerifier: storeData.aggregateVerifier || \"\",\n                  verifier: storeData.verifier || \"\",\n                  verifierId: storeData.verifierId || \"\",\n                  typeOfLogin: storeData.typeOfLogin || \"\",\n                  dappShare: storeData.dappShare || \"\",\n                  idToken: storeData.idToken || \"\",\n                  oAuthIdToken: storeData.oAuthIdToken || \"\",\n                  oAuthAccessToken: storeData.oAuthAccessToken || \"\"\n                };\n                return _context18.abrupt(\"return\", userInfo);\n              case 4:\n                throw new Error(\"user should be logged in to fetch userInfo\");\n              case 5:\n              case \"end\":\n                return _context18.stop();\n            }\n          }\n        }, _callee18, this);\n      }));\n      function getUserInfo() {\n        return _getUserInfo.apply(this, arguments);\n      }\n      return getUserInfo;\n    }()\n  }, {\n    key: \"getEncodedLoginUrl\",\n    value: function () {\n      var _getEncodedLoginUrl = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee19(loginParams) {\n        var redirectUrl, clientId, dataObject, b64Params, hashParams;\n        return _regeneratorRuntime.wrap(function _callee19$(_context19) {\n          while (1) {\n            switch (_context19.prev = _context19.next) {\n              case 0:\n                redirectUrl = loginParams.redirectUrl;\n                clientId = this.state.clientId;\n                if (this.state.originData[origin]) {\n                  _context19.next = 5;\n                  break;\n                }\n                _context19.next = 5;\n                return this.updateOriginData();\n              case 5:\n                dataObject = _objectSpread({\n                  _clientId: clientId,\n                  _origin: new URL(redirectUrl).origin,\n                  _originData: this.state.originData,\n                  redirectUrl: redirectUrl\n                }, loginParams);\n                b64Params = jsonToBase64(dataObject);\n                hashParams = {\n                  b64Params: b64Params,\n                  _method: \"openlogin_login\"\n                };\n                return _context19.abrupt(\"return\", constructURL({\n                  baseURL: \"\".concat(this.state.iframeUrl, \"/start\"),\n                  hash: hashParams\n                }));\n              case 9:\n              case \"end\":\n                return _context19.stop();\n            }\n          }\n        }, _callee19, this);\n      }));\n      function getEncodedLoginUrl(_x13) {\n        return _getEncodedLoginUrl.apply(this, arguments);\n      }\n      return getEncodedLoginUrl;\n    }()\n  }]);\n  return OpenLogin;\n}();\n\nexport { ALLOWED_INTERACTIONS, LOGIN_PROVIDER, MFA_LEVELS, OPENLOGIN_METHOD, OPENLOGIN_NETWORK, OpenLoginStore, Provider, SUPPORTED_KEY_CURVES, UX_MODE, awaitReq, constructURL, OpenLogin as default, documentReady, getHashQueryParams, getPopupFeatures, htmlToElement, localStorageAvailable, log as loglevel, modalDOMElementID, preloadIframe, sessionStorageAvailable, storageAvailable, storeKey, whitelistUrl };\n//# sourceMappingURL=openlogin.esm.js.map\n",null,null,null,null,null,null,"import OpenLogin, { OPENLOGIN_NETWORK, UX_MODE, getHashQueryParams, SUPPORTED_KEY_CURVES } from '@toruslabs/openlogin';\nimport { getChainConfig, BaseAdapter, WALLET_ADAPTERS, ADAPTER_NAMESPACES, ADAPTER_CATEGORY, ADAPTER_STATUS, CHAIN_NAMESPACES, log, WalletInitializationError, ADAPTER_EVENTS, WalletLoginError } from '@web3auth/base';\nimport _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { CommonPrivateKeyProvider } from '@web3auth/base-provider';\nimport merge from 'lodash.merge';\n\nconst getOpenloginDefaultOptions = (chainNamespace, chainId) => {\n  return {\n    adapterSettings: {\n      network: OPENLOGIN_NETWORK.MAINNET,\n      clientId: \"\",\n      uxMode: UX_MODE.POPUP\n    },\n    chainConfig: chainNamespace ? getChainConfig(chainNamespace, chainId) : null,\n    loginSettings: {}\n  };\n};\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass OpenloginAdapter extends BaseAdapter {\n  constructor(params) {\n    var _params$chainConfig, _params$chainConfig2, _params$chainConfig3;\n\n    super();\n\n    _defineProperty(this, \"name\", WALLET_ADAPTERS.OPENLOGIN);\n\n    _defineProperty(this, \"adapterNamespace\", ADAPTER_NAMESPACES.MULTICHAIN);\n\n    _defineProperty(this, \"type\", ADAPTER_CATEGORY.IN_APP);\n\n    _defineProperty(this, \"openloginInstance\", null);\n\n    _defineProperty(this, \"status\", ADAPTER_STATUS.NOT_READY);\n\n    _defineProperty(this, \"currentChainNamespace\", CHAIN_NAMESPACES.EIP155);\n\n    _defineProperty(this, \"openloginOptions\", void 0);\n\n    _defineProperty(this, \"loginSettings\", {});\n\n    _defineProperty(this, \"privKeyProvider\", null);\n\n    log.debug(\"const openlogin adapter\", params);\n    const defaultOptions = getOpenloginDefaultOptions((_params$chainConfig = params.chainConfig) === null || _params$chainConfig === void 0 ? void 0 : _params$chainConfig.chainNamespace, (_params$chainConfig2 = params.chainConfig) === null || _params$chainConfig2 === void 0 ? void 0 : _params$chainConfig2.chainId);\n    this.openloginOptions = _objectSpread(_objectSpread({\n      clientId: \"\",\n      network: OPENLOGIN_NETWORK.MAINNET\n    }, defaultOptions.adapterSettings), params.adapterSettings || {});\n    this.loginSettings = _objectSpread(_objectSpread({}, defaultOptions.loginSettings), params.loginSettings);\n    this.sessionTime = this.loginSettings.sessionTime || 86400; // if no chainNamespace is passed then chain config should be set before calling init\n\n    if ((_params$chainConfig3 = params.chainConfig) !== null && _params$chainConfig3 !== void 0 && _params$chainConfig3.chainNamespace) {\n      var _params$chainConfig4;\n\n      this.currentChainNamespace = (_params$chainConfig4 = params.chainConfig) === null || _params$chainConfig4 === void 0 ? void 0 : _params$chainConfig4.chainNamespace;\n      const defaultChainIdConfig = defaultOptions.chainConfig ? defaultOptions.chainConfig : {};\n      this.chainConfig = _objectSpread(_objectSpread({}, defaultChainIdConfig), params === null || params === void 0 ? void 0 : params.chainConfig);\n      log.debug(\"const openlogin chainConfig\", this.chainConfig);\n\n      if (!this.chainConfig.rpcTarget && params.chainConfig.chainNamespace !== CHAIN_NAMESPACES.OTHER) {\n        throw WalletInitializationError.invalidParams(\"rpcTarget is required in chainConfig\");\n      }\n    }\n  }\n\n  get chainConfigProxy() {\n    return this.chainConfig ? _objectSpread({}, this.chainConfig) : null;\n  }\n\n  get provider() {\n    var _this$privKeyProvider;\n\n    return ((_this$privKeyProvider = this.privKeyProvider) === null || _this$privKeyProvider === void 0 ? void 0 : _this$privKeyProvider.provider) || null;\n  }\n\n  set provider(_) {\n    throw new Error(\"Not implemented\");\n  }\n\n  async init(options) {\n    var _this$openloginOption;\n\n    super.checkInitializationRequirements();\n    if (!((_this$openloginOption = this.openloginOptions) !== null && _this$openloginOption !== void 0 && _this$openloginOption.clientId)) throw WalletInitializationError.invalidParams(\"clientId is required before openlogin's initialization\");\n    if (!this.chainConfig) throw WalletInitializationError.invalidParams(\"chainConfig is required before initialization\");\n    let isRedirectResult = false;\n\n    if (this.openloginOptions.uxMode === UX_MODE.REDIRECT) {\n      const redirectResult = getHashQueryParams();\n\n      if (Object.keys(redirectResult).length > 0 && redirectResult._pid) {\n        isRedirectResult = true;\n      }\n    }\n\n    this.openloginOptions = _objectSpread(_objectSpread({}, this.openloginOptions), {}, {\n      replaceUrlOnRedirect: isRedirectResult\n    });\n    this.openloginInstance = new OpenLogin(this.openloginOptions);\n    log.debug(\"initializing openlogin adapter init\");\n    await this.openloginInstance.init();\n    this.status = ADAPTER_STATUS.READY;\n    this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.OPENLOGIN);\n\n    try {\n      log.debug(\"initializing openlogin adapter\"); // connect only if it is redirect result or if connect (adapter is cached/already connected in same session) is true\n\n      if (this.openloginInstance.privKey && (options.autoConnect || isRedirectResult)) {\n        await this.connect();\n      }\n    } catch (error) {\n      log.error(\"Failed to connect with cached openlogin provider\", error);\n      this.emit(\"ERRORED\", error);\n    }\n  }\n\n  async connect(params) {\n    super.checkConnectionRequirements();\n    this.status = ADAPTER_STATUS.CONNECTING;\n    this.emit(ADAPTER_EVENTS.CONNECTING, _objectSpread(_objectSpread({}, params), {}, {\n      adapter: WALLET_ADAPTERS.OPENLOGIN\n    }));\n\n    try {\n      await this.connectWithProvider(params);\n      return this.provider;\n    } catch (error) {\n      log.error(\"Failed to connect with openlogin provider\", error); // ready again to be connected\n\n      this.status = ADAPTER_STATUS.READY;\n      this.emit(ADAPTER_EVENTS.ERRORED, error);\n\n      if (error !== null && error !== void 0 && error.message.includes(\"user closed popup\")) {\n        throw WalletLoginError.popupClosed();\n      }\n\n      throw WalletLoginError.connectionError(\"Failed to login with openlogin\");\n    }\n  }\n\n  async disconnect() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      cleanup: false\n    };\n    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.notConnectedError(\"Not connected with wallet\");\n    if (!this.openloginInstance) throw WalletInitializationError.notReady(\"openloginInstance is not ready\");\n    await this.openloginInstance.logout();\n\n    if (options.cleanup) {\n      this.status = ADAPTER_STATUS.NOT_READY;\n      this.openloginInstance = null;\n      this.privKeyProvider = null;\n    } else {\n      // ready to be connected again\n      this.status = ADAPTER_STATUS.READY;\n    }\n\n    this.emit(ADAPTER_EVENTS.DISCONNECTED);\n  }\n\n  async authenticateUser() {\n    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.notConnectedError(\"Not connected with wallet, Please login/connect first\");\n    const userInfo = await this.getUserInfo();\n    return {\n      idToken: userInfo.idToken\n    };\n  }\n\n  async getUserInfo() {\n    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.notConnectedError(\"Not connected with wallet\");\n    if (!this.openloginInstance) throw WalletInitializationError.notReady(\"openloginInstance is not ready\");\n    const userInfo = await this.openloginInstance.getUserInfo();\n    return userInfo;\n  } // should be called only before initialization.\n\n\n  setAdapterSettings(adapterSettings) {\n    if (this.status === ADAPTER_STATUS.READY) return;\n    const defaultOptions = getOpenloginDefaultOptions();\n    this.openloginOptions = _objectSpread(_objectSpread(_objectSpread({}, defaultOptions.adapterSettings), this.openloginOptions || {}), adapterSettings);\n\n    if (adapterSettings.sessionTime) {\n      this.loginSettings = _objectSpread(_objectSpread({}, this.loginSettings), {}, {\n        sessionTime: adapterSettings.sessionTime\n      });\n    }\n  } // should be called only before initialization.\n\n\n  setChainConfig(customChainConfig) {\n    super.setChainConfig(customChainConfig);\n    this.currentChainNamespace = customChainConfig.chainNamespace;\n  }\n\n  async connectWithProvider(params) {\n    if (!this.chainConfig) throw WalletInitializationError.invalidParams(\"chainConfig is required before initialization\");\n    if (!this.openloginInstance) throw WalletInitializationError.notReady(\"openloginInstance is not ready\");\n\n    if (this.currentChainNamespace === CHAIN_NAMESPACES.SOLANA) {\n      const {\n        SolanaPrivateKeyProvider\n      } = await import('@web3auth/solana-provider');\n      this.privKeyProvider = new SolanaPrivateKeyProvider({\n        config: {\n          chainConfig: this.chainConfig\n        }\n      });\n    } else if (this.currentChainNamespace === CHAIN_NAMESPACES.EIP155) {\n      const {\n        EthereumPrivateKeyProvider\n      } = await import('@web3auth/ethereum-provider');\n      this.privKeyProvider = new EthereumPrivateKeyProvider({\n        config: {\n          chainConfig: this.chainConfig\n        }\n      });\n    } else if (this.currentChainNamespace === CHAIN_NAMESPACES.OTHER) {\n      this.privKeyProvider = new CommonPrivateKeyProvider();\n    } else {\n      throw new Error(\"Invalid chainNamespace: \".concat(this.currentChainNamespace, \" found while connecting to wallet\"));\n    } // if not logged in then login\n\n\n    if (!this.openloginInstance.privKey && params) {\n      var _params$extraLoginOpt;\n\n      if (!this.loginSettings.curve) {\n        this.loginSettings.curve = this.currentChainNamespace === CHAIN_NAMESPACES.SOLANA ? SUPPORTED_KEY_CURVES.ED25519 : SUPPORTED_KEY_CURVES.SECP256K1;\n      }\n\n      await this.openloginInstance.login(merge(this.loginSettings, {\n        loginProvider: params.loginProvider\n      }, {\n        extraLoginOptions: _objectSpread(_objectSpread({}, params.extraLoginOptions || {}), {}, {\n          login_hint: params.login_hint || ((_params$extraLoginOpt = params.extraLoginOptions) === null || _params$extraLoginOpt === void 0 ? void 0 : _params$extraLoginOpt.login_hint)\n        })\n      }));\n    }\n\n    let finalPrivKey = this.openloginInstance.privKey;\n\n    if (finalPrivKey) {\n      if (this.currentChainNamespace === CHAIN_NAMESPACES.SOLANA) {\n        const {\n          getED25519Key\n        } = await import('@toruslabs/openlogin-ed25519');\n        finalPrivKey = getED25519Key(finalPrivKey).sk.toString(\"hex\");\n      }\n\n      await this.privKeyProvider.setupProvider(finalPrivKey);\n      this.status = ADAPTER_STATUS.CONNECTED;\n      this.emit(ADAPTER_EVENTS.CONNECTED, {\n        adapter: WALLET_ADAPTERS.OPENLOGIN,\n        reconnected: !params\n      });\n    }\n  }\n\n}\n\nexport { OpenloginAdapter, getOpenloginDefaultOptions };\n//# sourceMappingURL=openloginAdapter.esm.js.map\n",null],"sourceRoot":""}