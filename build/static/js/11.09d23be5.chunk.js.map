{"version":3,"sources":["../../src/baseEvmAdapter.ts","../../src/basePostMessageStream.ts","../../src/safeEventEmitter.ts","../../src/serializableError.ts","../../src/jrpc.ts","../../src/jrpcEngine.ts","../../src/substream.ts","../../src/mux.ts","../../src/BaseController.ts","../../src/createEventEmitterProxy.ts","../../src/Network/INetworkController.ts","../../src/enums.ts","../../src/Embed/CommunicationWindowManager.ts","../../src/utils/utils.ts","../../src/Network/createFetchMiddleware.ts","../../src/Preferences/BasePreferencesController.ts","../../src/Transaction/ITransactionController.ts","../node_modules/@web3auth/wallet-connect-v1-adapter/node_modules/loglevel/lib/loglevel.js","../../src/index.ts","../../../src/index.ts","../../../src/network.ts","../../src/rpc/walletMidddleware.ts","../../src/rpc/ethRpcMiddlewares.ts","../../src/rpc/jrpcClient.ts","../../src/providers/injectedProviders/walletConnectUtils.ts","../../src/providers/injectedProviders/WalletConnectProvider.ts","../../src/providers/converter.ts","../../src/providers/privateKeyProviders/TransactionFormatter/utils.ts","../../src/providers/privateKeyProviders/ethPrivatekeyUtils.ts","../../src/providers/utils.ts","../../src/providers/privateKeyProviders/TransactionFormatter/constants.ts","../../src/providers/privateKeyProviders/TransactionFormatter/index.ts","../../src/providers/privateKeyProviders/EthereumPrivateKeyProvider.ts","../../src/baseProvider.ts","../../src/commonPrivateKeyProvider.ts","../../src/utils.ts","../../../src/errors.ts","../../../src/events.ts","../../../src/storage.ts","../../../src/url.ts","../../src/config.ts","../../src/walletConnectV1adapter.ts"],"names":["BaseEvmAdapter","authenticateUser","provider","chainConfig","chainId","WalletLoginError","notConnectedError","chainNamespace","status","ADAPTER_STATUS","CONNECTED","request","method","accounts","length","existingToken","getSavedToken","name","checkIfTokenIsExpired","idToken","payload","domain","window","location","origin","uri","href","address","parseInt","version","nonce","Math","random","toString","slice","issuedAt","Date","toISOString","signChallenge","challenge","params","signedMessage","verifySignedChallenge","sessionTime","saveToken","disconnect","disconnectionError","clearToken","BaseAdapter","noop","ACK","Duplex","safeApply","handler","context","args","Reflect","apply","err","setTimeout","arrayClone","arr","n","copy","Array","i","SafeEventEmitter","type","doError","events","_events","undefined","error","er","Error","message","len","listeners","EventEmitter","SerializableError","code","data","Number","isInteger","stringify","stack","createScaffoldMiddleware","handlers","req","res","next","end","result","createAsyncMiddleware","asyncMiddleware","nextPromise","Promise","resolve","resolveNextPromise","returnHandlerCallback","nextWasCalled","asyncNext","runReturnHandlersCallback","JRPCEngine","_middleware","middleware","push","cb","isArray","_handleBatch","_handle","_promiseHandle","_runAllMiddleware","middlewareError","isComplete","returnHandlers","_runReturnHandlers","handlerCallback","reqs","all","map","bind","responses","_err","callerReq","id","jsonrpc","_processRequest","serializeError","_checkForCompletion","middlewareStack","_runMiddleware","reverse","returnHandler","reject","mergeMiddleware","engine","forEach","asMiddleware","Substream","parent","objectMode","_parent","_name","chunk","_encoding","callback","IGNORE_SUBSTREAM","Symbol","BaseController","constructor","config","state","defaultConfig","defaultState","initialState","initialConfig","internalConfig","internalState","configure","overwrite","fullUpdate","key","Object","assign","update","emit","initialize","filterNoop","internalEvents","externalEventFilter","includes","createEventEmitterProxy","initialTarget","opts","eventFilter","target","setTarget","newTarget","oldTarget","eventNames","filter","eventEmitter","rawListeners","getRawListeners","on","removeAllListeners","Proxy","get","_","set","value","createRandomId","getCreateRandomId","providerFromEngine","sendAsync","handle","fallbackError","ethErrors","rpc","internal","send","COMMUNICATION_JRPC_METHODS","hexString","targetLength","test","String","prototype","padStart","call","getHeaders","signMessage","privateKey","privKey","Buffer","from","stripHexPrefix","msgSig","ecsign","v","r","s","rSig","fromSigned","sSig","vSig","bufferToInt","rStr","padWithZeroes","toUnsigned","sStr","vStr","hex","intToHex","addHexPrefix","concat","concatSig","intToBuffer","RETRIABLE_ERRORS","checkForHttpErrors","fetchRes","methodNotFound","timeout","duration","parseResponse","body","createFetchConfigFromReq","rpcTarget","originHttpHeaderKey","parsedUrl","URL","originDomain","fetchParams","headers","Accept","JSON","fetchUrl","createFetchMiddleware","_next","maxAttempts","retryInterval","attempt","fetch","json","fetchBody","errMsg","some","phrase","TransactionStatus","root","definition","define","undefinedType","isIE","navigator","userAgent","logMethods","bindMethod","obj","methodName","Function","e","arguments","traceForIE","console","log","trace","realMethod","replaceLoggingMethods","level","loggerName","this","methodFactory","debug","enableLoggingWhenConsoleArrives","defaultMethodFactory","Logger","defaultLevel","factory","currentLevel","self","storageKey","persistLevelIfPossible","levelNum","levelName","toUpperCase","localStorage","ignore","document","cookie","encodeURIComponent","getPersistedLevel","storedLevel","indexOf","exec","levels","clearPersistedLevel","removeItem","getLevel","setLevel","persist","SILENT","setDefaultLevel","resetLevel","enableAll","TRACE","disableAll","initialLevel","defaultLogger","_loggersByName","getLogger","TypeError","logger","_log","noConflict","getLoggers","logLevel","INFO","apiKey","embedHost","sentry","tracingOrigins","tracingPaths","fetchAndTrace","url","init","_url","pathname","transaction","startTransaction","span","startChild","op","response","finish","getApiKeyHeaders","debugLogResponse","info","statusText","promiseTimeout","ms","promise","clearTimeout","race","options_","customOptions","defaultOptions","mode","useAPIKey","options","merge","ok","post","isUrlEncodedData","then","patch","remove","event","resemblesAddress","str","createWalletMiddleware","getAccounts","getPrivateKey","processDecryptMessage","processEncryptionPublicKey","processEthSignMessage","processPersonalMessage","processTransaction","processSignTransaction","processTypedMessage","processTypedMessageV3","processTypedMessageV4","validateAndNormalizeKeyholder","normalizedAccounts","_address","toLowerCase","normalizedAddress","invalidParams","methodNotSupported","txParams","extraParams","msgParams","firstParam","secondParam","warning","ciphertext","eth_accounts","eth_private_key","eth_coinbase","eth_sendTransaction","eth_signTransaction","eth_sign","eth_signTypedData","eth_signTypedData_v3","eth_signTypedData_v4","personal_sign","eth_getEncryptionPublicKey","eth_decrypt","createEthMiddleware","providerHandlers","eth_syncing","createChainIdMiddleware","createProviderConfigMiddleware","providerConfig","createJsonRpcClient","fetchMiddleware","networkMiddleware","connector","sendTransaction","signTransaction","signPersonalMessage","signTypedData","WalletConnectProvider","CHAIN_NAMESPACES","EIP155","skipLookupNetwork","enable","custom","setupProvider","_providerEngineProxy","onConnectorStateUpdate","setupEngine","switchChain","addChain","lookup","displayName","currentChainConfig","getChainConfig","sendCustomRequest","chainName","rpcUrls","lookupNetwork","WalletInitializationError","notReady","connected","connectedHexChainId","isHexStrict","rpcConnectionError","getProviderHandlers","ethMiddleware","updateProviderEngineProxy","connectedChainId","rpcUrl","maybeConfig","BaseProvider","providerFactory","BIG_NUMBER_WEI_MULTIPLIER","BigNumber","BIG_NUMBER_GWEI_MULTIPLIER","BIG_NUMBER_ETH_MULTIPLIER","toBigNumber","dec","toNormalizedDenomination","WEI","bigNumber","div","GWEI","ETH","toSpecifiedDenomination","times","dp","ROUND_HALF_UP","baseChange","conversionUtil","fromNumericBase","fromDenomination","toNumericBase","toDenomination","numberOfDecimals","convertedValue","ROUND_HALF_DOWN","converter","decGWEIToHexWEI","decGWEI","hexWEIToDecGWEI","normalizeGWEIDecimalNumbers","fetchEip1159GasEstimates","estimates","normalizedEstimates","estimatedBaseFee","low","suggestedMaxPriorityFeePerGas","suggestedMaxFeePerGas","medium","high","fetchLegacyGasPriceEstimates","referrer","referrerPolicy","SafeGasPrice","ProposeGasPrice","FastGasPrice","validateTypedMessageParams","parameters","activeChainId","assert","isValidAddress","SignTypedDataVersion","V1","doesNotThrow","parse","typedSignatureHash","V3","V4","primaryType","types","validation","jsonschema","validate","TYPED_MESSAGE_SCHEMA","properties","strictEqual","errors","isNaN","fail","invalidInput","signTx","txFormatter","formatTransaction","finalTxParams","getCommonConfiguration","common","unsignedEthTx","fromTxData","signedTx","sign","serialize","getProviderEngineProxy","privateToAddress","providerEngineProxy","txHash","rawMessageSig","privKeyBuffer","sig","personalSign","finalChainId","getEncryptionPublicKey","stripped","buff","decrypt","encryptedData","bnToHex","inputBn","hexToBn","inputHex","BN","isBN","BnMultiplyByFraction","targetBN","numerator","denominator","numberBN","denomBN","mul","TRANSACTION_ENVELOPE_TYPES","TRANSACTION_TYPES","GAS_ESTIMATE_TYPES","TransactionFormatter","providerProxy","getEIP1559Compatibility","isEIP1559Compatible","hardfork","Hardfork","London","Berlin","customChainParams","networkId","defaultHardfork","Common","clonedTxParams","gasPrice","maxFeePerGas","maxPriorityFeePerGas","gas","getDefaultGasLimit","defaultGasLimit","gasLimit","getDefaultGasFees","defaultGasPrice","defaultMaxFeePerGas","defaultMaxPriorityFeePerGas","a","b","lt","fetchEthGasPriceEstimate","latestBlock","supportsEIP1559","baseFeePerGas","fetchGasFeeEstimateData","isLegacyGasAPICompatible","replace","gasData","gasFeeEstimates","gasEstimateType","estimateTxGas","txMeta","analyzeGasUsage","block","blockGasLimitBN","saferGasLimitBN","estimatedGasHex","warn","blockGasLimit","addGasBuffer","initialGasLimitHex","blockGasLimitHex","multiplier","initialGasLimitBn","blockGasLimitBn","upperGasLimitBn","muln","bufferedGasLimitBn","gt","determineTransactionCategory","txParameters","to","txCategory","transactionCategory","EthereumPrivateKeyProvider","chainSwitchMiddleware","getChainSwitchMiddleware","getAccountMiddleware","updateAccount","network","chainDisconnected","chainSwitchHandlers","blockExplorerUrls","nativeCurrency","ticker","symbol","tickerName","blockExplorer","chainParams","wallet_addEthereumChain","wallet_switchEthereumChain","createChainSwitchMiddleware","accountHandlers","updatePrivatekey","accountParams","wallet_updateAccount","createAccountMiddleware","invalidProviderConfigError","networks","invalidRequest","CommonPrivateKeyProvider","privKeyMiddleware","getPrivKeyMiddleware","getPrivatekey","createPrivKeyMiddleware","private_key","ERROR_SESSION_CONNECTED","ERROR_SESSION_DISCONNECTED","WALLET_CONNECT_EXTENSION_ADAPTERS","chains","logo","mobile","native","universal","desktop","WalletConnectV1Adapter","WALLET_ADAPTERS","WALLET_CONNECT_V1","ADAPTER_NAMESPACES","ADAPTER_CATEGORY","EXTERNAL","NOT_READY","extensionAdapters","adapterOptions","wcProvider","getWalletConnectInstance","ADAPTER_EVENTS","READY","rehydrated","onConnectHandler","connect","CONNECTING","adapterSettings","qrcodeModal","skipNetworkSwitching","createNewSession","adapter","ERRORED","Web3AuthError","connectionError","setAdapterSettings","getUserInfo","cleanup","killSession","DISCONNECTED","networkSwitch","networkSwitchModal","addNetwork","appOrigin","hostname","connectedChainConfig","switchNetwork","newChainConfig","forceNewSession","pending","createSession","updateAdapterData","off","catch","isCustomUi","fromCode","subscribeEvents","reconnected","walletConnectOptions","bridge","WalletConnect"],"mappings":"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","file":"static/js/11.09d23be5.chunk.js","sourcesContent":["import { BaseAdapter, WalletLoginError, ADAPTER_STATUS, getSavedToken, checkIfTokenIsExpired, signChallenge, verifySignedChallenge, saveToken, clearToken } from '@web3auth/base';\n\nclass BaseEvmAdapter extends BaseAdapter {\n  async authenticateUser() {\n    var _this$chainConfig;\n\n    if (!this.provider || !((_this$chainConfig = this.chainConfig) !== null && _this$chainConfig !== void 0 && _this$chainConfig.chainId)) throw WalletLoginError.notConnectedError();\n    const {\n      chainNamespace,\n      chainId\n    } = this.chainConfig;\n    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.notConnectedError(\"Not connected with wallet, Please login/connect first\");\n    const accounts = await this.provider.request({\n      method: \"eth_accounts\"\n    });\n\n    if (accounts && accounts.length > 0) {\n      const existingToken = getSavedToken(accounts[0], this.name);\n\n      if (existingToken) {\n        const isExpired = checkIfTokenIsExpired(existingToken);\n\n        if (!isExpired) {\n          return {\n            idToken: existingToken\n          };\n        }\n      }\n\n      const payload = {\n        domain: window.location.origin,\n        uri: window.location.href,\n        address: accounts[0],\n        chainId: parseInt(chainId, 16),\n        version: \"1\",\n        nonce: Math.random().toString(36).slice(2),\n        issuedAt: new Date().toISOString()\n      };\n      const challenge = await signChallenge(payload, chainNamespace);\n      const signedMessage = await this.provider.request({\n        method: \"personal_sign\",\n        params: [challenge, accounts[0]]\n      });\n      const idToken = await verifySignedChallenge(chainNamespace, signedMessage, challenge, this.name, this.sessionTime);\n      saveToken(accounts[0], this.name, idToken);\n      return {\n        idToken\n      };\n    }\n\n    throw WalletLoginError.notConnectedError(\"Not connected with wallet, Please login/connect first\");\n  }\n\n  async disconnect() {\n    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.disconnectionError(\"Not connected with wallet\");\n    const accounts = await this.provider.request({\n      method: \"eth_accounts\"\n    });\n\n    if (accounts && accounts.length > 0) {\n      clearToken(accounts[0], this.name);\n    }\n  }\n\n}\n\nexport { BaseEvmAdapter };\n//# sourceMappingURL=baseEvmAdapter.esm.js.map\n","import _typeof from '@babel/runtime/helpers/typeof';\nimport _classCallCheck from '@babel/runtime/helpers/classCallCheck';\nimport _createClass from '@babel/runtime/helpers/createClass';\nimport _assertThisInitialized from '@babel/runtime/helpers/assertThisInitialized';\nimport _inherits from '@babel/runtime/helpers/inherits';\nimport _possibleConstructorReturn from '@babel/runtime/helpers/possibleConstructorReturn';\nimport _getPrototypeOf from '@babel/runtime/helpers/getPrototypeOf';\nimport _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { Duplex } from 'readable-stream';\nimport _asyncToGenerator from '@babel/runtime/helpers/asyncToGenerator';\nimport _regeneratorRuntime from '@babel/runtime/regenerator';\nimport { randomId } from '@toruslabs/openlogin-utils';\nimport { EventEmitter } from 'events';\nimport _wrapNativeSuper from '@babel/runtime/helpers/wrapNativeSuper';\nimport stringify from 'fast-safe-stringify';\nimport _slicedToArray from '@babel/runtime/helpers/slicedToArray';\nimport { serializeError } from 'eth-rpc-errors';\nimport eos from 'end-of-stream';\nimport once from 'once';\nimport pump from 'pump';\n\nfunction _createSuper$6(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$6(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$6() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction noop() {\n  return undefined;\n}\nvar SYN = \"SYN\";\nvar ACK = \"ACK\";\nvar BRK = \"BRK\";\nvar BasePostMessageStream = /*#__PURE__*/function (_Duplex) {\n  _inherits(BasePostMessageStream, _Duplex);\n  var _super = _createSuper$6(BasePostMessageStream);\n  function BasePostMessageStream(_ref) {\n    var _this;\n    var name = _ref.name,\n      target = _ref.target,\n      _ref$targetWindow = _ref.targetWindow,\n      targetWindow = _ref$targetWindow === void 0 ? window : _ref$targetWindow,\n      _ref$targetOrigin = _ref.targetOrigin,\n      targetOrigin = _ref$targetOrigin === void 0 ? \"*\" : _ref$targetOrigin;\n    _classCallCheck(this, BasePostMessageStream);\n    _this = _super.call(this, {\n      objectMode: true\n    });\n    _defineProperty(_assertThisInitialized(_this), \"_init\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"_haveSyn\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"_name\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"_target\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"_targetWindow\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"_targetOrigin\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"_onMessage\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"_synIntervalId\", void 0);\n    if (!name || !target) {\n      throw new Error(\"Invalid input.\");\n    }\n    _this._init = false;\n    _this._haveSyn = false;\n    _this._name = name;\n    _this._target = target; // target origin\n    _this._targetWindow = targetWindow;\n    _this._targetOrigin = targetOrigin;\n    _this._onMessage = _this.onMessage.bind(_assertThisInitialized(_this));\n    _this._synIntervalId = null;\n    window.addEventListener(\"message\", _this._onMessage, false);\n    _this._handShake();\n    return _this;\n  }\n  _createClass(BasePostMessageStream, [{\n    key: \"_break\",\n    value: function _break() {\n      this.cork();\n      this._write(BRK, null, noop);\n      this._haveSyn = false;\n      this._init = false;\n    }\n  }, {\n    key: \"_handShake\",\n    value: function _handShake() {\n      this._write(SYN, null, noop);\n      this.cork();\n    }\n  }, {\n    key: \"_onData\",\n    value: function _onData(data) {\n      if (!this._init) {\n        // listen for handshake\n        if (data === SYN) {\n          this._haveSyn = true;\n          this._write(ACK, null, noop);\n        } else if (data === ACK) {\n          this._init = true;\n          if (!this._haveSyn) {\n            this._write(ACK, null, noop);\n          }\n          this.uncork();\n        }\n      } else if (data === BRK) {\n        this._break();\n      } else {\n        // forward message\n        try {\n          this.push(data);\n        } catch (err) {\n          this.emit(\"error\", err);\n        }\n      }\n    }\n  }, {\n    key: \"_postMessage\",\n    value: function _postMessage(data) {\n      var originConstraint = this._targetOrigin;\n      this._targetWindow.postMessage({\n        target: this._target,\n        data: data\n      }, originConstraint);\n    }\n  }, {\n    key: \"onMessage\",\n    value: function onMessage(event) {\n      var message = event.data;\n      // validate message\n      if (this._targetOrigin !== \"*\" && event.origin !== this._targetOrigin || event.source !== this._targetWindow || _typeof(message) !== \"object\" || message.target !== this._name || !message.data) {\n        return;\n      }\n      this._onData(message.data);\n    }\n  }, {\n    key: \"_read\",\n    value: function _read() {\n      return undefined;\n    }\n  }, {\n    key: \"_write\",\n    value: function _write(data, _, cb) {\n      this._postMessage(data);\n      cb();\n    }\n  }, {\n    key: \"_destroy\",\n    value: function _destroy() {\n      window.removeEventListener(\"message\", this._onMessage, false);\n    }\n  }]);\n  return BasePostMessageStream;\n}(Duplex);\n\nfunction _createSuper$5(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$5(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$5() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction safeApply(handler, context, args) {\n  try {\n    Reflect.apply(handler, context, args);\n  } catch (err) {\n    // Throw error after timeout so as not to interrupt the stack\n    setTimeout(function () {\n      throw err;\n    });\n  }\n}\nfunction arrayClone(arr) {\n  var n = arr.length;\n  var copy = new Array(n);\n  for (var i = 0; i < n; i += 1) {\n    copy[i] = arr[i];\n  }\n  return copy;\n}\nvar SafeEventEmitter = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(SafeEventEmitter, _EventEmitter);\n  var _super = _createSuper$5(SafeEventEmitter);\n  function SafeEventEmitter() {\n    _classCallCheck(this, SafeEventEmitter);\n    return _super.apply(this, arguments);\n  }\n  _createClass(SafeEventEmitter, [{\n    key: \"emit\",\n    value: function emit(type) {\n      var doError = type === \"error\";\n      var events = this._events;\n      if (events !== undefined) {\n        doError = doError && events.error === undefined;\n      } else if (!doError) {\n        return false;\n      }\n      // If there is no 'error' event listener then throw.\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n      if (doError) {\n        var er;\n        if (args.length > 0) {\n          er = args[0];\n        }\n        if (er instanceof Error) {\n          // Note: The comments on the `throw` lines are intentional, they show\n          // up in Node's output if this results in an unhandled exception.\n          throw er; // Unhandled 'error' event\n        }\n        // At least give some kind of context to the user\n        var err = new Error(\"Unhandled error.\".concat(er ? \" (\".concat(er.message, \")\") : \"\"));\n        err.context = er;\n        throw err; // Unhandled 'error' event\n      }\n\n      var handler = events[type];\n      if (handler === undefined) {\n        return false;\n      }\n      if (typeof handler === \"function\") {\n        safeApply(handler, this, args);\n      } else {\n        var len = handler.length;\n        var listeners = arrayClone(handler);\n        for (var i = 0; i < len; i += 1) {\n          safeApply(listeners[i], this, args);\n        }\n      }\n      return true;\n    }\n  }]);\n  return SafeEventEmitter;\n}(EventEmitter);\n\nfunction _createSuper$4(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$4(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$4() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nvar SerializableError = /*#__PURE__*/function (_Error) {\n  _inherits(SerializableError, _Error);\n  var _super = _createSuper$4(SerializableError);\n  function SerializableError(_ref) {\n    var _this;\n    var code = _ref.code,\n      message = _ref.message,\n      data = _ref.data;\n    _classCallCheck(this, SerializableError);\n    if (!Number.isInteger(code)) {\n      throw new Error(\"code must be an integer\");\n    }\n    if (!message || typeof message !== \"string\") {\n      throw new Error(\"message must be string\");\n    }\n    _this = _super.call(this, message);\n    _defineProperty(_assertThisInitialized(_this), \"code\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"data\", void 0);\n    _this.code = code;\n    if (data !== undefined) {\n      _this.data = data;\n    }\n    return _this;\n  }\n  _createClass(SerializableError, [{\n    key: \"toString\",\n    value: function toString() {\n      return stringify({\n        code: this.code,\n        message: this.message,\n        data: this.data,\n        stack: this.stack\n      });\n    }\n  }]);\n  return SerializableError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar getRpcPromiseCallback = function getRpcPromiseCallback(resolve, reject) {\n  var unwrapResult = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  return function (error, response) {\n    if (error || response.error) {\n      reject(error || response.error);\n    } else if (!unwrapResult || Array.isArray(response)) {\n      resolve(response);\n    } else {\n      resolve(response.result);\n    }\n  };\n};\nfunction createErrorMiddleware(log) {\n  return function (req, res, next, end) {\n    try {\n      // json-rpc-engine will terminate the request when it notices this error\n      if (typeof req.method !== \"string\" || !req.method) {\n        res.error = new SerializableError({\n          code: -32603,\n          message: \"invalid method\"\n        });\n        end();\n        return;\n      }\n      next(function (done) {\n        var error = res.error;\n        if (!error) {\n          return done();\n        }\n        log.error(\"OpenLogin - RPC Error: \".concat(error.message), error);\n        return done();\n      });\n    } catch (error) {\n      log.error(\"OpenLogin - RPC Error thrown: \".concat(error.message), error);\n      res.error = new SerializableError({\n        code: -32603,\n        message: error.message\n      });\n      end();\n    }\n  };\n}\nfunction createStreamMiddleware() {\n  var idMap = {};\n  function readNoop() {\n    return false;\n  }\n  var events = new SafeEventEmitter();\n  function processResponse(res) {\n    var context = idMap[res.id];\n    if (!context) {\n      throw new Error(\"StreamMiddleware - Unknown response id \\\"\".concat(res.id, \"\\\"\"));\n    }\n    delete idMap[res.id];\n    // copy whole res onto original res\n    Object.assign(context.res, res);\n    // run callback on empty stack,\n    // prevent internal stream-handler from catching errors\n    setTimeout(context.end);\n  }\n  function processNotification(res) {\n    events.emit(\"notification\", res);\n  }\n  function processMessage(res, _encoding, cb) {\n    var err;\n    try {\n      var isNotification = !res.id;\n      if (isNotification) {\n        processNotification(res);\n      } else {\n        processResponse(res);\n      }\n    } catch (_err) {\n      err = _err;\n    }\n    // continue processing stream\n    cb(err);\n  }\n  var stream = new Duplex({\n    objectMode: true,\n    read: readNoop,\n    write: processMessage\n  });\n  var middleware = function middleware(req, res, next, end) {\n    // write req to stream\n    stream.push(req);\n    // register request on id map\n    idMap[req.id] = {\n      req: req,\n      res: res,\n      next: next,\n      end: end\n    };\n  };\n  return {\n    events: events,\n    middleware: middleware,\n    stream: stream\n  };\n}\nfunction createScaffoldMiddleware(handlers) {\n  return function (req, res, next, end) {\n    var handler = handlers[req.method];\n    // if no handler, return\n    if (handler === undefined) {\n      return next();\n    }\n    // if handler is fn, call as middleware\n    if (typeof handler === \"function\") {\n      return handler(req, res, next, end);\n    }\n    // if handler is some other value, use as result\n    res.result = handler;\n    return end();\n  };\n}\nfunction createIdRemapMiddleware() {\n  return function (req, res, next, _end) {\n    var originalId = req.id;\n    var newId = randomId();\n    req.id = newId;\n    res.id = newId;\n    next(function (done) {\n      req.id = originalId;\n      res.id = originalId;\n      done();\n    });\n  };\n}\nfunction createLoggerMiddleware(logger) {\n  return function (req, res, next, _) {\n    logger.debug(\"REQ\", req, \"RES\", res);\n    next();\n  };\n}\nfunction createAsyncMiddleware(asyncMiddleware) {\n  return /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(req, res, next, end) {\n      var resolveNextPromise, nextPromise, returnHandlerCallback, nextWasCalled, asyncNext;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              // nextPromise is the key to the implementation\n              // it is resolved by the return handler passed to the\n              // \"next\" function\n              nextPromise = new Promise(function (resolve) {\n                resolveNextPromise = resolve;\n              });\n              returnHandlerCallback = null;\n              nextWasCalled = false; // This will be called by the consumer's async middleware.\n              asyncNext = /*#__PURE__*/function () {\n                var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n                  return _regeneratorRuntime.wrap(function _callee$(_context) {\n                    while (1) {\n                      switch (_context.prev = _context.next) {\n                        case 0:\n                          nextWasCalled = true;\n                          // We pass a return handler to next(). When it is called by the engine,\n                          // the consumer's async middleware will resume executing.\n                          next(function (runReturnHandlersCallback) {\n                            // This callback comes from JRPCEngine._runReturnHandlers\n                            returnHandlerCallback = runReturnHandlersCallback;\n                            resolveNextPromise();\n                          });\n                          _context.next = 4;\n                          return nextPromise;\n                        case 4:\n                        case \"end\":\n                          return _context.stop();\n                      }\n                    }\n                  }, _callee);\n                }));\n                return function asyncNext() {\n                  return _ref2.apply(this, arguments);\n                };\n              }();\n              _context2.prev = 4;\n              _context2.next = 7;\n              return asyncMiddleware(req, res, asyncNext);\n            case 7:\n              if (!nextWasCalled) {\n                _context2.next = 13;\n                break;\n              }\n              _context2.next = 10;\n              return nextPromise;\n            case 10:\n              // we must wait until the return handler is called\n              returnHandlerCallback(null);\n              _context2.next = 14;\n              break;\n            case 13:\n              end(null);\n            case 14:\n              _context2.next = 19;\n              break;\n            case 16:\n              _context2.prev = 16;\n              _context2.t0 = _context2[\"catch\"](4);\n              if (returnHandlerCallback) {\n                returnHandlerCallback(_context2.t0);\n              } else {\n                end(_context2.t0);\n              }\n            case 19:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, null, [[4, 16]]);\n    }));\n    return function (_x, _x2, _x3, _x4) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _createSuper$3(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$3(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$3() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n/**\n * A JSON-RPC request and response processor.\n * Give it a stack of middleware, pass it requests, and get back responses.\n */\nvar JRPCEngine = /*#__PURE__*/function (_SafeEventEmitter) {\n  _inherits(JRPCEngine, _SafeEventEmitter);\n  var _super = _createSuper$3(JRPCEngine);\n  function JRPCEngine() {\n    var _this;\n    _classCallCheck(this, JRPCEngine);\n    _this = _super.call(this);\n    _defineProperty(_assertThisInitialized(_this), \"_middleware\", void 0);\n    _this._middleware = [];\n    return _this;\n  }\n  /**\n   * Serially executes the given stack of middleware.\n   *\n   * @returns An array of any error encountered during middleware execution,\n   * a boolean indicating whether the request was completed, and an array of\n   * middleware-defined return handlers.\n   */\n  _createClass(JRPCEngine, [{\n    key: \"push\",\n    value:\n    /**\n     * Add a middleware function to the engine's middleware stack.\n     *\n     * @param middleware - The middleware function to add.\n     */\n    function push(middleware) {\n      this._middleware.push(middleware);\n    }\n  }, {\n    key: \"handle\",\n    value: function handle(req, cb) {\n      if (cb && typeof cb !== \"function\") {\n        throw new Error('\"callback\" must be a function if provided.');\n      }\n      if (Array.isArray(req)) {\n        if (cb) {\n          return this._handleBatch(req, cb);\n        }\n        return this._handleBatch(req);\n      }\n      if (cb) {\n        return this._handle(req, cb);\n      }\n      return this._promiseHandle(req);\n    }\n    /**\n     * Returns this engine as a middleware function that can be pushed to other\n     * engines.\n     *\n     * @returns This engine as a middleware function.\n     */\n  }, {\n    key: \"asMiddleware\",\n    value: function asMiddleware() {\n      var _this2 = this;\n      return /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(req, res, next, end) {\n          var _yield$JRPCEngine$_ru, _yield$JRPCEngine$_ru2, middlewareError, isComplete, returnHandlers;\n          return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  _context2.prev = 0;\n                  _context2.next = 3;\n                  return JRPCEngine._runAllMiddleware(req, res, _this2._middleware);\n                case 3:\n                  _yield$JRPCEngine$_ru = _context2.sent;\n                  _yield$JRPCEngine$_ru2 = _slicedToArray(_yield$JRPCEngine$_ru, 3);\n                  middlewareError = _yield$JRPCEngine$_ru2[0];\n                  isComplete = _yield$JRPCEngine$_ru2[1];\n                  returnHandlers = _yield$JRPCEngine$_ru2[2];\n                  if (!isComplete) {\n                    _context2.next = 12;\n                    break;\n                  }\n                  _context2.next = 11;\n                  return JRPCEngine._runReturnHandlers(returnHandlers);\n                case 11:\n                  return _context2.abrupt(\"return\", end(middlewareError));\n                case 12:\n                  return _context2.abrupt(\"return\", next( /*#__PURE__*/function () {\n                    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(handlerCallback) {\n                      return _regeneratorRuntime.wrap(function _callee$(_context) {\n                        while (1) {\n                          switch (_context.prev = _context.next) {\n                            case 0:\n                              _context.prev = 0;\n                              _context.next = 3;\n                              return JRPCEngine._runReturnHandlers(returnHandlers);\n                            case 3:\n                              _context.next = 8;\n                              break;\n                            case 5:\n                              _context.prev = 5;\n                              _context.t0 = _context[\"catch\"](0);\n                              return _context.abrupt(\"return\", handlerCallback(_context.t0));\n                            case 8:\n                              return _context.abrupt(\"return\", handlerCallback());\n                            case 9:\n                            case \"end\":\n                              return _context.stop();\n                          }\n                        }\n                      }, _callee, null, [[0, 5]]);\n                    }));\n                    return function (_x5) {\n                      return _ref2.apply(this, arguments);\n                    };\n                  }()));\n                case 15:\n                  _context2.prev = 15;\n                  _context2.t0 = _context2[\"catch\"](0);\n                  return _context2.abrupt(\"return\", end(_context2.t0));\n                case 18:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2, null, [[0, 15]]);\n        }));\n        return function (_x, _x2, _x3, _x4) {\n          return _ref.apply(this, arguments);\n        };\n      }();\n    }\n  }, {\n    key: \"_handleBatch\",\n    value: function () {\n      var _handleBatch2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(reqs, cb) {\n        var responses;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.prev = 0;\n                _context3.next = 3;\n                return Promise.all(\n                // 1. Begin executing each request in the order received\n                reqs.map(this._promiseHandle.bind(this)));\n              case 3:\n                responses = _context3.sent;\n                if (!cb) {\n                  _context3.next = 6;\n                  break;\n                }\n                return _context3.abrupt(\"return\", cb(null, responses));\n              case 6:\n                return _context3.abrupt(\"return\", responses);\n              case 9:\n                _context3.prev = 9;\n                _context3.t0 = _context3[\"catch\"](0);\n                if (!cb) {\n                  _context3.next = 13;\n                  break;\n                }\n                return _context3.abrupt(\"return\", cb(_context3.t0));\n              case 13:\n                throw _context3.t0;\n              case 14:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[0, 9]]);\n      }));\n      function _handleBatch(_x6, _x7) {\n        return _handleBatch2.apply(this, arguments);\n      }\n      return _handleBatch;\n    }()\n    /**\n     * A promise-wrapped _handle.\n     */\n  }, {\n    key: \"_promiseHandle\",\n    value: function _promiseHandle(req) {\n      var _this3 = this;\n      return new Promise(function (resolve) {\n        _this3._handle(req, function (_err, res) {\n          // There will always be a response, and it will always have any error\n          // that is caught and propagated.\n          resolve(res);\n        });\n      });\n    }\n    /**\n     * Ensures that the request object is valid, processes it, and passes any\n     * error and the response object to the given callback.\n     *\n     * Does not reject.\n     */\n  }, {\n    key: \"_handle\",\n    value: function () {\n      var _handle2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(callerReq, cb) {\n        var _error2, _error3, req, res, error;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!(!callerReq || Array.isArray(callerReq) || _typeof(callerReq) !== \"object\")) {\n                  _context4.next = 3;\n                  break;\n                }\n                _error2 = new SerializableError({\n                  code: -32603,\n                  message: \"request must be plain object\"\n                });\n                return _context4.abrupt(\"return\", cb(_error2, {\n                  id: undefined,\n                  jsonrpc: \"2.0\",\n                  error: _error2\n                }));\n              case 3:\n                if (!(typeof callerReq.method !== \"string\")) {\n                  _context4.next = 6;\n                  break;\n                }\n                _error3 = new SerializableError({\n                  code: -32603,\n                  message: \"method must be string\"\n                });\n                return _context4.abrupt(\"return\", cb(_error3, {\n                  id: callerReq.id,\n                  jsonrpc: \"2.0\",\n                  error: _error3\n                }));\n              case 6:\n                req = _objectSpread$1({}, callerReq);\n                res = {\n                  id: req.id,\n                  jsonrpc: req.jsonrpc\n                };\n                error = null;\n                _context4.prev = 9;\n                _context4.next = 12;\n                return this._processRequest(req, res);\n              case 12:\n                _context4.next = 17;\n                break;\n              case 14:\n                _context4.prev = 14;\n                _context4.t0 = _context4[\"catch\"](9);\n                // A request handler error, a re-thrown middleware error, or something\n                // unexpected.\n                error = _context4.t0;\n              case 17:\n                if (error) {\n                  // Ensure no result is present on an errored response\n                  delete res.result;\n                  if (!res.error) {\n                    res.error = serializeError(error);\n                  }\n                }\n                return _context4.abrupt(\"return\", cb(error, res));\n              case 19:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[9, 14]]);\n      }));\n      function _handle(_x8, _x9) {\n        return _handle2.apply(this, arguments);\n      }\n      return _handle;\n    }()\n    /**\n     * For the given request and response, runs all middleware and their return\n     * handlers, if any, and ensures that internal request processing semantics\n     * are satisfied.\n     */\n  }, {\n    key: \"_processRequest\",\n    value: function () {\n      var _processRequest2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(req, res) {\n        var _yield$JRPCEngine$_ru3, _yield$JRPCEngine$_ru4, error, isComplete, returnHandlers;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return JRPCEngine._runAllMiddleware(req, res, this._middleware);\n              case 2:\n                _yield$JRPCEngine$_ru3 = _context5.sent;\n                _yield$JRPCEngine$_ru4 = _slicedToArray(_yield$JRPCEngine$_ru3, 3);\n                error = _yield$JRPCEngine$_ru4[0];\n                isComplete = _yield$JRPCEngine$_ru4[1];\n                returnHandlers = _yield$JRPCEngine$_ru4[2];\n                // Throw if \"end\" was not called, or if the response has neither a result\n                // nor an error.\n                JRPCEngine._checkForCompletion(req, res, isComplete);\n                // The return handlers should run even if an error was encountered during\n                // middleware processing.\n                _context5.next = 10;\n                return JRPCEngine._runReturnHandlers(returnHandlers);\n              case 10:\n                if (!error) {\n                  _context5.next = 12;\n                  break;\n                }\n                throw error;\n              case 12:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n      function _processRequest(_x10, _x11) {\n        return _processRequest2.apply(this, arguments);\n      }\n      return _processRequest;\n    }()\n  }], [{\n    key: \"_runAllMiddleware\",\n    value: function () {\n      var _runAllMiddleware2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(req, res, middlewareStack) {\n        var returnHandlers, error, isComplete, _iterator, _step, middleware, _yield$JRPCEngine$_ru5, _yield$JRPCEngine$_ru6;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                returnHandlers = [];\n                error = null;\n                isComplete = false; // Go down stack of middleware, call and collect optional returnHandlers\n                _iterator = _createForOfIteratorHelper(middlewareStack);\n                _context6.prev = 4;\n                _iterator.s();\n              case 6:\n                if ((_step = _iterator.n()).done) {\n                  _context6.next = 18;\n                  break;\n                }\n                middleware = _step.value;\n                _context6.next = 10;\n                return JRPCEngine._runMiddleware(req, res, middleware, returnHandlers);\n              case 10:\n                _yield$JRPCEngine$_ru5 = _context6.sent;\n                _yield$JRPCEngine$_ru6 = _slicedToArray(_yield$JRPCEngine$_ru5, 2);\n                error = _yield$JRPCEngine$_ru6[0];\n                isComplete = _yield$JRPCEngine$_ru6[1];\n                if (!isComplete) {\n                  _context6.next = 16;\n                  break;\n                }\n                return _context6.abrupt(\"break\", 18);\n              case 16:\n                _context6.next = 6;\n                break;\n              case 18:\n                _context6.next = 23;\n                break;\n              case 20:\n                _context6.prev = 20;\n                _context6.t0 = _context6[\"catch\"](4);\n                _iterator.e(_context6.t0);\n              case 23:\n                _context6.prev = 23;\n                _iterator.f();\n                return _context6.finish(23);\n              case 26:\n                return _context6.abrupt(\"return\", [error, isComplete, returnHandlers.reverse()]);\n              case 27:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, null, [[4, 20, 23, 26]]);\n      }));\n      function _runAllMiddleware(_x12, _x13, _x14) {\n        return _runAllMiddleware2.apply(this, arguments);\n      }\n      return _runAllMiddleware;\n    }()\n    /**\n     * Runs an individual middleware.\n     *\n     * @returns An array of any error encountered during middleware exection,\n     * and a boolean indicating whether the request should end.\n     */\n  }, {\n    key: \"_runMiddleware\",\n    value: function _runMiddleware(req, res, middleware, returnHandlers) {\n      return new Promise(function (resolve) {\n        var end = function end(err) {\n          var error = err || res.error;\n          if (error) {\n            res.error = serializeError(error);\n          }\n          // True indicates that the request should end\n          resolve([error, true]);\n        };\n        var next = function next(returnHandler) {\n          if (res.error) {\n            end(res.error);\n          } else {\n            if (returnHandler) {\n              if (typeof returnHandler !== \"function\") {\n                end(new SerializableError({\n                  code: -32603,\n                  message: \"JRPCEngine: 'next' return handlers must be functions\"\n                }));\n              }\n              returnHandlers.push(returnHandler);\n            }\n            // False indicates that the request should not end\n            resolve([null, false]);\n          }\n        };\n        try {\n          middleware(req, res, next, end);\n        } catch (error) {\n          end(error);\n        }\n      });\n    }\n    /**\n     * Serially executes array of return handlers. The request and response are\n     * assumed to be in their scope.\n     */\n  }, {\n    key: \"_runReturnHandlers\",\n    value: function () {\n      var _runReturnHandlers2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(handlers) {\n        var _iterator2, _step2, _loop;\n        return _regeneratorRuntime.wrap(function _callee7$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _iterator2 = _createForOfIteratorHelper(handlers);\n                _context8.prev = 1;\n                _loop = /*#__PURE__*/_regeneratorRuntime.mark(function _loop() {\n                  var handler;\n                  return _regeneratorRuntime.wrap(function _loop$(_context7) {\n                    while (1) {\n                      switch (_context7.prev = _context7.next) {\n                        case 0:\n                          handler = _step2.value;\n                          _context7.next = 3;\n                          return new Promise(function (resolve, reject) {\n                            handler(function (err) {\n                              return err ? reject(err) : resolve();\n                            });\n                          });\n                        case 3:\n                        case \"end\":\n                          return _context7.stop();\n                      }\n                    }\n                  }, _loop);\n                });\n                _iterator2.s();\n              case 4:\n                if ((_step2 = _iterator2.n()).done) {\n                  _context8.next = 8;\n                  break;\n                }\n                return _context8.delegateYield(_loop(), \"t0\", 6);\n              case 6:\n                _context8.next = 4;\n                break;\n              case 8:\n                _context8.next = 13;\n                break;\n              case 10:\n                _context8.prev = 10;\n                _context8.t1 = _context8[\"catch\"](1);\n                _iterator2.e(_context8.t1);\n              case 13:\n                _context8.prev = 13;\n                _iterator2.f();\n                return _context8.finish(13);\n              case 16:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee7, null, [[1, 10, 13, 16]]);\n      }));\n      function _runReturnHandlers(_x15) {\n        return _runReturnHandlers2.apply(this, arguments);\n      }\n      return _runReturnHandlers;\n    }()\n    /**\n     * Throws an error if the response has neither a result nor an error, or if\n     * the \"isComplete\" flag is falsy.\n     */\n  }, {\n    key: \"_checkForCompletion\",\n    value: function _checkForCompletion(req, res, isComplete) {\n      if (!(\"result\" in res) && !(\"error\" in res)) {\n        throw new SerializableError({\n          code: -32603,\n          message: \"Response has no error or result for request\"\n        });\n      }\n      if (!isComplete) {\n        throw new SerializableError({\n          code: -32603,\n          message: \"Nothing ended request\"\n        });\n      }\n    }\n  }]);\n  return JRPCEngine;\n}(SafeEventEmitter);\nfunction mergeMiddleware(middlewareStack) {\n  var engine = new JRPCEngine();\n  middlewareStack.forEach(function (middleware) {\n    return engine.push(middleware);\n  });\n  return engine.asMiddleware();\n}\nfunction createEngineStream(opts) {\n  if (!opts || !opts.engine) {\n    throw new Error(\"Missing engine parameter!\");\n  }\n  var engine = opts.engine;\n  // eslint-disable-next-line prefer-const\n  var stream;\n  function read() {\n    return undefined;\n  }\n  function write(req, _encoding, cb) {\n    engine.handle(req, function (_err, res) {\n      stream.push(res);\n    });\n    cb();\n  }\n  stream = new Duplex({\n    objectMode: true,\n    read: read,\n    write: write\n  });\n  // forward notifications\n  if (engine.on) {\n    engine.on(\"notification\", function (message) {\n      stream.push(message);\n    });\n  }\n  return stream;\n}\n\nfunction _createSuper$2(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$2(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$2() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nvar Substream = /*#__PURE__*/function (_Duplex) {\n  _inherits(Substream, _Duplex);\n  var _super = _createSuper$2(Substream);\n  function Substream(_ref) {\n    var _this;\n    var parent = _ref.parent,\n      name = _ref.name;\n    _classCallCheck(this, Substream);\n    _this = _super.call(this, {\n      objectMode: true\n    });\n    _defineProperty(_assertThisInitialized(_this), \"_parent\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"_name\", void 0);\n    _this._parent = parent;\n    _this._name = name;\n    return _this;\n  }\n  /**\n   * Explicitly sets read operations to a no-op.\n   */\n  _createClass(Substream, [{\n    key: \"_read\",\n    value: function _read() {\n      return undefined;\n    }\n    /**\n     * Called when data should be written to this writable stream.\n     *\n     * @param chunk - Arbitrary object to write\n     * @param encoding - Encoding to use when writing payload\n     * @param callback - Called when writing is complete or an error occurs\n     */\n  }, {\n    key: \"_write\",\n    value: function _write(chunk, _encoding, callback) {\n      this._parent.push({\n        name: this._name,\n        data: chunk\n      });\n      callback();\n    }\n  }]);\n  return Substream;\n}(Duplex);\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$1() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nvar IGNORE_SUBSTREAM = Symbol(\"IGNORE_SUBSTREAM\");\nvar ObjectMultiplex = /*#__PURE__*/function (_Duplex) {\n  _inherits(ObjectMultiplex, _Duplex);\n  var _super = _createSuper$1(ObjectMultiplex);\n  function ObjectMultiplex() {\n    var _this;\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, ObjectMultiplex);\n    _this = _super.call(this, _objectSpread(_objectSpread({}, opts), {}, {\n      objectMode: true\n    }));\n    _defineProperty(_assertThisInitialized(_this), \"_substreams\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"getStream\", void 0);\n    _this._substreams = {};\n    return _this;\n  }\n  _createClass(ObjectMultiplex, [{\n    key: \"createStream\",\n    value: function createStream(name) {\n      // validate name\n      if (!name) {\n        throw new Error(\"ObjectMultiplex - name must not be empty\");\n      }\n      if (this._substreams[name]) {\n        throw new Error(\"ObjectMultiplex - Substream for name \\\"\".concat(name, \"\\\" already exists\"));\n      }\n      // create substream\n      var substream = new Substream({\n        parent: this,\n        name: name\n      });\n      this._substreams[name] = substream;\n      // listen for parent stream to end\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      anyStreamEnd(this, function (_error) {\n        return substream.destroy(_error || undefined);\n      });\n      return substream;\n    }\n    // ignore streams (dont display orphaned data warning)\n  }, {\n    key: \"ignoreStream\",\n    value: function ignoreStream(name) {\n      // validate name\n      if (!name) {\n        throw new Error(\"ObjectMultiplex - name must not be empty\");\n      }\n      if (this._substreams[name]) {\n        throw new Error(\"ObjectMultiplex - Substream for name \\\"\".concat(name, \"\\\" already exists\"));\n      }\n      // set\n      this._substreams[name] = IGNORE_SUBSTREAM;\n    }\n  }, {\n    key: \"_read\",\n    value: function _read() {\n      return undefined;\n    }\n  }, {\n    key: \"_write\",\n    value: function _write(chunk, _encoding, callback) {\n      var name = chunk.name,\n        data = chunk.data;\n      if (!name) {\n        window.console.warn(\"ObjectMultiplex - malformed chunk without name \\\"\".concat(chunk, \"\\\"\"));\n        return callback();\n      }\n      // get corresponding substream\n      var substream = this._substreams[name];\n      if (!substream) {\n        window.console.warn(\"ObjectMultiplex - orphaned data for stream \\\"\".concat(name, \"\\\"\"));\n        return callback();\n      }\n      // push data into substream\n      if (substream !== IGNORE_SUBSTREAM) {\n        substream.push(data);\n      }\n      return callback();\n    }\n  }]);\n  return ObjectMultiplex;\n}(Duplex);\n// util\nfunction anyStreamEnd(stream, _cb) {\n  var cb = once(_cb);\n  eos(stream, {\n    readable: false\n  }, cb);\n  eos(stream, {\n    writable: false\n  }, cb);\n}\nfunction setupMultiplex(stream) {\n  var mux = new ObjectMultiplex();\n  mux.getStream = function streamHelper(name) {\n    if (this._substreams[name]) {\n      return this._substreams[name];\n    }\n    return this.createStream(name);\n  };\n  pump(stream, mux, stream, function (err) {\n    if (err) window.console.error(err);\n  });\n  return mux;\n}\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nvar PostMessageStream = /*#__PURE__*/function (_BasePostMessageStrea) {\n  _inherits(PostMessageStream, _BasePostMessageStrea);\n  var _super = _createSuper(PostMessageStream);\n  function PostMessageStream() {\n    _classCallCheck(this, PostMessageStream);\n    return _super.apply(this, arguments);\n  }\n  _createClass(PostMessageStream, [{\n    key: \"_postMessage\",\n    value: function _postMessage(data) {\n      var originConstraint = this._targetOrigin;\n      if (_typeof(data) === \"object\") {\n        var dataObj = data;\n        if (_typeof(dataObj.data) === \"object\") {\n          var dataObjData = dataObj.data;\n          if (Array.isArray(dataObjData.params) && dataObjData.params.length > 0) {\n            var dataObjDataParam = dataObjData.params[0];\n            if (dataObjDataParam._origin) {\n              originConstraint = dataObjDataParam._origin;\n            }\n            // add a constraint for the response\n            dataObjDataParam._origin = window.location.origin;\n          }\n        }\n      }\n      this._targetWindow.postMessage({\n        target: this._target,\n        data: data\n      }, originConstraint);\n    }\n  }]);\n  return PostMessageStream;\n}(BasePostMessageStream);\n\nexport { BasePostMessageStream, IGNORE_SUBSTREAM, JRPCEngine, ObjectMultiplex, PostMessageStream, SafeEventEmitter, SerializableError, Substream, createAsyncMiddleware, createEngineStream, createErrorMiddleware, createIdRemapMiddleware, createLoggerMiddleware, createScaffoldMiddleware, createStreamMiddleware, getRpcPromiseCallback, mergeMiddleware, setupMultiplex };\n//# sourceMappingURL=openloginJrpc.esm.js.map\n",null,null,null,null,null,null,"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { SafeEventEmitter, JRPCEngine, createAsyncMiddleware, mergeMiddleware, createScaffoldMiddleware } from '@toruslabs/openlogin-jrpc';\nimport { serializeError, ethErrors } from 'eth-rpc-errors';\nimport getCreateRandomId from 'json-rpc-random-id';\nimport { BigNumber } from 'bignumber.js';\nimport { fromSigned, bufferToInt, toUnsigned, stripHexPrefix, addHexPrefix, hashPersonalMessage, ecsign, intToBuffer } from 'ethereumjs-util';\nimport log from 'loglevel';\nimport { BroadcastChannel } from '@toruslabs/broadcast-channel';\nimport { get, post, patch, remove } from '@toruslabs/http-helpers';\nimport bowser from 'bowser';\nimport { cloneDeep, pickBy, omitBy } from 'lodash';\n\nfunction ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$3(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n/**\n * Controller class that provides configuration, state management, and subscriptions\n */\n\nclass BaseController extends SafeEventEmitter {\n  /**\n   * Default options used to configure this controller\n   */\n\n  /**\n   * Default state set on this controller\n   */\n\n  /**\n   * Determines if listeners are notified of state changes\n   */\n\n  /**\n   * Name of this controller used during composition\n   */\n\n  /**\n   * Creates a BaseController instance. Both initial state and initial\n   * configuration options are merged with defaults upon initialization.\n   *\n   * @param config - Initial options used to configure this controller\n   * @param state - Initial state to set on this controller\n   */\n  constructor(_ref) {\n    let {\n      config = {},\n      state = {}\n    } = _ref;\n    super(); // Use assign since generics can't be spread: https://git.io/vpRhY\n\n    _defineProperty(this, \"defaultConfig\", {});\n\n    _defineProperty(this, \"defaultState\", {});\n\n    _defineProperty(this, \"disabled\", false);\n\n    _defineProperty(this, \"name\", \"BaseController\");\n\n    _defineProperty(this, \"initialConfig\", void 0);\n\n    _defineProperty(this, \"initialState\", void 0);\n\n    _defineProperty(this, \"internalConfig\", this.defaultConfig);\n\n    _defineProperty(this, \"internalState\", this.defaultState);\n\n    this.initialState = state;\n    this.initialConfig = config;\n  }\n  /**\n   * Retrieves current controller configuration options\n   *\n   * @returns - Current configuration\n   */\n\n\n  get config() {\n    return this.internalConfig;\n  }\n  /**\n   * Retrieves current controller state\n   *\n   * @returns - Current state\n   */\n\n\n  get state() {\n    return this.internalState;\n  }\n  /**\n   * Updates controller configuration\n   *\n   * @param config - New configuration options\n   * @param overwrite - Overwrite config instead of merging\n   * @param fullUpdate - Boolean that defines if the update is partial or not\n   */\n\n\n  configure(config) {\n    let overwrite = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let fullUpdate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n    if (fullUpdate) {\n      this.internalConfig = overwrite ? config : Object.assign(this.internalConfig, config);\n\n      for (const key in this.internalConfig) {\n        if (typeof this.internalConfig[key] !== \"undefined\") {\n          this[key] = this.internalConfig[key];\n        }\n      }\n    } else {\n      for (const key in config) {\n        /* istanbul ignore else */\n        if (typeof this.internalConfig[key] !== \"undefined\") {\n          this.internalConfig[key] = config[key];\n          this[key] = config[key];\n        }\n      }\n    }\n  }\n  /**\n   * Updates controller state\n   *\n   * @param state - New state\n   * @param overwrite - Overwrite state instead of merging\n   */\n\n\n  update(state) {\n    let overwrite = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    this.internalState = overwrite ? _objectSpread$3({}, state) : _objectSpread$3(_objectSpread$3({}, this.internalState), state);\n    this.emit(\"store\", this.internalState);\n  }\n  /**\n   * Enables the controller. This sets each config option as a member\n   * variable on this instance and triggers any defined setters. This\n   * also sets initial state and triggers any listeners.\n   *\n   * @returns - This controller instance\n   */\n\n\n  initialize() {\n    this.internalState = this.defaultState;\n    this.internalConfig = this.defaultConfig;\n    this.configure(this.initialConfig);\n    this.update(this.initialState);\n    return this;\n  }\n\n}\n\nconst sec = 1000;\n\nconst calculateSum = (accumulator, currentValue) => accumulator + currentValue;\n\nconst blockTrackerEvents = [\"sync\", \"latest\"];\nclass BaseBlockTracker extends BaseController {\n  constructor(_ref) {\n    let {\n      config = {},\n      state = {}\n    } = _ref;\n    super({\n      config,\n      state\n    }); // config\n\n    _defineProperty(this, \"name\", \"BaseBlockTracker\");\n\n    _defineProperty(this, \"_blockResetTimeout\", void 0);\n\n    this.defaultState = {\n      _currentBlock: {\n        idempotencyKey: \"\"\n      },\n      _isRunning: false\n    };\n    this.defaultConfig = {\n      blockResetDuration: 20 * sec\n    };\n    this.initialize(); // bind functions for internal use\n\n    this._onNewListener = this._onNewListener.bind(this);\n    this._onRemoveListener = this._onRemoveListener.bind(this);\n    this._resetCurrentBlock = this._resetCurrentBlock.bind(this); // listen for handler changes\n\n    this._setupInternalEvents();\n  }\n\n  isRunning() {\n    return this.state._isRunning;\n  }\n\n  getCurrentBlock() {\n    return this.state._currentBlock;\n  }\n\n  async getLatestBlock() {\n    // return if available\n    if (this.state._currentBlock) {\n      return this.state._currentBlock;\n    } // wait for a new latest block\n\n\n    const latestBlock = await new Promise(resolve => this.once(\"latest\", newState => {\n      if (newState._currentBlock) {\n        resolve(newState._currentBlock);\n      }\n    })); // return newly set current block\n\n    return latestBlock;\n  } // dont allow module consumer to remove our internal event listeners\n\n\n  removeAllListeners(eventName) {\n    if (eventName) {\n      super.removeAllListeners(eventName);\n    } else {\n      super.removeAllListeners();\n    } // re-add internal events\n\n\n    this._setupInternalEvents(); // trigger stop check just in case\n\n\n    this._onRemoveListener();\n\n    return this;\n  }\n  /**\n   * To be implemented in subclass.\n   */\n\n\n  _start() {// default behavior is noop\n  }\n  /**\n   * To be implemented in subclass.\n   */\n\n\n  _end() {// default behavior is noop\n  }\n\n  _newPotentialLatest(newBlock) {\n    const currentBlock = this.state._currentBlock; // only update if blok number is higher\n\n    if (currentBlock && newBlock.idempotencyKey === currentBlock.idempotencyKey) {\n      return;\n    }\n\n    this._setCurrentBlock(newBlock);\n  }\n\n  _setupInternalEvents() {\n    // first remove listeners for idempotency\n    this.removeListener(\"newListener\", this._onNewListener);\n    this.removeListener(\"removeListener\", this._onRemoveListener); // then add them\n\n    this.on(\"removeListener\", this._onRemoveListener);\n    this.on(\"newListener\", this._onNewListener);\n  }\n\n  _onNewListener() {\n    this._maybeStart();\n  }\n\n  _onRemoveListener() {\n    // `removeListener` is called *after* the listener is removed\n    if (this._getBlockTrackerEventCount() > 0) {\n      return;\n    }\n\n    this._maybeEnd();\n  }\n\n  _maybeStart() {\n    if (this.state._isRunning) {\n      return;\n    }\n\n    this.state._isRunning = true; // cancel setting latest block to stale\n\n    this._cancelBlockResetTimeout();\n\n    this._start();\n  }\n\n  _maybeEnd() {\n    if (!this.state._isRunning) {\n      return;\n    }\n\n    this.state._isRunning = false;\n\n    this._setupBlockResetTimeout();\n\n    this._end();\n  }\n\n  _getBlockTrackerEventCount() {\n    return blockTrackerEvents.map(eventName => this.listenerCount(eventName)).reduce(calculateSum);\n  }\n\n  _setCurrentBlock(newBlock) {\n    const oldBlock = this.state._currentBlock;\n    this.update({\n      _currentBlock: newBlock\n    });\n    this.emit(\"latest\", newBlock);\n    this.emit(\"sync\", {\n      oldBlock,\n      newBlock\n    });\n  }\n\n  _setupBlockResetTimeout() {\n    // clear any existing timeout\n    this._cancelBlockResetTimeout(); // clear latest block when stale\n\n\n    this._blockResetTimeout = setTimeout(this._resetCurrentBlock, this.config.blockResetDuration); // nodejs - dont hold process open\n\n    if (this._blockResetTimeout.unref) {\n      this._blockResetTimeout.unref();\n    }\n  }\n\n  _cancelBlockResetTimeout() {\n    if (this._blockResetTimeout) {\n      clearTimeout(this._blockResetTimeout);\n    }\n  }\n\n  _resetCurrentBlock() {\n    this.update({\n      _currentBlock: {\n        idempotencyKey: \"\"\n      }\n    });\n  }\n\n}\n\nconst filterNoop = () => true;\n\nconst internalEvents = [\"newListener\", \"removeListener\"];\n\nconst externalEventFilter = name => !internalEvents.includes(name);\n\nfunction getRawListeners(eventEmitter, name) {\n  // prefer native\n  return eventEmitter.rawListeners(name);\n}\n\nfunction createEventEmitterProxy(initialTarget, opts) {\n  // parse options\n  const finalOpts = opts || {};\n  let eventFilter = finalOpts.eventFilter || filterNoop;\n  if (typeof eventFilter === \"string\" && eventFilter === \"skipInternal\") eventFilter = externalEventFilter;\n  if (typeof eventFilter !== \"function\") throw new Error(\"createEventEmitterProxy - Invalid eventFilter\");\n  let target = initialTarget;\n\n  let setTarget = newTarget => {\n    const oldTarget = target;\n    target = newTarget;\n    oldTarget.eventNames().filter(eventFilter).forEach(name => {\n      getRawListeners(oldTarget, name).forEach(handler => newTarget.on(name, handler));\n    }); // remove old listeners\n\n    oldTarget.removeAllListeners();\n  };\n\n  const proxy = new Proxy({}, {\n    get: (_, name) => {\n      // override `setTarget` access\n      if (name === \"setTarget\") return setTarget;\n      return target[name];\n    },\n    set: (_, name, value) => {\n      // allow `setTarget` overrides\n      if (name === \"setTarget\") {\n        setTarget = value;\n        return true;\n      }\n\n      target[name] = value;\n      return true;\n    }\n  });\n  return proxy;\n}\n\nfunction createSwappableProxy(initialTarget) {\n  let target = initialTarget;\n\n  let setTarget = newTarget => {\n    target = newTarget;\n  };\n\n  const proxy = new Proxy({}, {\n    get: (_, name) => {\n      // override `setTarget` access\n      if (name === \"setTarget\") return setTarget;\n      return target[name];\n    },\n    set: (_, name, value) => {\n      // allow `setTarget` overrides\n      if (name === \"setTarget\") {\n        setTarget = value;\n        return true;\n      }\n\n      target[name] = value;\n      return true;\n    }\n  });\n  return proxy;\n}\n\nconst POLLING_INTERVAL = 600000;\nclass BaseCurrencyController extends BaseController {\n  constructor(_ref) {\n    let {\n      config = {},\n      state\n    } = _ref;\n    super({\n      config,\n      state\n    });\n    this.defaultState = {\n      currentCurrency: \"usd\",\n      conversionRate: 0,\n      conversionDate: \"N/A\",\n      nativeCurrency: \"ETH\"\n    };\n    this.defaultConfig = {\n      pollInterval: POLLING_INTERVAL\n    };\n    this.initialize();\n  } //\n  // PUBLIC METHODS\n  //\n\n\n  getNativeCurrency() {\n    return this.state.nativeCurrency;\n  }\n\n  setNativeCurrency(nativeCurrency) {\n    this.update({\n      nativeCurrency,\n      ticker: nativeCurrency\n    });\n  }\n\n  getCurrentCurrency() {\n    return this.state.currentCurrency;\n  }\n\n  setCurrentCurrency(currentCurrency) {\n    this.update({\n      currentCurrency\n    });\n  }\n  /**\n   * A getter for the conversionRate property\n   *\n   * @returns The conversion rate from ETH to the selected currency.\n   *\n   */\n\n\n  getConversionRate() {\n    return this.state.conversionRate;\n  }\n\n  setConversionRate(conversionRate) {\n    this.update({\n      conversionRate\n    });\n  }\n  /**\n   * A getter for the conversionDate property\n   *\n   * @returns The date at which the conversion rate was set. Expressed in milliseconds since midnight of\n   * January 1, 1970\n   *\n   */\n\n\n  getConversionDate() {\n    return this.state.conversionDate;\n  }\n\n  setConversionDate(conversionDate) {\n    this.update({\n      conversionDate\n    });\n  }\n\n}\n\nfunction ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nconst createRandomId = getCreateRandomId();\nfunction providerFromEngine(engine) {\n  const provider = new SafeEventEmitter(); // handle both rpc send methods\n\n  provider.sendAsync = async req => {\n    const res = await engine.handle(req);\n\n    if (res.error) {\n      var _res$error, _res$error2;\n\n      const err = serializeError(res.error, {\n        fallbackError: {\n          message: ((_res$error = res.error) === null || _res$error === void 0 ? void 0 : _res$error.message) || res.error.toString(),\n          code: ((_res$error2 = res.error) === null || _res$error2 === void 0 ? void 0 : _res$error2.code) || -32603\n        }\n      });\n      throw ethErrors.rpc.internal(err);\n    }\n\n    return res.result;\n  }; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  provider.send = (req, callback) => {\n    if (typeof callback !== \"function\") {\n      throw new Error('Must provide callback to \"send\" method.');\n    }\n\n    engine.handle(req, callback);\n  }; // forward notifications\n\n\n  if (engine.on) {\n    engine.on(\"notification\", message => {\n      provider.emit(\"data\", null, message);\n    });\n  }\n\n  provider.request = async args => {\n    const req = _objectSpread$2(_objectSpread$2({}, args), {}, {\n      id: createRandomId(),\n      jsonrpc: \"2.0\"\n    });\n\n    const res = await provider.sendAsync(req);\n    return res;\n  };\n\n  return provider;\n}\nfunction providerFromMiddleware(middleware) {\n  const engine = new JRPCEngine();\n  engine.push(middleware);\n  const provider = providerFromEngine(engine);\n  return provider;\n}\nfunction providerAsMiddleware(provider) {\n  return async (req, res, _next, end) => {\n    // send request to provider\n    try {\n      const providerRes = await provider.sendAsync(req);\n      res.result = providerRes;\n      return end();\n    } catch (error) {\n      return end(error.message);\n    }\n  };\n}\n\nconst FEATURES_PROVIDER_CHANGE_WINDOW = {\n  height: 660,\n  width: 375\n};\nconst FEATURES_DEFAULT_WALLET_WINDOW = {\n  height: 740,\n  width: 1315\n};\nconst FEATURES_DEFAULT_POPUP_WINDOW = {\n  height: 700,\n  width: 1200\n};\nconst FEATURES_CONFIRM_WINDOW = {\n  height: 700,\n  width: 450\n};\nconst POPUP_LOADED = \"popup_loaded\";\nconst POPUP_RESULT = \"popup_result\";\nconst SETUP_COMPLETE = \"setup_complete\";\nconst ACTIVITY_ACTION_ALL = \"walletActivity.allTransactions\";\nconst ACTIVITY_ACTION_SEND = \"walletActivity.send\";\nconst ACTIVITY_ACTION_BURN = \"walletActivity.burn\";\nconst ACTIVITY_ACTION_RECEIVE = \"walletActivity.receive\";\nconst ACTIVITY_ACTION_TOPUP = \"walletActivity.topup\";\nconst ACTIVITY_PERIOD_ALL = \"walletActivity.all\";\nconst ACTIVITY_PERIOD_WEEK_ONE = \"walletActivity.lastOneWeek\";\nconst ACTIVITY_PERIOD_MONTH_ONE = \"walletActivity.lastOneMonth\";\nconst ACTIVITY_PERIOD_MONTH_SIX = \"walletActivity.lastSixMonts\";\nconst ACTIVITY_STATUS_SUCCESSFUL = \"walletActivity.successful\";\nconst ACTIVITY_STATUS_UNSUCCESSFUL = \"walletActivity.unsuccessful\";\nconst ACTIVITY_STATUS_PENDING = \"walletActivity.pending\";\nconst ACTIVITY_STATUS_CANCELLED = \"walletActivity.cancelled\";\nconst ACTIVITY_STATUS_CANCELLING = \"walletActivity.cancelling\";\nconst COMMUNICATION_NOTIFICATIONS = {\n  IFRAME_STATUS: \"iframe_status\",\n  // Tell embed to create the window\n  CREATE_WINDOW: \"create_window\",\n  // Tell embed to close the window\n  CLOSE_WINDOW: \"close_window\",\n  USER_LOGGED_IN: \"user_logged_in\",\n  USER_LOGGED_OUT: \"user_logged_out\"\n};\nconst COMMUNICATION_JRPC_METHODS = {\n  LOGOUT: \"logout\",\n  WALLET_INSTANCE_ID: \"wallet_instance_id\",\n  USER_INFO: \"user_info\",\n  SET_PROVIDER: \"set_provider\",\n  TOPUP: \"topup\",\n  IFRAME_STATUS: \"iframe_status\",\n  // embed has opened the window as requested\n  OPENED_WINDOW: \"opened_window\",\n  // user has closed the window from embed's side\n  CLOSED_WINDOW: \"closed_window\",\n  GET_PROVIDER_STATE: \"get_provider_state\",\n  LOGIN_WITH_PRIVATE_KEY: \"login_with_private_key\"\n};\nconst PROVIDER_JRPC_METHODS = {\n  GET_PROVIDER_STATE: \"wallet_get_provider_state\"\n};\nconst PROVIDER_NOTIFICATIONS = {\n  ACCOUNTS_CHANGED: \"wallet_accounts_changed\",\n  CHAIN_CHANGED: \"wallet_chain_changed\",\n  UNLOCK_STATE_CHANGED: \"wallet_unlock_state_changed\"\n};\nconst BROADCAST_CHANNELS = {\n  REDIRECT_CHANNEL: \"redirect_channel\",\n  PROVIDER_CHANGE_CHANNEL: \"torus_provider_change_channel\",\n  TRANSACTION_CHANNEL: \"torus_channel\",\n  MESSAGE_CHANNEL: \"torus_message_channel\",\n  WALLET_LOGOUT_CHANNEL: \"wallet_logout_channel\",\n  WALLET_SELECTED_ADDRESS_CHANNEL: \"wallet_selected_address_channel\",\n  WALLET_NETWORK_CHANGE_CHANNEL: \"wallet_network_change_channel\",\n  WALLET_ACCOUNT_IMPORT_CHANNEL: \"wallet_account_import_channel\",\n  THEME_CHANGE: \"theme_change_channel\"\n};\nconst BROADCAST_CHANNELS_MSGS = {\n  LOGOUT: \"logout\",\n  ACCOUNT_IMPORTED: \"account_imported\",\n  SELECTED_ADDRESS_CHANGE: \"selected_address_change\",\n  NETWORK_CHANGE: \"network_change\",\n  SET_THEME: \"set_theme\"\n};\n\nfunction createChangeProviderMiddlewareMiddleware(_ref) {\n  let {\n    changeProvider\n  } = _ref;\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== COMMUNICATION_JRPC_METHODS.SET_PROVIDER) return next();\n    if (!changeProvider) throw new Error(\"CommunicationMiddleware - opts.changeProvider not provided\");\n    response.result = await changeProvider(request);\n  });\n}\nfunction createTopupMiddleware(_ref2) {\n  let {\n    topup\n  } = _ref2;\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== COMMUNICATION_JRPC_METHODS.TOPUP) return next();\n    if (!topup) throw new Error(\"CommunicationMiddleware - opts.topup not provided\");\n    response.result = await topup(request);\n  });\n}\nfunction createGenericJRPCMiddleware(targetMethod, handler) {\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== targetMethod) return next();\n    if (!handler) throw new Error(\"CommunicationMiddleware - \".concat(targetMethod, \" not provided\"));\n    const result = await handler(request);\n\n    if (!result) {\n      return next();\n    }\n\n    response.result = result;\n    return undefined;\n  });\n}\nfunction createCommunicationMiddleware(providerHandlers) {\n  const {\n    getUserInfo,\n    getWalletInstanceId,\n    topup,\n    logout,\n    changeProvider,\n    setIFrameStatus,\n    handleWindowRpc,\n    getProviderState,\n    loginWithPrivateKey\n  } = providerHandlers;\n  return mergeMiddleware([createChangeProviderMiddlewareMiddleware({\n    changeProvider\n  }), createTopupMiddleware({\n    topup\n  }), createScaffoldMiddleware({\n    [COMMUNICATION_JRPC_METHODS.LOGOUT]: logout,\n    [COMMUNICATION_JRPC_METHODS.WALLET_INSTANCE_ID]: getWalletInstanceId,\n    [COMMUNICATION_JRPC_METHODS.USER_INFO]: getUserInfo,\n    [COMMUNICATION_JRPC_METHODS.IFRAME_STATUS]: setIFrameStatus,\n    // Do this in the orchestrator because communicationWindowManager needs to be passed into PopupHandlers\n    [COMMUNICATION_JRPC_METHODS.OPENED_WINDOW]: handleWindowRpc,\n    [COMMUNICATION_JRPC_METHODS.CLOSED_WINDOW]: handleWindowRpc,\n    [COMMUNICATION_JRPC_METHODS.GET_PROVIDER_STATE]: getProviderState\n  }), createGenericJRPCMiddleware(COMMUNICATION_JRPC_METHODS.LOGIN_WITH_PRIVATE_KEY, loginWithPrivateKey)]);\n}\n\nclass BaseEmbedController extends BaseController {\n  constructor(_ref) {\n    let {\n      config = {},\n      state\n    } = _ref;\n    super({\n      config,\n      state\n    });\n\n    _defineProperty(this, \"_communicationProviderProxy\", void 0);\n\n    this.defaultState = {\n      buttonPosition: \"bottom-right\",\n      isIFrameFullScreen: true,\n      apiKey: \"torus-default\",\n      oauthModalVisibility: false,\n      loginInProgress: false,\n      dappMetadata: {\n        name: \"\",\n        icon: \"\"\n      }\n    };\n    this.initialize();\n  }\n  /**\n   * Called by orchestrator once while initializing the class\n   * @param handlers - JRPC handlers for provider\n   * @returns - provider - Returns the providerProxy\n   */\n\n\n  initializeProvider(handlers) {\n    const engine = new JRPCEngine();\n    const communicationMiddleware = createCommunicationMiddleware(handlers);\n    engine.push(communicationMiddleware);\n    const communicationProvider = providerFromEngine(engine);\n    this.setCommunicationProvider(communicationProvider);\n  }\n\n  setCommunicationProvider(communicationProvider) {\n    if (this._communicationProviderProxy) {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      this._communicationProviderProxy.setTarget(communicationProvider);\n    } else {\n      this._communicationProviderProxy = createSwappableProxy(communicationProvider);\n    }\n  }\n\n}\n\nclass CommunicationWindowManager extends SafeEventEmitter {\n  constructor() {\n    super(...arguments);\n\n    _defineProperty(this, \"handleWindowRpc\", (request, response, next, end) => {\n      const {\n        method,\n        params\n      } = request;\n\n      if (method === COMMUNICATION_JRPC_METHODS.OPENED_WINDOW) {\n        const {\n          windowId\n        } = params; // I've been informed that a window has been opened\n\n        this.emit(\"\".concat(windowId, \":opened\"));\n        response.result = true;\n        end();\n      } else if (method === COMMUNICATION_JRPC_METHODS.CLOSED_WINDOW) {\n        const {\n          windowId\n        } = params; // I've been informed that a window has been closed\n\n        this.emit(\"\".concat(windowId, \":closed\"));\n        response.result = true;\n        end();\n      } else {\n        next();\n      }\n    });\n  }\n\n}\n\nconst LOGIN_PROVIDER = {\n  GOOGLE: \"google\",\n  FACEBOOK: \"facebook\",\n  REDDIT: \"reddit\",\n  DISCORD: \"discord\",\n  TWITCH: \"twitch\",\n  APPLE: \"apple\",\n  LINE: \"line\",\n  GITHUB: \"github\",\n  KAKAO: \"kakao\",\n  LINKEDIN: \"linkedin\",\n  TWITTER: \"twitter\",\n  WEIBO: \"weibo\",\n  WECHAT: \"wechat\",\n  EMAIL_PASSWORDLESS: \"email_passwordless\"\n};\nconst PAYMENT_PROVIDER = {\n  MOONPAY: \"moonpay\",\n  WYRE: \"wyre\",\n  RAMPNETWORK: \"rampnetwork\",\n  XANPOOL: \"xanpool\",\n  MERCURYO: \"mercuryo\",\n  TRANSAK: \"transak\"\n};\n\nconst getTxStatusText = txStatus => {\n  switch (txStatus) {\n    case \"rejected\":\n    case \"unapproved\":\n    case \"failed\":\n      return ACTIVITY_STATUS_UNSUCCESSFUL;\n\n    case \"confirmed\":\n      return ACTIVITY_STATUS_SUCCESSFUL;\n\n    case \"submitted\":\n      return ACTIVITY_STATUS_PENDING;\n\n    case \"cancelled\":\n      return ACTIVITY_STATUS_CANCELLED;\n\n    default:\n      return \"\";\n  }\n};\n\n/**\n * General utility functions\n */\n\nfunction intToHex(i) {\n  const hex = i.toString(16);\n  return \"0x\".concat(hex);\n}\n/**\n * Returns a random number. Don't use for cryptographic purposes.\n * @returns a random number\n */\n\nconst randomId = () => Math.random().toString(36).slice(2);\n/**\n * Pads the front of the given hex string with zeroes until it reaches the\n * target length. If the input string is already longer than or equal to the\n * target length, it is returned unmodified.\n *\n * If the input string is \"0x\"-prefixed or not a hex string, an error will be\n * thrown.\n *\n * @param hexString - The hexadecimal string to pad with zeroes.\n * @param targetLength - The target length of the hexadecimal string.\n * @returns The input string front-padded with zeroes, or the original string\n * if it was already greater than or equal to to the target length.\n */\n\nfunction padWithZeroes(hexString, targetLength) {\n  if (hexString !== \"\" && !/^[a-f0-9]+$/iu.test(hexString)) {\n    throw new Error(\"Expected an unprefixed hex string. Received: \".concat(hexString));\n  }\n\n  if (targetLength < 0) {\n    throw new Error(\"Expected a non-negative integer target length. Received: \".concat(targetLength));\n  }\n\n  return String.prototype.padStart.call(hexString, targetLength, \"0\");\n}\n/**\n * Concatenate an extended ECDSA signature into a hex string.\n *\n * @param v - The 'v' portion of the signature.\n * @param r - The 'r' portion of the signature.\n * @param s - The 's' portion of the signature.\n * @returns The concatenated ECDSA signature.\n */\n\nfunction concatSig(v, r, s) {\n  const rSig = fromSigned(r);\n  const sSig = fromSigned(s);\n  const vSig = bufferToInt(v);\n  const rStr = padWithZeroes(toUnsigned(rSig).toString(\"hex\"), 64);\n  const sStr = padWithZeroes(toUnsigned(sSig).toString(\"hex\"), 64);\n  const vStr = stripHexPrefix(intToHex(vSig));\n  return addHexPrefix(rStr.concat(sStr, vStr));\n}\nfunction timeout$1(duration) {\n  return new Promise(resolve => {\n    const timeoutRef = window.setTimeout(() => {\n      resolve();\n      window.clearTimeout(timeoutRef);\n    }, duration);\n  });\n}\nconst getHeaders = jwt => {\n  return {\n    headers: {\n      Authorization: \"Bearer \".concat(jwt),\n      \"Content-Type\": \"application/json; charset=utf-8\"\n    }\n  };\n};\n/**\n * Text/number formatting utilities\n */\n\nconst formatSmallNumbers = function (number) {\n  let currency = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"usd\";\n  let noTilde = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  const finalNumber = BigNumber.isBigNumber(number) ? number.toNumber() : number;\n  if (!Number.isFinite(finalNumber)) return \"\";\n  const value = currency.toLowerCase() === \"usd\" ? parseFloat(Number(finalNumber).toFixed(2)) : parseFloat(Number(finalNumber).toFixed(5));\n  const tilde = value > 0 ? \"~ \" : \"\";\n  return \"\".concat(currency.toLowerCase() === \"usd\" || noTilde ? \"\" : tilde).concat(Number(value), \" \").concat(currency.toUpperCase());\n};\nconst addressSlicer = function (address) {\n  let sliceLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;\n\n  if (address.length < 11) {\n    return address;\n  }\n\n  if (typeof address !== \"string\") return \"\";\n  return \"\".concat(address.slice(0, sliceLength), \"...\").concat(address.slice(-sliceLength));\n};\nconst significantDigits = function (number) {\n  let perc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  let length_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;\n  let input = !BigNumber.isBigNumber(number) ? new BigNumber(number) : number;\n  if (input.isZero()) return input;\n\n  if (perc) {\n    input = input.times(new BigNumber(100));\n  }\n\n  let depth;\n\n  if (input.gte(new BigNumber(1))) {\n    depth = length_;\n  } else {\n    depth = length_ - 1 + Math.ceil(Math.log10(new BigNumber(\"1\").div(input).toNumber()));\n  }\n\n  const shift = new BigNumber(10).pow(new BigNumber(depth));\n  const roundedNumber = Math.round(shift.times(input).toNumber()) / shift.toNumber();\n  return roundedNumber;\n};\nconst formatDate = inputDate => {\n  const monthList = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n  const date = new Date(inputDate);\n  const day = date.getDate();\n  const month = monthList[date.getMonth()];\n  const year = date.getFullYear();\n  return \"\".concat(day, \" \").concat(month, \" \").concat(year);\n};\nconst formatTime = time => {\n  return new Date(time).toTimeString().slice(0, 8);\n};\n/**\n * Network utilities\n */\n\nconst transactionMatchesNetwork = (transaction, chainId) => {\n  if (typeof transaction.chainId !== \"undefined\") {\n    return transaction.chainId === chainId;\n  }\n\n  return false;\n};\n/**\n * Signing utils\n */\n\nconst hashMessage = message => {\n  const bufferedMessage = Buffer.from(message, \"utf8\");\n  const el = hashPersonalMessage(bufferedMessage);\n  return el;\n};\nconst signMessage = (privateKey, data) => {\n  const privKey = Buffer.from(privateKey, \"hex\");\n  const message = stripHexPrefix(data);\n  const msgSig = ecsign(Buffer.from(message, \"hex\"), privKey);\n  const rawMsgSig = concatSig(intToBuffer(msgSig.v), msgSig.r, msgSig.s);\n  return rawMsgSig;\n};\n/**\n * popup handler utils\n */\n\nfunction getPopupFeatures(_ref) {\n  let {\n    width: w,\n    height: h\n  } = _ref;\n  // Fixes dual-screen position                             Most browsers      Firefox\n  const dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : window.screenX;\n  const dualScreenTop = window.screenTop !== undefined ? window.screenTop : window.screenY;\n  const width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : window.screen.width;\n  const height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : window.screen.height;\n  const systemZoom = 1; // No reliable estimate\n\n  const left = Math.abs((width - w) / 2 / systemZoom + dualScreenLeft);\n  const top = Math.abs((height - h) / 2 / systemZoom + dualScreenTop);\n  const features = \"titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=\".concat(h / systemZoom, \",width=\").concat(w / systemZoom, \",top=\").concat(top, \",left=\").concat(left);\n  return features;\n}\nconst broadcastChannelOptions = {\n  // type: 'localstorage', // (optional) enforce a type, oneOf['native', 'idb', 'localstorage', 'node']\n  webWorkerSupport: false // (optional) set this to false if you know that your channel will never be used in a WebWorker (increases performance)\n\n};\nfunction getCustomDeviceInfo() {\n  var _navigator;\n\n  if ((_navigator = navigator) !== null && _navigator !== void 0 && _navigator.brave) {\n    return {\n      browser: \"Brave\"\n    };\n  }\n}\nclass UserError extends Error {}\nconst handleRedirectParameters = (hash, queryParameters) => {\n  const hashParameters = {};\n  const hashUrl = new URL(\"\".concat(window.location.origin, \"/?\").concat(hash.slice(1)));\n  hashUrl.searchParams.forEach((value, key) => {\n    hashParameters[key] = value;\n  });\n  let instanceParameters = {};\n  let error = \"\";\n\n  if (!queryParameters.windowId) {\n    if (Object.keys(hashParameters).length > 0 && hashParameters.state) {\n      instanceParameters = JSON.parse(window.atob(decodeURIComponent(decodeURIComponent(hashParameters.state)))) || {};\n      error = hashParameters.error_description || hashParameters.error || error;\n    } else if (Object.keys(queryParameters).length > 0 && queryParameters.state) {\n      instanceParameters = JSON.parse(window.atob(decodeURIComponent(decodeURIComponent(queryParameters.state)))) || {};\n      if (queryParameters.error) error = queryParameters.error;\n    }\n  }\n\n  return {\n    error,\n    instanceParameters,\n    hashParameters\n  };\n};\nfunction sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nclass BaseKeyringController extends BaseController {\n  constructor(_ref) {\n    var _state$wallets;\n\n    let {\n      config = {},\n      state\n    } = _ref;\n    super({\n      config,\n      state\n    });\n    this.defaultState = {\n      wallets: (_state$wallets = state.wallets) !== null && _state$wallets !== void 0 ? _state$wallets : []\n    };\n    this.initialize();\n  } // for signing auth message\n\n\n  signAuthMessage(address, message) {\n    const keyring = this.state.wallets.find(x => x.address === address);\n\n    if (!keyring) {\n      throw new Error(\"key does not exist\");\n    }\n\n    const hashedMessage = hashMessage(message).toString(\"hex\");\n    const rawMessageSig = signMessage(keyring.privateKey, hashedMessage);\n    return rawMessageSig;\n  }\n\n}\n\nconst RETRIABLE_ERRORS = [// ignore server overload errors\n\"Gateway timeout\", \"ETIMEDOUT\", // ignore server sent html error pages\n// or truncated json responses\n\"failed to parse response body\", // ignore errors where http req failed to establish\n\"Failed to fetch\"];\n\nfunction checkForHttpErrors(fetchRes) {\n  // check for errors\n  switch (fetchRes.status) {\n    case 405:\n      throw ethErrors.rpc.methodNotFound();\n\n    case 418:\n      throw ethErrors.rpc.internal({\n        message: \"Request is being rate limited.\"\n      });\n\n    case 503:\n    case 504:\n      throw ethErrors.rpc.internal({\n        message: \"Gateway timeout. The request took too long to process.\" + \"This can happen when querying over too wide a block range.\"\n      });\n  }\n}\n\nfunction timeout(duration) {\n  return new Promise(resolve => setTimeout(resolve, duration));\n}\n\nfunction parseResponse(fetchRes, body) {\n  // check for error code\n  if (fetchRes.status !== 200) {\n    throw ethErrors.rpc.internal({\n      message: \"Non-200 status code: '\".concat(fetchRes.status, \"'\"),\n      data: body\n    });\n  } // check for rpc error\n\n\n  if (body.error) {\n    throw ethErrors.rpc.internal({\n      data: body.error\n    });\n  } // return successful result\n\n\n  return body.result;\n}\n\nfunction createFetchConfigFromReq(_ref) {\n  let {\n    req,\n    rpcTarget,\n    originHttpHeaderKey\n  } = _ref;\n  const parsedUrl = new URL(rpcTarget); // prepare payload\n  // copy only canonical json rpc properties\n\n  const payload = {\n    id: req.id,\n    jsonrpc: req.jsonrpc,\n    method: req.method,\n    params: req.params\n  }; // extract 'origin' parameter from request\n\n  const originDomain = req.origin; // serialize request body\n\n  const serializedPayload = JSON.stringify(payload); // configure fetch params\n\n  const fetchParams = {\n    method: \"POST\",\n    headers: {\n      Accept: \"application/json\",\n      \"Content-Type\": \"application/json\"\n    },\n    body: serializedPayload\n  }; // optional: add request origin as header\n\n  if (originHttpHeaderKey && originDomain) {\n    fetchParams.headers[originHttpHeaderKey] = originDomain;\n  }\n\n  return {\n    fetchUrl: parsedUrl.href,\n    fetchParams\n  };\n}\nfunction createFetchMiddleware(_ref2) {\n  let {\n    rpcTarget,\n    originHttpHeaderKey\n  } = _ref2;\n  return createAsyncMiddleware(async (req, res, _next) => {\n    const {\n      fetchUrl,\n      fetchParams\n    } = createFetchConfigFromReq({\n      req,\n      rpcTarget,\n      originHttpHeaderKey\n    }); // attempt request multiple times\n\n    const maxAttempts = 5;\n    const retryInterval = 1000;\n\n    for (let attempt = 0; attempt < maxAttempts; attempt++) {\n      try {\n        const fetchRes = await fetch(fetchUrl, fetchParams); // check for http errrors\n\n        checkForHttpErrors(fetchRes); // parse response body\n\n        const fetchBody = await fetchRes.json();\n        const result = parseResponse(fetchRes, fetchBody); // set result and exit retry loop\n\n        res.result = result;\n        return;\n      } catch (err) {\n        const errMsg = err.toString();\n        const isRetriable = RETRIABLE_ERRORS.some(phrase => errMsg.includes(phrase)); // re-throw error if not retriable\n\n        if (!isRetriable) {\n          throw err;\n        }\n      } // delay before retrying\n\n\n      await timeout(retryInterval);\n    }\n  });\n}\n\nfunction createLoggerMiddleware(options) {\n  return function loggerMiddleware(request, response, next) {\n    next(callback => {\n      if (response.error) {\n        log.warn(\"Error in RPC response:\\n\", response);\n      }\n\n      if (request.isTorusInternal) return;\n      log.info(\"RPC (\".concat(options.origin, \"):\"), request, \"->\", response);\n      callback();\n    });\n  };\n}\n\nfunction createOriginMiddleware(options) {\n  return function originMiddleware(request, _, next) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    request.origin = options.origin;\n    next();\n  };\n}\n\nclass BroadcastChannelHandler {\n  constructor(channelPrefix) {\n    _defineProperty(this, \"bc\", void 0);\n\n    _defineProperty(this, \"channel\", void 0);\n\n    const queryParameters = new URLSearchParams(window.location.search);\n    const instanceId = queryParameters.get(\"instanceId\");\n    this.channel = \"\".concat(channelPrefix, \"_\").concat(instanceId);\n    this.bc = new BroadcastChannel(this.channel, broadcastChannelOptions);\n  }\n\n  getMessageFromChannel() {\n    return new Promise((resolve, reject) => {\n      this.bc.addEventListener(\"message\", async ev => {\n        this.bc.close();\n\n        if (ev.error) {\n          reject(ev.error);\n        } else {\n          resolve(ev.data);\n        }\n      });\n      this.bc.postMessage({\n        data: {\n          type: POPUP_LOADED\n        }\n      });\n    });\n  }\n\n}\n\nclass StreamWindow extends BaseController {\n  // if window has been closed by users\n  constructor(_ref) {\n    let {\n      config,\n      state = {}\n    } = _ref;\n    super({\n      config,\n      state\n    });\n\n    _defineProperty(this, \"closed\", false);\n\n    this.initialize();\n  }\n\n  async open() {\n    return new Promise((resolve, reject) => {\n      const {\n        communicationEngine,\n        communicationWindowManager\n      } = this.config;\n      let popupSuccess = false;\n      communicationWindowManager.once(\"\".concat(this.state.windowId, \":closed\"), () => {\n        this.closed = true;\n      }); // Window is not open yet\n\n      if (!this.state.windowId) {\n        this.update({\n          windowId: randomId()\n        });\n        communicationWindowManager.once(\"\".concat(this.state.windowId, \":opened\"), () => {\n          resolve(this);\n        }); // Tell the other party to create a window by prompting the user to click on something\n\n        communicationEngine.emit(\"notification\", {\n          method: COMMUNICATION_NOTIFICATIONS.CREATE_WINDOW,\n          params: {\n            windowId: this.state.windowId,\n            url: this.state.url.href\n          }\n        });\n      } else {\n        // Send this window with `windowId` the url to open via bc\n        const bc = new BroadcastChannel(this.state.windowId, broadcastChannelOptions);\n        bc.addEventListener(\"message\", async ev => {\n          try {\n            log.info(ev, \"receiving data on channel: \".concat(bc.name));\n            const {\n              error\n            } = ev;\n\n            if (error) {\n              // Popup says some error. so, we say it's not really opened\n              reject(new Error(error));\n              return;\n            }\n\n            const {\n              message\n            } = ev.data;\n\n            if (message === POPUP_LOADED) {\n              popupSuccess = true;\n              await bc.postMessage({\n                data: {\n                  url: this.state.url.href,\n                  message: \"\" // No need of a msg\n\n                }\n              });\n              resolve(this);\n              bc.close();\n            }\n          } catch (error) {\n            reject(error);\n            bc.close(); // Something went wrong. so, we close that window\n\n            this.close();\n          }\n        }); // We don't know if the other end is ready to receive this msg. So, we keep writing until it receives and sends back something\n        // we need backoff strategy\n        // we need to wait for first attempt to succeed/fail until the second attempt\n        // If we get 429, we need to wait for a while and then try again\n\n        const postMsg = async () => {\n          // this never throws\n          const localResponse = await bc.postMessage({\n            data: {\n              message: SETUP_COMPLETE\n            }\n          });\n          return localResponse;\n        };\n\n        let currentDelay = bc.type === \"server\" ? 1000 : 200;\n\n        const recursiveFn = async () => {\n          if (!popupSuccess && !this.closed) {\n            const localResponse = await postMsg();\n\n            if (bc.type === \"server\") {\n              const serverResponse = localResponse;\n\n              if (serverResponse.status >= 400) {\n                // We need to wait for a while and then try again\n                currentDelay = Math.round(currentDelay * 1.5);\n              }\n            }\n\n            await sleep(currentDelay);\n            await recursiveFn();\n          }\n        };\n\n        recursiveFn();\n      }\n    });\n  }\n\n  close() {\n    const {\n      communicationEngine\n    } = this.config;\n    communicationEngine.emit(\"notification\", {\n      method: COMMUNICATION_NOTIFICATIONS.CLOSE_WINDOW,\n      params: {\n        windowId: this.state.windowId\n      }\n    });\n  }\n\n}\n\n/*\nScenarios:\n1. Open a normal popup window and no communication with it - Use PopupHandler\n2. Open a popup window and communicate with it - Use PopupWithBcHandler (can initiate communication by waiting for window to open or not)\n\n3. If window is already opened, pass in windowId to the popup handler.\n   This will establish communication with the popup window and sends it a new url to redirect to\n\n\nIf you're trying to open a window and it gets blocked (happens if you're in iframe or delay b/w click and opening window),\nStreamWindow is invoked and it writes in a channel to display a message to the user\n\nOnce user clicks on that modal/dialog, we pre-open the window and pass in the windowId (goes to 3)\n*/\n\n/**\n * Handles popup window management.\n * For broadcast channel communication, use url with `instanceId` coded into state parameter.\n * This state parameter will be passed across redirects according to OAuth spec.\n */\n\nclass PopupHandler extends BaseController {\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config,\n      state\n    }); // this.id = randomId()\n    // Add in dapp storage key to all popups as a hash parameter\n\n    this.defaultConfig = {\n      dappStorageKey: \"\",\n      features: getPopupFeatures(FEATURES_DEFAULT_POPUP_WINDOW),\n      target: \"_blank\",\n      communicationEngine: null,\n      communicationWindowManager: null\n    };\n    this.defaultState = {\n      windowTimer: null,\n      window: null,\n      iClosedWindow: false,\n      windowId: \"\",\n      url: state.url\n    };\n    this.initialize();\n\n    this._setupTimer();\n  }\n\n  async open() {\n    // if window is already open\n    const {\n      target,\n      features,\n      dappStorageKey,\n      communicationEngine,\n      communicationWindowManager\n    } = this.config;\n    const {\n      windowId,\n      url\n    } = this.state;\n\n    if (dappStorageKey) {\n      const urlHashParams = new URLSearchParams(url.hash.slice(1));\n      urlHashParams.append(\"dappStorageKey\", dappStorageKey);\n      url.hash = urlHashParams.toString();\n      this.update({\n        url\n      });\n    } // No window has been pre-opened\n\n\n    if (!windowId) {\n      // try to open a window first\n      let localWindow = window.open(url.href, target, features);\n\n      if (!localWindow) {\n        // if it's blocked, open StreamWindow\n        localWindow = new StreamWindow({\n          config: {\n            communicationEngine,\n            communicationWindowManager\n          },\n          state: {\n            url\n          }\n        });\n        localWindow.open();\n      }\n\n      this.update({\n        window: localWindow\n      });\n      return;\n    } // A window has been pre-opened with a query parameter `windowId`\n\n\n    const localWindow = new StreamWindow({\n      config: {\n        communicationEngine,\n        communicationWindowManager\n      },\n      state: {\n        url,\n        windowId\n      }\n    });\n    this.update({\n      window: localWindow\n    });\n    await localWindow.open();\n  }\n\n  close() {\n    this.update({\n      iClosedWindow: true\n    });\n    const {\n      window\n    } = this.state;\n    if (window) window.close();\n  }\n\n  _setupTimer() {\n    const timer = window.setInterval(() => {\n      const {\n        window,\n        windowTimer,\n        iClosedWindow\n      } = this.state;\n\n      if (window && window.closed) {\n        if (windowTimer) clearInterval(windowTimer);\n\n        if (!iClosedWindow) {\n          this.emit(\"close\");\n        }\n\n        this.update({\n          iClosedWindow: false,\n          window: null\n        });\n      }\n\n      if (window === null && windowTimer) clearInterval(windowTimer);\n    }, 500);\n    this.update({\n      windowTimer: timer\n    });\n  }\n\n}\n\nclass PopupStoreChannel {\n  constructor(_ref) {\n    let {\n      instanceId,\n      handleLogout,\n      handleAccountImport,\n      handleNetworkChange,\n      handleSelectedAddressChange,\n      handleThemeChange\n    } = _ref;\n\n    _defineProperty(this, \"handleLogout\", void 0);\n\n    _defineProperty(this, \"handleAccountImport\", void 0);\n\n    _defineProperty(this, \"handleNetworkChange\", void 0);\n\n    _defineProperty(this, \"handleThemeChange\", void 0);\n\n    _defineProperty(this, \"handleSelectedAddressChange\", void 0);\n\n    _defineProperty(this, \"instanceId\", void 0);\n\n    this.instanceId = instanceId;\n    this.handleLogout = handleLogout;\n    this.handleAccountImport = handleAccountImport;\n    this.handleNetworkChange = handleNetworkChange;\n    this.handleSelectedAddressChange = handleSelectedAddressChange;\n    this.handleThemeChange = handleThemeChange;\n  }\n\n  setupStoreChannels() {\n    this.logoutChannel();\n    this.importAccountChannel();\n    this.networkChangeChannel();\n    this.selectedAddressChangeChannel();\n    this.themeChangedChannel();\n  }\n\n  logoutChannel() {\n    const logoutChannel = new BroadcastChannel(\"\".concat(BROADCAST_CHANNELS.WALLET_LOGOUT_CHANNEL, \"_\").concat(this.instanceId), broadcastChannelOptions);\n    logoutChannel.addEventListener(\"message\", ev => {\n      var _ev$data;\n\n      log.info(\"received logout message\", ev);\n\n      if (!ev.error && ((_ev$data = ev.data) === null || _ev$data === void 0 ? void 0 : _ev$data.type) === BROADCAST_CHANNELS_MSGS.LOGOUT) {\n        log.info(\"Logging Out\");\n        this.handleLogout();\n      }\n    });\n  }\n\n  importAccountChannel() {\n    const walletAccountImportChannel = new BroadcastChannel(\"\".concat(BROADCAST_CHANNELS.WALLET_ACCOUNT_IMPORT_CHANNEL, \"_\").concat(this.instanceId), broadcastChannelOptions);\n    walletAccountImportChannel.addEventListener(\"message\", ev => {\n      var _ev$data2;\n\n      if (!ev.error && ((_ev$data2 = ev.data) === null || _ev$data2 === void 0 ? void 0 : _ev$data2.type) === BROADCAST_CHANNELS_MSGS.ACCOUNT_IMPORTED) {\n        var _ev$data3;\n\n        this.handleAccountImport((_ev$data3 = ev.data) === null || _ev$data3 === void 0 ? void 0 : _ev$data3.privKey);\n      }\n    });\n  }\n\n  networkChangeChannel() {\n    const walletAccountImportChannel = new BroadcastChannel(\"\".concat(BROADCAST_CHANNELS.WALLET_NETWORK_CHANGE_CHANNEL, \"_\").concat(this.instanceId), broadcastChannelOptions);\n    walletAccountImportChannel.addEventListener(\"message\", ev => {\n      var _ev$data4;\n\n      if (!ev.error && ((_ev$data4 = ev.data) === null || _ev$data4 === void 0 ? void 0 : _ev$data4.type) === BROADCAST_CHANNELS_MSGS.NETWORK_CHANGE) {\n        var _ev$data5;\n\n        this.handleNetworkChange((_ev$data5 = ev.data) === null || _ev$data5 === void 0 ? void 0 : _ev$data5.network);\n      }\n    });\n  }\n\n  themeChangedChannel() {\n    const walletAccountImportChannel = new BroadcastChannel(\"\".concat(BROADCAST_CHANNELS.THEME_CHANGE, \"_\").concat(this.instanceId), broadcastChannelOptions);\n    walletAccountImportChannel.addEventListener(\"message\", ev => {\n      var _ev$data6;\n\n      log.info({\n        ev\n      });\n\n      if (!ev.error && ((_ev$data6 = ev.data) === null || _ev$data6 === void 0 ? void 0 : _ev$data6.type) === BROADCAST_CHANNELS_MSGS.SET_THEME) {\n        var _ev$data7;\n\n        this.handleThemeChange((_ev$data7 = ev.data) === null || _ev$data7 === void 0 ? void 0 : _ev$data7.theme);\n      }\n    });\n  }\n\n  selectedAddressChangeChannel() {\n    const walletAccountImportChannel = new BroadcastChannel(\"\".concat(BROADCAST_CHANNELS.WALLET_SELECTED_ADDRESS_CHANNEL, \"_\").concat(this.instanceId), broadcastChannelOptions);\n    walletAccountImportChannel.addEventListener(\"message\", ev => {\n      var _ev$data8;\n\n      if (!ev.error && ((_ev$data8 = ev.data) === null || _ev$data8 === void 0 ? void 0 : _ev$data8.type) === BROADCAST_CHANNELS_MSGS.SELECTED_ADDRESS_CHANGE) {\n        var _ev$data9;\n\n        this.handleSelectedAddressChange((_ev$data9 = ev.data) === null || _ev$data9 === void 0 ? void 0 : _ev$data9.selectedAddress);\n      }\n    });\n  }\n\n}\n\n/**\n * PopupWithBcHandler is a PopupHandler which uses broadcast channel to communicate with the popup window.\n */\n\nclass PopupWithBcHandler extends PopupHandler {\n  constructor(_ref) {\n    let {\n      config,\n      state,\n      instanceId\n    } = _ref;\n    super({\n      config,\n      state\n    });\n\n    _defineProperty(this, \"bc\", void 0);\n\n    this.bc = new BroadcastChannel(instanceId, broadcastChannelOptions);\n  }\n  /**\n   * Receives the data from popup window and closes the window\n   * @param successExtraFn - Extra function to be called after the data is received\n   * @returns The data to be received\n   */\n\n\n  handle(successExtraFn) {\n    return new Promise((resolve, reject) => {\n      const closeListener = () => {\n        this.bc.close();\n        reject(new UserError(\"user closed popup\"));\n        this.removeListener(\"close\", closeListener);\n      };\n\n      this.on(\"close\", closeListener);\n      this.bc.addEventListener(\"message\", async ev => {\n        log.info(ev, \"receiving data on channel: \".concat(this.bc.name));\n\n        try {\n          const {\n            error,\n            data\n          } = ev;\n\n          if (error) {\n            reject(new Error(error));\n            return;\n          }\n\n          if (successExtraFn) await successExtraFn.call(this, data);\n          resolve(data);\n        } catch (error) {\n          reject(error);\n        } finally {\n          this.bc.close();\n          this.close();\n        }\n      });\n      this.open().then(() => {\n        log.info(\"opened window \".concat(this.bc.name)); // Opened window. yay.  let the bc events do their job\n\n        return undefined;\n      }).catch(err => {\n        log.error(err, \"something went wrong while opening window\");\n        reject(err);\n      });\n    });\n  }\n  /**\n   * Use this if we have to send large payloads which don't fit in query/hash params.\n   * Waits for ack that popup window is ready to receive data.\n   * Receives the data from popup window and closes the window\n   * @param payload - The data to be sent to the popup window once we have ack that window is ready to receive data\n   * @param successExtraFn - Extra function to be called after the data is received\n   * @returns The data to be received\n   */\n\n\n  handleWithHandshake(payload, successExtraFn) {\n    return new Promise((resolve, reject) => {\n      const closeListener = () => {\n        this.bc.close();\n        reject(new UserError(\"user closed popup\"));\n        this.removeListener(\"close\", closeListener);\n      };\n\n      this.on(\"close\", closeListener);\n      this.bc.addEventListener(\"message\", async ev => {\n        try {\n          log.info(ev, \"receiving data on channel: \".concat(this.bc.name));\n          const {\n            error,\n            data\n          } = ev;\n\n          if (error) {\n            reject(new Error(error));\n            return;\n          } // Do handshake\n\n\n          const {\n            type = \"\"\n          } = data;\n\n          if (type === POPUP_LOADED) {\n            // Hack with generic to use the same type for both send and receive\n            await this.bc.postMessage({\n              data: payload\n            });\n          } else if (type === POPUP_RESULT) {\n            if (successExtraFn) await successExtraFn.call(this, data);\n            resolve(data); // Must only close the bc after result is done\n\n            this.bc.close();\n            this.close();\n          }\n        } catch (error) {\n          reject(error);\n          this.bc.close();\n          this.close();\n        }\n      });\n      this.open().then(() => {\n        log.info(\"opened window \".concat(this.bc.name)); // Opened window. yay.  let the bc events do their job\n\n        return undefined;\n      }).catch(err => {\n        log.error(err, \"something went wrong while opening window\");\n        reject(err);\n      });\n    });\n  }\n\n}\n\nclass RedirectHandler {\n  constructor() {\n    _defineProperty(this, \"error\", void 0);\n\n    _defineProperty(this, \"finalQueryParams\", {});\n\n    _defineProperty(this, \"instanceParameters\", void 0);\n\n    _defineProperty(this, \"hashParameters\", void 0);\n\n    const {\n      hash\n    } = window.location;\n    const queryParameters = new URLSearchParams(window.location.search);\n    queryParameters.forEach((value, key) => {\n      this.finalQueryParams[key] = value;\n    });\n    const {\n      error,\n      instanceParameters,\n      hashParameters\n    } = handleRedirectParameters(hash, this.finalQueryParams);\n    this.error = error;\n    this.instanceParameters = instanceParameters;\n    this.hashParameters = hashParameters;\n  }\n\n  async handle() {\n    return new Promise((resolve, reject) => {\n      const {\n        finalQueryParams,\n        instanceParameters,\n        hashParameters,\n        error\n      } = this;\n      let bc;\n\n      try {\n        if (!finalQueryParams.windowId) {\n          bc = new BroadcastChannel(\"\".concat(BROADCAST_CHANNELS.REDIRECT_CHANNEL, \"_\").concat(instanceParameters.instanceId), broadcastChannelOptions);\n          bc.addEventListener(\"message\", async ev => {\n            if (ev.error) {\n              reject(ev.error);\n              window.close();\n            } else {\n              resolve();\n              bc.close();\n              log.info(\"posted\", {\n                finalQueryParams,\n                hashParameters,\n                instanceParameters\n              });\n            }\n          });\n          bc.postMessage({\n            data: {\n              instanceParams: instanceParameters,\n              hashParams: hashParameters,\n              queryParams: finalQueryParams\n            },\n            error\n          });\n          setTimeout(() => {\n            resolve();\n            window.location.href = window.location.origin + window.location.search + window.location.hash;\n          }, 5000);\n        } else {\n          bc = new BroadcastChannel(\"\".concat(finalQueryParams.windowId), broadcastChannelOptions);\n          bc.addEventListener(\"message\", async ev => {\n            const {\n              url,\n              message\n            } = ev.data;\n\n            if (url) {\n              resolve();\n              window.location.href = url;\n            } else if (message === SETUP_COMPLETE) {\n              await bc.postMessage({\n                data: {\n                  windowId: finalQueryParams.windowId,\n                  message: POPUP_LOADED\n                }\n              });\n            }\n\n            if (ev.error && ev.error !== \"\") {\n              log.error(ev.error);\n              resolve();\n              bc.close();\n            }\n          });\n        }\n      } catch (err) {\n        log.info(err, \"something went wrong\");\n        reject(err);\n        if (bc) bc.close();\n        window.close();\n      }\n    });\n  }\n\n}\n\nconst ACTIVITY_ACTION = {\n  ACTIVITY_ACTION_ALL: \"walletActivity.allTransactions\",\n  ACTIVITY_ACTION_SEND: \"walletActivity.send\",\n  ACTIVITY_ACTION_RECEIVE: \"walletActivity.receive\",\n  ACTIVITY_ACTION_TOPUP: \"walletActivity.topup\"\n};\nconst ACCOUNT_CATEGORY = {\n  NORMAL: \"normal\",\n  THRESHOLD: \"threshold\",\n  IMPORTED: \"imported\"\n};\n\nfunction ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nconst DEFAULT_INTERVAL = 180 * 1000;\nconst DEFAULT_PREFERENCES = {\n  selectedCurrency: \"USD\",\n  theme: \"dark\",\n  locale: \"en-US\",\n  accountType: ACCOUNT_CATEGORY.NORMAL,\n  contacts: [],\n  jwtToken: \"\",\n  fetchedPastTx: [],\n  pastTransactions: [],\n  paymentTx: [],\n  defaultPublicAddress: \"\",\n  customTokens: [],\n  customNfts: [],\n  crashReport: true,\n  userInfo: {\n    aggregateVerifier: \"\",\n    email: \"\",\n    name: \"\",\n    profileImage: \"\",\n    typeOfLogin: LOGIN_PROVIDER.GOOGLE,\n    verifier: \"\",\n    verifierId: \"\"\n  }\n};\n/**\n * Controller that stores shared settings and exposes convenience methods\n */\n\nclass BasePreferencesController extends BaseController {\n  /**\n   * Name of this controller used during composition\n   */\n\n  /**\n   * Creates a PreferencesController instance\n   *\n   * @param config - Initial options used to configure this controller\n   * @param state - Initial state to set on this controller\n   */\n  constructor(_ref) {\n    let {\n      config,\n      state,\n      defaultPreferences,\n      signAuthMessage\n    } = _ref;\n    super({\n      config,\n      state\n    });\n\n    _defineProperty(this, \"name\", \"PreferencesController\");\n\n    _defineProperty(this, \"iframeOrigin\", void 0);\n\n    _defineProperty(this, \"signAuthMessage\", void 0);\n\n    _defineProperty(this, \"defaultPreferences\", void 0);\n\n    if (!config.api) {\n      throw new Error(\"PreferencesController - no api specified in config.\");\n    }\n\n    this.defaultState = {\n      identities: {},\n      selectedAddress: \"\",\n      lastErrorMessage: \"\",\n      lastSuccessMessage: \"\"\n    };\n    this.defaultConfig = {\n      api: config.api,\n      pollInterval: DEFAULT_INTERVAL\n    };\n    this.initialize();\n    this.defaultPreferences = _objectSpread$1(_objectSpread$1({}, DEFAULT_PREFERENCES), defaultPreferences);\n    this.signAuthMessage = signAuthMessage;\n  }\n\n  setIframeOrigin(origin) {\n    this.iframeOrigin = origin;\n  }\n\n  getAddressState(address) {\n    const selectedAddress = address || this.state.selectedAddress;\n    return this.state.identities[selectedAddress];\n  }\n  /**\n   * Sets selected address\n   *\n   * @param selectedAddress - casper account hash\n   */\n\n\n  setSelectedAddress(selectedAddress) {\n    this.update({\n      selectedAddress\n    });\n  }\n\n  async getUser(address) {\n    const user = await get(\"\".concat(this.config.api, \"/user?fetchTx=false\"), this.headers(address), {\n      useAPIKey: true\n    });\n    return user.data;\n  }\n\n  async createUser(params) {\n    const {\n      selectedCurrency,\n      theme,\n      verifier,\n      verifierId,\n      locale,\n      address,\n      idToken\n    } = params;\n    const userPayload = {\n      default_currency: selectedCurrency,\n      theme,\n      verifier,\n      verifier_id: verifierId,\n      locale,\n      idToken\n    };\n    await post(\"\".concat(this.config.api, \"/user\"), userPayload, this.headers(address), {\n      useAPIKey: true\n    });\n    this.updateState({\n      theme,\n      defaultPublicAddress: address,\n      selectedCurrency,\n      locale\n    }, address);\n  }\n\n  async storeUserLogin(params) {\n    const {\n      verifierId,\n      verifier,\n      options,\n      address,\n      idToken\n    } = params;\n\n    if (!options.rehydrate) {\n      const browser = bowser.getParser(window.navigator.userAgent);\n      const specialBrowser = getCustomDeviceInfo();\n      const recordLoginPayload = {\n        os: browser.getOSName(),\n        os_version: browser.getOSVersion() || \"unidentified\",\n        browser: (specialBrowser === null || specialBrowser === void 0 ? void 0 : specialBrowser.browser) || browser.getBrowserName() || \"unidentified\",\n        browser_version: browser.getBrowserVersion() || \"unidentified\",\n        platform: browser.getPlatform().type || \"desktop\",\n        hostname: this.iframeOrigin,\n        verifier,\n        verifier_id: verifierId,\n        idToken\n      };\n      await post(\"\".concat(this.config.api, \"/user/recordLogin\"), recordLoginPayload, this.headers(address), {\n        useAPIKey: true\n      });\n    }\n  }\n\n  async setCrashReport(isEnabled) {\n    var _this$getAddressState;\n\n    if (isEnabled === ((_this$getAddressState = this.getAddressState()) === null || _this$getAddressState === void 0 ? void 0 : _this$getAddressState.crashReport)) return true;\n\n    try {\n      await patch(\"\".concat(this.config.api, \"/user\"), {\n        enable_crash_reporter: isEnabled\n      }, this.headers(), {\n        useAPIKey: true\n      });\n      this.updateState({\n        crashReport: isEnabled\n      });\n      return true;\n    } catch (error) {\n      log.error(error);\n      return false;\n    }\n  }\n\n  async setUserTheme(theme) {\n    var _this$getAddressState2;\n\n    if (theme === ((_this$getAddressState2 = this.getAddressState()) === null || _this$getAddressState2 === void 0 ? void 0 : _this$getAddressState2.theme)) return true;\n\n    try {\n      await patch(\"\".concat(this.config.api, \"/user\"), {\n        theme\n      }, this.headers(), {\n        useAPIKey: true\n      });\n      this.updateState({\n        theme\n      });\n      return true;\n    } catch (error) {\n      log.error(error);\n      return false;\n    }\n  }\n\n  async setUserLocale(locale) {\n    var _this$getAddressState3;\n\n    if (locale === ((_this$getAddressState3 = this.getAddressState()) === null || _this$getAddressState3 === void 0 ? void 0 : _this$getAddressState3.locale)) return;\n\n    try {\n      await patch(\"\".concat(this.config.api, \"/user\"), {\n        locale\n      }, this.headers(), {\n        useAPIKey: true\n      });\n      this.updateState({\n        locale\n      });\n      return true;\n    } catch (error) {\n      log.error(\"unable to set locale\", error);\n      return false;\n    }\n  }\n\n  async setSelectedCurrency(payload) {\n    var _this$getAddressState4;\n\n    if (payload.selectedCurrency === ((_this$getAddressState4 = this.getAddressState()) === null || _this$getAddressState4 === void 0 ? void 0 : _this$getAddressState4.selectedCurrency)) return true;\n\n    try {\n      await patch(\"\".concat(this.config.api, \"/user\"), {\n        default_currency: payload.selectedCurrency\n      }, this.headers(), {\n        useAPIKey: true\n      });\n      this.updateState({\n        selectedCurrency: payload.selectedCurrency\n      });\n      return true;\n    } catch (error) {\n      log.error(error);\n      return false;\n    }\n  }\n\n  async addContact(contact) {\n    try {\n      var _this$getAddressState5;\n\n      const response = await post(\"\".concat(this.config.api, \"/contact\"), contact, this.headers(), {\n        useAPIKey: true\n      });\n      this.updateState({\n        contacts: [...(((_this$getAddressState5 = this.getAddressState()) === null || _this$getAddressState5 === void 0 ? void 0 : _this$getAddressState5.contacts) || []), response.data]\n      });\n      return true;\n    } catch (error) {\n      log.error(\"unable to add contact\", error);\n      return false;\n    }\n  }\n\n  async deleteContact(contactId) {\n    try {\n      var _this$getAddressState6;\n\n      const response = await remove(\"\".concat(this.config.api, \"/contact/\").concat(contactId), {}, this.headers(), {\n        useAPIKey: true\n      });\n      const finalContacts = (_this$getAddressState6 = this.getAddressState()) === null || _this$getAddressState6 === void 0 ? void 0 : _this$getAddressState6.contacts.filter(contact => contact.id !== response.data.id);\n      if (finalContacts) this.updateState({\n        contacts: [...finalContacts]\n      });\n      return true;\n    } catch (error) {\n      log.error(\"unable to delete contact\", error);\n      return false;\n    }\n  }\n\n  async revokeDiscord(idToken) {\n    try {\n      const resp = await post(\"\".concat(this.config.api, \"/revoke/discord\"), {\n        token: idToken\n      }, this.headers(), {\n        useAPIKey: true\n      });\n      log.info(resp);\n    } catch (error) {\n      log.error(error);\n    }\n  }\n\n  async patchPastTx(body, address) {\n    try {\n      const response = await patch(\"\".concat(this.config.api, \"/transaction\"), body, this.headers(address), {\n        useAPIKey: true\n      });\n      log.info(\"successfully patched\", response);\n    } catch (error) {\n      log.error(\"unable to patch tx\", error);\n    }\n  }\n\n  async postPastTx(tx, address) {\n    try {\n      const response = await post(\"\".concat(this.config.api, \"/transaction\"), tx, this.headers(address), {\n        useAPIKey: true\n      });\n      log.info(\"successfully posted tx\", response);\n      return response;\n    } catch (error) {\n      log.error(error, \"unable to insert transaction\");\n    }\n  }\n\n  async getWalletOrders(address) {\n    try {\n      const response = await get(\"\".concat(this.config.api, \"/transaction\"), this.headers(address), {\n        useAPIKey: true\n      });\n      return response.success ? response.data ? response.data : [] : [];\n    } catch (error) {\n      log.error(\"unable to get wallet orders tx\", error);\n      return [];\n    }\n  }\n\n  async getTopUpOrders(address) {\n    try {\n      const response = await get(\"\".concat(this.config.commonApiHost, \"/transaction\"), this.headers(address), {\n        useAPIKey: true\n      });\n      return response.data || [];\n    } catch (error) {\n      log.error(\"unable to fetch past Top up orders\", error);\n    }\n  }\n\n  async getBillBoardData() {\n    try {\n      const response = await get(\"\".concat(this.config.api, \"/billboard\"), this.headers(), {\n        useAPIKey: true\n      });\n      return response.success ? response.data : [];\n    } catch (error) {\n      log.error(\"unable to get billboard data\", error);\n      return [];\n    }\n  }\n\n  async getMessageForSigning(publicAddress) {\n    const response = await post(\"\".concat(this.config.api, \"/auth/message\"), {\n      public_address: publicAddress\n    }, {}, {\n      useAPIKey: true\n    });\n    return response.message;\n  }\n\n  async getTwitterId(payload) {\n    const res = await get(\"\".concat(this.config.api, \"/twitter?screen_name=\").concat(payload.nick), this.headers(), {\n      useAPIKey: true\n    });\n    return \"\".concat(payload.typeOfLogin.toLowerCase(), \"|\").concat(res.data.toString());\n  }\n\n  async sendEmail(payload) {\n    return post(\"\".concat(this.config.api, \"/transaction/sendemail\"), payload.emailObject, this.headers(), {\n      useAPIKey: true\n    });\n  }\n\n  async refreshJwt() {\n    const address = this.state.selectedAddress;\n    const messageToSign = await this.getMessageForSigning(address);\n    if (!messageToSign.startsWith(this.config.signInPrefix)) throw new Error(\"Cannot sign on invalid message\");\n    const signedMessage = this.signAuthMessage(address, messageToSign);\n    const response = await post(\"\".concat(this.config.api, \"/auth/verify\"), {\n      public_address: address,\n      signed_message: signedMessage\n    }, {}, {\n      useAPIKey: true\n    });\n    this.updateState({\n      jwtToken: response.token\n    }, address);\n  }\n\n  async getDappList() {\n    try {\n      const response = await get(\"\".concat(this.config.api, \"/dapps\"), this.headers(), {\n        useAPIKey: true\n      });\n      return response.success ? response.data : [];\n    } catch (error) {\n      log.error(\"unable to get billboard data\", error);\n      return [];\n    }\n  }\n\n  async init(address, userInfo, jwtToken) {\n    let response = {\n      token: jwtToken\n    };\n    if (this.getAddressState(address)) return;\n\n    if (!jwtToken) {\n      const messageToSign = await this.getMessageForSigning(address);\n      if (!messageToSign.startsWith(this.config.signInPrefix)) throw new Error(\"Cannot sign on invalid message\");\n      const signedMessage = this.signAuthMessage(address, messageToSign);\n      response = await post(\"\".concat(this.config.api, \"/auth/verify\"), {\n        public_address: address,\n        signed_message: signedMessage\n      }, {}, {\n        useAPIKey: true\n      });\n    }\n\n    this.updateState({\n      jwtToken: response.token,\n      userInfo\n    }, address);\n  }\n\n  updateState(preferences, address) {\n    const selectedAddress = address || this.state.selectedAddress;\n    const currentState = this.getAddressState(selectedAddress) || cloneDeep(this.defaultPreferences);\n\n    const mergedState = _objectSpread$1(_objectSpread$1({}, currentState), preferences);\n\n    this.update({\n      identities: _objectSpread$1(_objectSpread$1({}, this.state.identities), {}, {\n        [selectedAddress]: mergedState\n      })\n    });\n    return mergedState;\n  }\n\n  headers(address) {\n    var _this$getAddressState7;\n\n    const selectedAddress = address || this.state.selectedAddress;\n    return getHeaders(((_this$getAddressState7 = this.getAddressState(selectedAddress)) === null || _this$getAddressState7 === void 0 ? void 0 : _this$getAddressState7.jwtToken) || \"\");\n  }\n\n}\n\n/**\n * The status of the transaction. Each status represents the state of the transaction internally\n * in the wallet. Some of these correspond with the state of the transaction on the network, but\n * some are wallet-specific.\n */\nvar TransactionStatus;\n\n(function (TransactionStatus) {\n  TransactionStatus[\"approved\"] = \"approved\";\n  TransactionStatus[\"cancelled\"] = \"cancelled\";\n  TransactionStatus[\"confirmed\"] = \"confirmed\";\n  TransactionStatus[\"failed\"] = \"failed\";\n  TransactionStatus[\"finalized\"] = \"finalized\";\n  TransactionStatus[\"processed\"] = \"processed\";\n  TransactionStatus[\"rejected\"] = \"rejected\";\n  TransactionStatus[\"signed\"] = \"signed\";\n  TransactionStatus[\"submitted\"] = \"submitted\";\n  TransactionStatus[\"unapproved\"] = \"unapproved\";\n  TransactionStatus[\"dropped\"] = \"dropped\";\n  TransactionStatus[\"expired\"] = \"expired\";\n})(TransactionStatus || (TransactionStatus = {}));\n\nconst TRANSACTION_TYPES = {\n  CONTRACT_INTERACTION: \"contractInteraction\",\n  DEPLOY_CONTRACT: \"contractDeployment\",\n  WASM_BASED_DEPLOY: \"wasmBasedDeploy\",\n  STANDARD_TRANSACTION: \"transaction\",\n  STANDARD_PAYMENT_TRANSACTION: \"payment_transaction\" // specific to chains like solana and casper\n\n};\nconst TX_EVENTS = {\n  TX_WARNING: \"tx:warning\",\n  TX_ERROR: \"tx:error\",\n  TX_FAILED: \"tx:failed\",\n  TX_CONFIRMED: \"tx:confirmed\",\n  TX_DROPPED: \"tx:dropped\",\n  TX_EXPIRED: \"tx:expired\",\n  TX_STATUS_UPDATE: \"tx:status_update\",\n  TX_UNAPPROVED: \"tx:unapproved\"\n};\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass BaseTransactionStateManager extends BaseController {\n  constructor(_ref) {\n    let {\n      config,\n      state,\n      getCurrentChainId\n    } = _ref;\n    super({\n      config,\n      state\n    });\n\n    _defineProperty(this, \"getCurrentChainId\", void 0);\n\n    this.defaultConfig = {\n      txHistoryLimit: 40\n    };\n    this.defaultState = {\n      transactions: {},\n      unapprovedTxs: {},\n      currentNetworkTxsList: []\n    };\n    this.initialize();\n    this.getCurrentChainId = getCurrentChainId;\n  }\n\n  getUnapprovedTxList() {\n    const chainId = this.getCurrentChainId();\n    return pickBy(this.state.transactions, transaction => transaction.status === TransactionStatus.unapproved && transactionMatchesNetwork(transaction, chainId));\n  }\n\n  getTransaction(txId) {\n    const {\n      transactions\n    } = this.state;\n    return transactions[txId];\n  }\n\n  updateTransaction(txMeta) {\n    // commit txMeta to state\n    const txId = txMeta.id;\n    txMeta.updated_at = new Date().toISOString();\n    this.update({\n      transactions: _objectSpread(_objectSpread({}, this.state.transactions), {}, {\n        [txId]: txMeta\n      })\n    });\n  }\n\n  setTxStatusRejected(txId) {\n    this._setTransactionStatus(txId, TransactionStatus.rejected);\n\n    this._deleteTransaction(txId);\n  }\n  /**\n   * The implementing controller can override this functionality and add custom logic + call super.()\n   */\n\n\n  setTxStatusUnapproved(txId) {\n    this._setTransactionStatus(txId, TransactionStatus.unapproved);\n  }\n\n  setTxStatusApproved(txId) {\n    this._setTransactionStatus(txId, TransactionStatus.approved);\n  }\n\n  setTxStatusSigned(txId) {\n    this._setTransactionStatus(txId, TransactionStatus.signed);\n  }\n\n  setTxStatusSubmitted(txId) {\n    this._setTransactionStatus(txId, TransactionStatus.submitted);\n  }\n\n  setTxStatusDropped(txId) {\n    this._setTransactionStatus(txId, TransactionStatus.dropped);\n  }\n\n  setTxStatusExpired(txId) {\n    this._setTransactionStatus(txId, TransactionStatus.expired);\n  }\n\n  setTxStatusConfirmed(txId) {\n    this._setTransactionStatus(txId, TransactionStatus.confirmed);\n  }\n\n  setTxStatusFailed(txId, error_) {\n    const error = !error_ ? new Error(\"Internal torus failure\") : error_;\n    const txMeta = this.getTransaction(txId);\n    txMeta.error = error;\n    this.updateTransaction(txMeta);\n\n    this._setTransactionStatus(txId, TransactionStatus.failed);\n  }\n  /**\n   * Method to determine if the transaction is in a final state\n   * @param status - Transaction status\n   * @returns boolean if the transaction is in a final state\n   */\n\n\n  isFinalState(status) {\n    return status === TransactionStatus.rejected || status === TransactionStatus.submitted || status === TransactionStatus.confirmed || status === TransactionStatus.failed || status === TransactionStatus.cancelled || status === TransactionStatus.expired;\n  }\n  /**\n   * Filters out the unapproved transactions from state\n   */\n\n\n  clearUnapprovedTxs() {\n    this.update({\n      transactions: omitBy(this.state.transactions, transaction => transaction.status === TransactionStatus.unapproved)\n    });\n  }\n  /**\n   * will append new transactions to old txns.\n   */\n\n\n  _addTransactionsToState(transactions) {\n    this.update({\n      transactions: transactions.reduce((result, newTx) => {\n        result[newTx.id] = newTx;\n        return result;\n      }, this.state.transactions)\n    });\n  }\n  /**\n   * will set new txns, override existing if any in state.\n   */\n\n\n  _setTransactionsToState(transactions) {\n    this.update({\n      transactions: transactions.reduce((result, newTx) => {\n        result[newTx.id] = newTx;\n        return result;\n      }, {})\n    });\n  }\n\n  _deleteTransaction(targetTransactionId) {\n    const {\n      transactions\n    } = this.state;\n    delete transactions[targetTransactionId];\n    this.update({\n      transactions\n    });\n  }\n\n  _deleteTransactions(targetTransactionIds) {\n    const {\n      transactions\n    } = this.state;\n    targetTransactionIds.forEach(transactionId => {\n      delete transactions[transactionId];\n    });\n    this.update({\n      transactions\n    });\n  }\n\n  _setTransactionStatus(txId, status) {\n    const txMeta = this.getTransaction(txId);\n\n    if (!txMeta) {\n      return;\n    }\n\n    txMeta.status = status; // only updating status so no validation required on txn.\n\n    this.updateTransaction(txMeta);\n    this.emit(TX_EVENTS.TX_STATUS_UPDATE, {\n      txId,\n      status\n    });\n\n    if (this.isFinalState(status)) {\n      this.emit(\"\".concat(txMeta.id, \":finished\"), txMeta);\n    } else {\n      this.emit(\"\".concat(txMeta.id, \":\").concat(status), txId);\n    }\n  }\n\n}\n\nexport { ACCOUNT_CATEGORY, ACTIVITY_ACTION, ACTIVITY_ACTION_ALL, ACTIVITY_ACTION_BURN, ACTIVITY_ACTION_RECEIVE, ACTIVITY_ACTION_SEND, ACTIVITY_ACTION_TOPUP, ACTIVITY_PERIOD_ALL, ACTIVITY_PERIOD_MONTH_ONE, ACTIVITY_PERIOD_MONTH_SIX, ACTIVITY_PERIOD_WEEK_ONE, ACTIVITY_STATUS_CANCELLED, ACTIVITY_STATUS_CANCELLING, ACTIVITY_STATUS_PENDING, ACTIVITY_STATUS_SUCCESSFUL, ACTIVITY_STATUS_UNSUCCESSFUL, BROADCAST_CHANNELS, BROADCAST_CHANNELS_MSGS, BaseBlockTracker, BaseController, BaseCurrencyController, BaseEmbedController, BaseKeyringController, BasePreferencesController, BaseTransactionStateManager, BroadcastChannelHandler, COMMUNICATION_JRPC_METHODS, COMMUNICATION_NOTIFICATIONS, CommunicationWindowManager, DEFAULT_PREFERENCES, FEATURES_CONFIRM_WINDOW, FEATURES_DEFAULT_POPUP_WINDOW, FEATURES_DEFAULT_WALLET_WINDOW, FEATURES_PROVIDER_CHANGE_WINDOW, LOGIN_PROVIDER, PAYMENT_PROVIDER, POPUP_LOADED, POPUP_RESULT, PROVIDER_JRPC_METHODS, PROVIDER_NOTIFICATIONS, PopupHandler, PopupStoreChannel, PopupWithBcHandler, RedirectHandler, SETUP_COMPLETE, StreamWindow, TRANSACTION_TYPES, TX_EVENTS, TransactionStatus, UserError, addressSlicer, broadcastChannelOptions, concatSig, createChangeProviderMiddlewareMiddleware, createCommunicationMiddleware, createEventEmitterProxy, createFetchConfigFromReq, createFetchMiddleware, createGenericJRPCMiddleware, createLoggerMiddleware, createOriginMiddleware, createRandomId, createSwappableProxy, createTopupMiddleware, formatDate, formatSmallNumbers, formatTime, getCustomDeviceInfo, getHeaders, getPopupFeatures, getTxStatusText, handleRedirectParameters, hashMessage, intToHex, padWithZeroes, providerAsMiddleware, providerFromEngine, providerFromMiddleware, randomId, signMessage, significantDigits, sleep, timeout$1 as timeout, transactionMatchesNetwork };\n//# sourceMappingURL=baseControllers.esm.js.map\n",null,null,null,null,null,null,null,null,"/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (root, definition) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        define(definition);\n    } else if (typeof module === 'object' && module.exports) {\n        module.exports = definition();\n    } else {\n        root.log = definition();\n    }\n}(this, function () {\n    \"use strict\";\n\n    // Slightly dubious tricks to cut down minimized file size\n    var noop = function() {};\n    var undefinedType = \"undefined\";\n    var isIE = (typeof window !== undefinedType) && (typeof window.navigator !== undefinedType) && (\n        /Trident\\/|MSIE /.test(window.navigator.userAgent)\n    );\n\n    var logMethods = [\n        \"trace\",\n        \"debug\",\n        \"info\",\n        \"warn\",\n        \"error\"\n    ];\n\n    // Cross-browser bind equivalent that works at least back to IE6\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === 'function') {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\n                };\n            }\n        }\n    }\n\n    // Trace() doesn't print the message in IE, so for that case we need to wrap it\n    function traceForIE() {\n        if (console.log) {\n            if (console.log.apply) {\n                console.log.apply(console, arguments);\n            } else {\n                // In old IE, native console methods themselves don't have apply().\n                Function.prototype.apply.apply(console.log, [console, arguments]);\n            }\n        }\n        if (console.trace) console.trace();\n    }\n\n    // Build the best logging method possible for this env\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\n    function realMethod(methodName) {\n        if (methodName === 'debug') {\n            methodName = 'log';\n        }\n\n        if (typeof console === undefinedType) {\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (methodName === 'trace' && isIE) {\n            return traceForIE;\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, 'log');\n        } else {\n            return noop;\n        }\n    }\n\n    // These private functions always need `this` to be set properly\n\n    function replaceLoggingMethods(level, loggerName) {\n        /*jshint validthis:true */\n        for (var i = 0; i < logMethods.length; i++) {\n            var methodName = logMethods[i];\n            this[methodName] = (i < level) ?\n                noop :\n                this.methodFactory(methodName, level, loggerName);\n        }\n\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n    }\n\n    // In old IE versions, the console isn't present until you first open it.\n    // We build realMethod() replacements here that regenerate logging methods\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n        return function () {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this, level, loggerName);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n\n    // By default, we use closely bound real methods wherever possible, and\n    // otherwise we wait for a console to appear, and then try again.\n    function defaultMethodFactory(methodName, level, loggerName) {\n        /*jshint validthis:true */\n        return realMethod(methodName) ||\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n\n    function Logger(name, defaultLevel, factory) {\n      var self = this;\n      var currentLevel;\n      defaultLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\n\n      var storageKey = \"loglevel\";\n      if (typeof name === \"string\") {\n        storageKey += \":\" + name;\n      } else if (typeof name === \"symbol\") {\n        storageKey = undefined;\n      }\n\n      function persistLevelIfPossible(levelNum) {\n          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n\n          if (typeof window === undefinedType || !storageKey) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage[storageKey] = levelName;\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n          } catch (ignore) {}\n      }\n\n      function getPersistedLevel() {\n          var storedLevel;\n\n          if (typeof window === undefinedType || !storageKey) return;\n\n          try {\n              storedLevel = window.localStorage[storageKey];\n          } catch (ignore) {}\n\n          // Fallback to cookies if local storage gives us nothing\n          if (typeof storedLevel === undefinedType) {\n              try {\n                  var cookie = window.document.cookie;\n                  var location = cookie.indexOf(\n                      encodeURIComponent(storageKey) + \"=\");\n                  if (location !== -1) {\n                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n                  }\n              } catch (ignore) {}\n          }\n\n          // If the stored level is not valid, treat it as if nothing was stored.\n          if (self.levels[storedLevel] === undefined) {\n              storedLevel = undefined;\n          }\n\n          return storedLevel;\n      }\n\n      function clearPersistedLevel() {\n          if (typeof window === undefinedType || !storageKey) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage.removeItem(storageKey);\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC\";\n          } catch (ignore) {}\n      }\n\n      /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */\n\n      self.name = name;\n\n      self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\n          \"ERROR\": 4, \"SILENT\": 5};\n\n      self.methodFactory = factory || defaultMethodFactory;\n\n      self.getLevel = function () {\n          return currentLevel;\n      };\n\n      self.setLevel = function (level, persist) {\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n              level = self.levels[level.toUpperCase()];\n          }\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n              currentLevel = level;\n              if (persist !== false) {  // defaults to true\n                  persistLevelIfPossible(level);\n              }\n              replaceLoggingMethods.call(self, level, name);\n              if (typeof console === undefinedType && level < self.levels.SILENT) {\n                  return \"No console available for logging\";\n              }\n          } else {\n              throw \"log.setLevel() called with invalid level: \" + level;\n          }\n      };\n\n      self.setDefaultLevel = function (level) {\n          defaultLevel = level;\n          if (!getPersistedLevel()) {\n              self.setLevel(level, false);\n          }\n      };\n\n      self.resetLevel = function () {\n          self.setLevel(defaultLevel, false);\n          clearPersistedLevel();\n      };\n\n      self.enableAll = function(persist) {\n          self.setLevel(self.levels.TRACE, persist);\n      };\n\n      self.disableAll = function(persist) {\n          self.setLevel(self.levels.SILENT, persist);\n      };\n\n      // Initialize with the right level\n      var initialLevel = getPersistedLevel();\n      if (initialLevel == null) {\n          initialLevel = defaultLevel;\n      }\n      self.setLevel(initialLevel, false);\n    }\n\n    /*\n     *\n     * Top-level API\n     *\n     */\n\n    var defaultLogger = new Logger();\n\n    var _loggersByName = {};\n    defaultLogger.getLogger = function getLogger(name) {\n        if ((typeof name !== \"symbol\" && typeof name !== \"string\") || name === \"\") {\n          throw new TypeError(\"You must supply a name when creating a logger.\");\n        }\n\n        var logger = _loggersByName[name];\n        if (!logger) {\n          logger = _loggersByName[name] = new Logger(\n            name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n        }\n        return logger;\n    };\n\n    // Grab the current global log variable in case of overwrite\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if (typeof window !== undefinedType &&\n               window.log === defaultLogger) {\n            window.log = _log;\n        }\n\n        return defaultLogger;\n    };\n\n    defaultLogger.getLoggers = function getLoggers() {\n        return _loggersByName;\n    };\n\n    // ES6 default export, for compatibility\n    defaultLogger['default'] = defaultLogger;\n\n    return defaultLogger;\n}));\n","import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport merge from 'lodash.merge';\nimport logLevel, { levels } from 'loglevel';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nconst log = logLevel.getLogger(\"http-helpers\");\nlog.setLevel(levels.INFO);\nlet apiKey = \"torus-default\";\nlet embedHost = \"\"; // #region API Keys\n\nconst gatewayAuthHeader = \"x-api-key\";\nconst gatewayEmbedHostHeader = \"x-embed-host\";\nlet sentry = null;\nconst tracingOrigins = [];\nconst tracingPaths = [];\nfunction enableSentryTracing(_sentry, _tracingOrigins, _tracingPaths) {\n  sentry = _sentry;\n  tracingOrigins.push(..._tracingOrigins);\n  tracingPaths.push(..._tracingPaths);\n}\nfunction setEmbedHost(embedHost_) {\n  embedHost = embedHost_;\n}\nfunction clearEmbedHost() {\n  embedHost = \"\";\n}\nfunction getEmbedHost() {\n  return embedHost;\n}\nfunction setAPIKey(apiKey_) {\n  apiKey = apiKey_;\n}\nfunction clearAPIKey() {\n  apiKey = \"torus-default\";\n}\nfunction getAPIKey() {\n  return apiKey;\n} // #endregion\n\nfunction setLogLevel(level) {\n  log.setLevel(level);\n}\n\nasync function fetchAndTrace(url, init) {\n  let _url = null;\n\n  try {\n    _url = new URL(url);\n  } catch (error) {}\n\n  if (sentry && _url && (tracingOrigins.includes(_url.origin) || tracingPaths.includes(_url.pathname))) {\n    const transaction = sentry.startTransaction({\n      name: url\n    });\n    const span = transaction.startChild({\n      op: \"http\"\n    }); // This function returns a Span\n\n    const response = await fetch(url, init);\n    span.finish(); // Remember that only finished spans will be sent with the transaction\n\n    transaction.finish(); // Finishing the transaction will send it to Sentry\n\n    return response;\n  }\n\n  return fetch(url, init);\n}\n\nfunction getApiKeyHeaders() {\n  const headers = {};\n  if (apiKey) headers[gatewayAuthHeader] = apiKey;\n  if (embedHost) headers[gatewayEmbedHostHeader] = embedHost;\n  return headers;\n}\n\nfunction debugLogResponse(response) {\n  log.info(\"Response: \".concat(response.status, \" \").concat(response.statusText));\n  log.info(\"Url: \".concat(response.url));\n}\n\nconst promiseTimeout = (ms, promise) => {\n  const timeout = new Promise((resolve, reject) => {\n    const id = setTimeout(() => {\n      clearTimeout(id);\n      reject(new Error(\"Timed out in \".concat(ms, \"ms\")));\n    }, ms);\n  });\n  return Promise.race([promise, timeout]);\n};\nconst get = async function (url) {\n  let options_ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let customOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const defaultOptions = {\n    mode: \"cors\",\n    headers: {}\n  };\n\n  if (customOptions.useAPIKey) {\n    defaultOptions.headers = _objectSpread(_objectSpread({}, defaultOptions.headers), getApiKeyHeaders());\n  }\n\n  const options = merge(defaultOptions, options_, {\n    method: \"GET\"\n  });\n  const response = await fetchAndTrace(url, options);\n\n  if (response.ok) {\n    return response.json();\n  }\n\n  debugLogResponse(response);\n  throw response;\n};\nconst post = function (url) {\n  let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let options_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let customOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const defaultOptions = {\n    mode: \"cors\",\n    headers: {\n      \"Content-Type\": \"application/json; charset=utf-8\"\n    }\n  };\n\n  if (customOptions.useAPIKey) {\n    defaultOptions.headers = _objectSpread(_objectSpread({}, defaultOptions.headers), getApiKeyHeaders());\n  }\n\n  const options = merge(defaultOptions, options_, {\n    method: \"POST\"\n  }); // deep merge changes the structure of form data and url encoded data ,\n  // so we should not deepmerge body data\n\n  if (customOptions.isUrlEncodedData) {\n    // for multipart request browser/client will add multipart content type\n    // along with multipart boundary , so for multipart request send\n    // content-type: undefined or send with multipart boundary if already known\n    options.body = data; // If url encoded data, this must not be the content type\n\n    if (options.headers[\"Content-Type\"] === \"application/json; charset=utf-8\") delete options.headers[\"Content-Type\"];\n  } else {\n    options.body = JSON.stringify(data);\n  }\n\n  return promiseTimeout(customOptions.timeout || 60000, fetchAndTrace(url, options).then(response => {\n    if (response.ok) {\n      return response.json();\n    }\n\n    debugLogResponse(response);\n    throw response;\n  }));\n};\nconst patch = async function (url) {\n  let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let options_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let customOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const defaultOptions = {\n    mode: \"cors\",\n    headers: {\n      \"Content-Type\": \"application/json; charset=utf-8\"\n    }\n  }; // for multipart request browser/client will add multipart content type\n  // along with multipart boundary , so for multipart request send\n  // content-type: undefined or send with multipart boundary if already known\n\n  if (customOptions.useAPIKey) {\n    defaultOptions.headers = _objectSpread(_objectSpread({}, defaultOptions.headers), getApiKeyHeaders());\n  }\n\n  const options = merge(defaultOptions, options_, {\n    method: \"PATCH\"\n  }); // deep merge changes the structure of form data and url encoded data ,\n  // so we should not deepmerge body data\n\n  if (customOptions.isUrlEncodedData) {\n    // for multipart request browser/client will add multipart content type\n    // along with multipart boundary , so for multipart request send\n    // content-type: undefined or send with multipart boundary if already known\n    options.body = data; // If url encoded data, this must not be the content type\n\n    if (options.headers[\"Content-Type\"] === \"application/json; charset=utf-8\") delete options.headers[\"Content-Type\"];\n  } else {\n    options.body = JSON.stringify(data);\n  }\n\n  const response = await fetchAndTrace(url, options);\n\n  if (response.ok) {\n    return response.json();\n  }\n\n  debugLogResponse(response);\n  throw response;\n};\nconst put = async function (url) {\n  let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let options_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let customOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const defaultOptions = {\n    mode: \"cors\",\n    headers: {\n      \"Content-Type\": \"application/json; charset=utf-8\"\n    }\n  }; // for multipart request browser/client will add multipart content type\n  // along with multipart boundary , so for multipart request send\n  // content-type: undefined or send with multipart boundary if already known\n\n  if (customOptions.useAPIKey) {\n    defaultOptions.headers = _objectSpread(_objectSpread({}, defaultOptions.headers), getApiKeyHeaders());\n  }\n\n  const options = merge(defaultOptions, options_, {\n    method: \"PUT\"\n  }); // deep merge changes the structure of form data and url encoded data ,\n  // so we should not deepmerge body data\n\n  if (customOptions.isUrlEncodedData) {\n    // for multipart request browser/client will add multipart content type\n    // along with multipart boundary , so for multipart request send\n    // content-type: undefined or send with multipart boundary if already known\n    options.body = data; // If url encoded data, this must not be the content type\n\n    if (options.headers[\"Content-Type\"] === \"application/json; charset=utf-8\") delete options.headers[\"Content-Type\"];\n  } else {\n    options.body = JSON.stringify(data);\n  }\n\n  const response = await fetchAndTrace(url, options);\n\n  if (response.ok) {\n    return response.json();\n  }\n\n  debugLogResponse(response);\n  throw response;\n};\nconst remove = async function (url) {\n  let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let options_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let customOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const defaultOptions = {\n    mode: \"cors\",\n    headers: {\n      \"Content-Type\": \"application/json; charset=utf-8\"\n    }\n  }; // for multipart request browser/client will add multipart content type\n  // along with multipart boundary , so for multipart request send\n  // content-type: undefined or send with multipart boundary if already known\n\n  if (customOptions.useAPIKey) {\n    defaultOptions.headers = _objectSpread(_objectSpread({}, defaultOptions.headers), getApiKeyHeaders());\n  }\n\n  const options = merge(defaultOptions, options_, {\n    method: \"DELETE\"\n  });\n\n  if (customOptions.isUrlEncodedData) {\n    // for multipart request browser/client will add multipart content type\n    // along with multipart boundary , so for multipart request send\n    // content-type: undefined or send with multipart boundary if already known\n    options.body = data; // If url encoded data, this must not be the content type\n\n    if (options.headers[\"Content-Type\"] === \"application/json; charset=utf-8\") delete options.headers[\"Content-Type\"];\n  } else {\n    options.body = JSON.stringify(data);\n  }\n\n  const response = await fetchAndTrace(url, options);\n\n  if (response.ok) {\n    return response.json();\n  }\n\n  debugLogResponse(response);\n  throw response;\n};\nconst generateJsonRPCObject = (method, parameters) => ({\n  jsonrpc: \"2.0\",\n  method,\n  id: 10,\n  params: parameters\n});\nconst promiseRace = function (url, options) {\n  let timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 60000;\n  return Promise.race([get(url, options), new Promise((resolve, reject) => {\n    setTimeout(() => {\n      reject(new Error(\"timed out\"));\n    }, timeout);\n  })]);\n};\n\nexport { clearAPIKey, clearEmbedHost, enableSentryTracing, gatewayAuthHeader, gatewayEmbedHostHeader, generateJsonRPCObject, get, getAPIKey, getEmbedHost, patch, post, promiseRace, promiseTimeout, put, remove, setAPIKey, setEmbedHost, setLogLevel };\n//# sourceMappingURL=httpHelpers.esm.js.map\n","import Connector from \"@walletconnect/core\";\nimport * as cryptoLib from \"@walletconnect/iso-crypto\";\nclass WalletConnect extends Connector {\n    constructor(connectorOpts, pushServerOpts) {\n        super({\n            cryptoLib,\n            connectorOpts,\n            pushServerOpts,\n        });\n    }\n}\nexport default WalletConnect;\n//# sourceMappingURL=index.js.map","class NetworkMonitor {\n    constructor() {\n        this._eventEmitters = [];\n        if (typeof window !== \"undefined\" && typeof window.addEventListener !== \"undefined\") {\n            window.addEventListener(\"online\", () => this.trigger(\"online\"));\n            window.addEventListener(\"offline\", () => this.trigger(\"offline\"));\n        }\n    }\n    on(event, callback) {\n        this._eventEmitters.push({\n            event,\n            callback,\n        });\n    }\n    trigger(event) {\n        let eventEmitters = [];\n        if (event) {\n            eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === event);\n        }\n        eventEmitters.forEach((eventEmitter) => {\n            eventEmitter.callback();\n        });\n    }\n}\nexport default NetworkMonitor;\n//# sourceMappingURL=network.js.map","import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { createFetchMiddleware, providerFromEngine, signMessage } from '@toruslabs/base-controllers';\nimport { createScaffoldMiddleware, createAsyncMiddleware, mergeMiddleware, JRPCEngine } from '@toruslabs/openlogin-jrpc';\nimport { CHAIN_NAMESPACES, log, WalletInitializationError, WalletLoginError, isHexStrict, getChainConfig } from '@web3auth/base';\nimport { BaseProvider } from '@web3auth/base-provider';\nimport { ethErrors } from 'eth-rpc-errors';\nimport { TransactionFactory } from '@ethereumjs/tx';\nimport { SignTypedDataVersion, TYPED_MESSAGE_SCHEMA, typedSignatureHash, personalSign, signTypedData, getEncryptionPublicKey, decrypt } from '@metamask/eth-sig-util';\nimport { stripHexPrefix, isValidAddress, privateToAddress, addHexPrefix, BN } from 'ethereumjs-util';\nimport { get } from '@toruslabs/http-helpers';\nimport assert from 'assert';\nimport jsonschema from 'jsonschema';\nimport BigNumber, { BigNumber as BigNumber$1 } from 'bignumber.js';\nimport Common, { Hardfork } from '@ethereumjs/common';\n\nfunction ownKeys$5(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$5(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$5(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$5(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction resemblesAddress(str) {\n  // hex prefix 2 + 20 bytes\n  return str.length === 2 + 20 * 2;\n}\n\nfunction createWalletMiddleware(_ref) {\n  let {\n    getAccounts,\n    getPrivateKey,\n    processDecryptMessage,\n    processEncryptionPublicKey,\n    processEthSignMessage,\n    processPersonalMessage,\n    processTransaction,\n    processSignTransaction,\n    processTypedMessage,\n    processTypedMessageV3,\n    processTypedMessageV4\n  } = _ref;\n\n  if (!getAccounts) {\n    throw new Error(\"opts.getAccounts is required\");\n  } //\n  // utility\n  //\n\n  /**\n   * Validates the keyholder address, and returns a normalized (i.e. lowercase)\n   * copy of it.\n   *\n   * an error\n   */\n\n\n  async function validateAndNormalizeKeyholder(address, req) {\n    if (typeof address === \"string\" && address.length > 0) {\n      // ensure address is included in provided accounts\n      const accounts = await getAccounts(req);\n      const normalizedAccounts = accounts.map(_address => _address.toLowerCase());\n      const normalizedAddress = address.toLowerCase();\n\n      if (normalizedAccounts.includes(normalizedAddress)) {\n        return normalizedAddress;\n      }\n    }\n\n    throw ethErrors.rpc.invalidParams({\n      message: \"Invalid parameters: must provide an Ethereum address.\"\n    });\n  } //\n  // account lookups\n  //\n\n\n  async function lookupAccounts(req, res) {\n    res.result = await getAccounts(req);\n  }\n\n  async function lookupDefaultAccount(req, res) {\n    const accounts = await getAccounts(req);\n    res.result = accounts[0] || null;\n  } //\n  // transaction signatures\n  //\n\n\n  async function sendTransaction(req, res) {\n    if (!processTransaction) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const txParams = req.params[0] || {\n      from: \"\"\n    };\n    txParams.from = await validateAndNormalizeKeyholder(txParams.from, req);\n    res.result = await processTransaction(txParams, req);\n  }\n\n  async function signTransaction(req, res) {\n    if (!processSignTransaction) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const txParams = req.params[0] || {\n      from: \"\"\n    };\n    txParams.from = await validateAndNormalizeKeyholder(txParams.from, req);\n    res.result = await processSignTransaction(txParams, req);\n  } //\n  // message signatures\n  //\n\n\n  async function ethSign(req, res) {\n    if (!processEthSignMessage) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const address = await validateAndNormalizeKeyholder(req.params[0], req);\n    const message = req.params[1];\n    const extraParams = req.params[2] || {};\n\n    const msgParams = _objectSpread$5(_objectSpread$5({}, extraParams), {}, {\n      from: address,\n      data: message\n    });\n\n    res.result = await processEthSignMessage(msgParams, req);\n  }\n\n  async function signTypedData(req, res) {\n    if (!processTypedMessage) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const message = req.params[0];\n    const address = await validateAndNormalizeKeyholder(req.params[1], req);\n    const version = \"V1\";\n    const extraParams = req.params[2] || {};\n\n    const msgParams = _objectSpread$5(_objectSpread$5({}, extraParams), {}, {\n      from: address,\n      data: message\n    });\n\n    res.result = await processTypedMessage(msgParams, req, version);\n  }\n\n  async function signTypedDataV3(req, res) {\n    if (!processTypedMessageV3) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const address = await validateAndNormalizeKeyholder(req.params[0], req);\n    const message = req.params[1];\n    const version = \"V3\";\n    const msgParams = {\n      data: message,\n      from: address,\n      version\n    };\n    res.result = await processTypedMessageV3(msgParams, req, version);\n  }\n\n  async function signTypedDataV4(req, res) {\n    if (!processTypedMessageV4) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const address = await validateAndNormalizeKeyholder(req.params[0], req);\n    const message = req.params[1];\n    const version = \"V4\";\n    const msgParams = {\n      data: message,\n      from: address,\n      version\n    };\n    res.result = await processTypedMessageV4(msgParams, req, version);\n  }\n\n  async function personalSign(req, res) {\n    if (!processPersonalMessage) {\n      throw ethErrors.rpc.methodNotSupported();\n    } // process normally\n\n\n    const firstParam = req.params[0];\n    const secondParam = req.params[1]; // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n\n    const extraParams = req.params[2] || {}; // We initially incorrectly ordered these parameters.\n    // To gracefully respect users who adopted this API early,\n    // we are currently gracefully recovering from the wrong param order\n    // when it is clearly identifiable.\n    //\n    // That means when the first param is definitely an address,\n    // and the second param is definitely not, but is hex.\n\n    let address, message;\n\n    if (resemblesAddress(firstParam) && !resemblesAddress(secondParam)) {\n      let warning = \"The eth_personalSign method requires params ordered \";\n      warning += \"[message, address]. This was previously handled incorrectly, \";\n      warning += \"and has been corrected automatically. \";\n      warning += \"Please switch this param order for smooth behavior in the future.\";\n      res.warning = warning;\n      address = firstParam;\n      message = secondParam;\n    } else {\n      message = firstParam;\n      address = secondParam;\n    }\n\n    address = await validateAndNormalizeKeyholder(address, req);\n\n    const msgParams = _objectSpread$5(_objectSpread$5({}, extraParams), {}, {\n      from: address,\n      data: message\n    }); // eslint-disable-next-line require-atomic-updates\n\n\n    res.result = await processPersonalMessage(msgParams, req);\n  }\n\n  async function encryptionPublicKey(req, res) {\n    if (!processEncryptionPublicKey) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const address = await validateAndNormalizeKeyholder(req.params[0], req);\n    res.result = await processEncryptionPublicKey(address, req);\n  }\n\n  async function decryptMessage(req, res) {\n    if (!processDecryptMessage) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const ciphertext = req.params[0];\n    const address = await validateAndNormalizeKeyholder(req.params[1], req);\n    const extraParams = req.params[2] || {};\n\n    const msgParams = _objectSpread$5(_objectSpread$5({}, extraParams), {}, {\n      from: address,\n      data: ciphertext\n    });\n\n    res.result = processDecryptMessage(msgParams, req);\n  }\n\n  async function fetchPrivateKey(req, res) {\n    if (!getPrivateKey) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    res.result = getPrivateKey(req);\n  }\n\n  return createScaffoldMiddleware({\n    // account lookups\n    eth_accounts: createAsyncMiddleware(lookupAccounts),\n    eth_private_key: createAsyncMiddleware(fetchPrivateKey),\n    eth_coinbase: createAsyncMiddleware(lookupDefaultAccount),\n    // tx signatures\n    eth_sendTransaction: createAsyncMiddleware(sendTransaction),\n    eth_signTransaction: createAsyncMiddleware(signTransaction),\n    // message signatures\n    eth_sign: createAsyncMiddleware(ethSign),\n    eth_signTypedData: createAsyncMiddleware(signTypedData),\n    eth_signTypedData_v3: createAsyncMiddleware(signTypedDataV3),\n    eth_signTypedData_v4: createAsyncMiddleware(signTypedDataV4),\n    personal_sign: createAsyncMiddleware(personalSign),\n    eth_getEncryptionPublicKey: createAsyncMiddleware(encryptionPublicKey),\n    eth_decrypt: createAsyncMiddleware(decryptMessage)\n  });\n}\n\nfunction createEthMiddleware(providerHandlers) {\n  const {\n    getAccounts,\n    getPrivateKey,\n    processTransaction,\n    processSignTransaction,\n    processEthSignMessage,\n    processTypedMessage,\n    processTypedMessageV3,\n    processTypedMessageV4,\n    processPersonalMessage,\n    processEncryptionPublicKey,\n    processDecryptMessage\n  } = providerHandlers;\n  const ethMiddleware = mergeMiddleware([createScaffoldMiddleware({\n    eth_syncing: false\n  }), createWalletMiddleware({\n    getAccounts,\n    getPrivateKey,\n    processTransaction,\n    processEthSignMessage,\n    processSignTransaction,\n    processTypedMessage,\n    processTypedMessageV3,\n    processTypedMessageV4,\n    processPersonalMessage,\n    processEncryptionPublicKey,\n    processDecryptMessage\n  })]);\n  return ethMiddleware;\n}\nfunction createChainSwitchMiddleware(_ref) {\n  let {\n    addChain,\n    switchChain\n  } = _ref;\n\n  async function addNewChain(req, res) {\n    var _req$params;\n\n    const chainParams = (_req$params = req.params) !== null && _req$params !== void 0 && _req$params.length ? req.params[0] : undefined;\n    if (!chainParams) throw ethErrors.rpc.invalidParams(\"Missing chain params\");\n    if (!chainParams.chainId) throw ethErrors.rpc.invalidParams(\"Missing chainId in chainParams\");\n    if (!chainParams.rpcUrls || chainParams.rpcUrls.length === 0) throw ethErrors.rpc.invalidParams(\"Missing rpcUrls in chainParams\");\n    if (!chainParams.nativeCurrency) throw ethErrors.rpc.invalidParams(\"Missing nativeCurrency in chainParams\");\n    res.result = await addChain(chainParams);\n  }\n\n  async function updateChain(req, res) {\n    var _req$params2;\n\n    const chainParams = (_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.length ? req.params[0] : undefined;\n    if (!chainParams) throw ethErrors.rpc.invalidParams(\"Missing chainId\");\n    res.result = await switchChain(chainParams);\n  }\n\n  return createScaffoldMiddleware({\n    wallet_addEthereumChain: createAsyncMiddleware(addNewChain),\n    wallet_switchEthereumChain: createAsyncMiddleware(updateChain)\n  });\n} // #region account middlewares\n\nfunction createAccountMiddleware(_ref2) {\n  let {\n    updatePrivatekey\n  } = _ref2;\n\n  async function updateAccount(req, res) {\n    var _req$params3;\n\n    const accountParams = (_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.length ? req.params[0] : undefined;\n    if (!(accountParams !== null && accountParams !== void 0 && accountParams.privateKey)) throw ethErrors.rpc.invalidParams(\"Missing privateKey\");\n    res.result = await updatePrivatekey(accountParams);\n  }\n\n  return createScaffoldMiddleware({\n    wallet_updateAccount: createAsyncMiddleware(updateAccount)\n  });\n} // #endregion account middlewares\n\nfunction createChainIdMiddleware(chainId) {\n  return (req, res, next, end) => {\n    if (req.method === \"eth_chainId\") {\n      res.result = chainId;\n      return end();\n    }\n\n    return next();\n  };\n}\nfunction createProviderConfigMiddleware(providerConfig) {\n  return (req, res, next, end) => {\n    if (req.method === \"eth_provider_config\") {\n      res.result = providerConfig;\n      return end();\n    }\n\n    return next();\n  };\n}\nfunction createJsonRpcClient(providerConfig) {\n  const {\n    chainId,\n    rpcTarget\n  } = providerConfig;\n  const fetchMiddleware = createFetchMiddleware({\n    rpcTarget\n  });\n  const networkMiddleware = mergeMiddleware([createChainIdMiddleware(chainId), createProviderConfigMiddleware(providerConfig), fetchMiddleware]);\n  return {\n    networkMiddleware,\n    fetchMiddleware\n  };\n}\n\nfunction getProviderHandlers$1(_ref) {\n  let {\n    connector\n  } = _ref;\n  return {\n    getPrivateKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    getAccounts: async _ => {\n      const {\n        accounts\n      } = connector;\n\n      if (accounts && accounts.length) {\n        return accounts;\n      }\n\n      throw new Error(\"Failed to get accounts\");\n    },\n    processTransaction: async (txParams, _) => {\n      const result = await connector.sendTransaction(txParams);\n      return result;\n    },\n    processSignTransaction: async (txParams, _) => {\n      const result = await connector.signTransaction(txParams);\n      return result;\n    },\n    processEthSignMessage: async (msgParams, _) => {\n      const result = await connector.signMessage([msgParams.from, msgParams.data]);\n      return result;\n    },\n    processPersonalMessage: async (msgParams, _) => {\n      const result = await connector.signPersonalMessage([msgParams.data, msgParams.from]);\n      return result;\n    },\n    processTypedMessage: async (msgParams, _) => {\n      const result = await connector.signTypedData([msgParams.from, msgParams.data]);\n      return result;\n    },\n    processTypedMessageV3: async msgParams => {\n      const result = await connector.signTypedData([msgParams.from, msgParams.data]);\n      return result;\n    },\n    processTypedMessageV4: async msgParams => {\n      const result = await connector.signTypedData([msgParams.from, msgParams.data]);\n      return result;\n    },\n    processEncryptionPublicKey: async _ => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    processDecryptMessage: _ => {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n  };\n}\n\nfunction ownKeys$4(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$4(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$4(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass WalletConnectProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state,\n      connector\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread$4(_objectSpread$4({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.EIP155\n        }),\n        skipLookupNetwork: !!config.skipLookupNetwork\n      },\n      state: _objectSpread$4(_objectSpread$4({}, state || {}), {}, {\n        chainId: \"loading\",\n        accounts: []\n      })\n    });\n\n    _defineProperty(this, \"connector\", null);\n\n    this.connector = connector || null;\n  }\n\n  async enable() {\n    if (!this.connector) throw ethErrors.provider.custom({\n      message: \"Connector is not initialized, pass wallet connect connector in constructor\",\n      code: 4902\n    });\n    await this.setupProvider(this.connector);\n    return this._providerEngineProxy.request({\n      method: \"eth_accounts\"\n    });\n  }\n\n  async setupProvider(connector) {\n    this.onConnectorStateUpdate(connector);\n    await this.setupEngine(connector);\n  }\n\n  async switchChain(_ref2) {\n    let {\n      chainId,\n      addChain = true,\n      lookup = true\n    } = _ref2;\n    if (!this.connector) throw ethErrors.provider.custom({\n      message: \"Connector is not initialized, pass wallet connect connector in constructor\",\n      code: 4902\n    });\n    const currentChainConfig = this.getChainConfig(chainId);\n    this.update({\n      chainId: \"loading\"\n    });\n    const {\n      rpcTarget,\n      displayName\n    } = currentChainConfig;\n\n    if (addChain) {\n      try {\n        await this.connector.sendCustomRequest({\n          method: \"wallet_addEthereumChain\",\n          params: [{\n            chainId,\n            chainName: displayName,\n            rpcUrls: [rpcTarget]\n          }]\n        });\n      } catch (error) {\n        log.error(error);\n      }\n    }\n\n    try {\n      await this.connector.sendCustomRequest({\n        method: \"wallet_switchEthereumChain\",\n        params: [{\n          chainId\n        }]\n      });\n    } catch (error) {\n      log.error(error); // ignore this error because metamask & others return provider.result as null\n      // wallet connect thinks this is wrong\n\n      if (error.message !== \"JSON RPC response format is invalid\") {\n        throw error;\n      }\n    }\n\n    this.configure({\n      chainConfig: currentChainConfig\n    });\n    if (lookup) await this.lookupNetwork(this.connector);\n  }\n\n  async addChain(chainConfig) {\n    if (!this.connector) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n    const {\n      rpcTarget,\n      displayName\n    } = chainConfig;\n\n    try {\n      await this.connector.sendCustomRequest({\n        method: \"wallet_addEthereumChain\",\n        params: [{\n          chainId: chainConfig.chainId,\n          chainName: displayName,\n          rpcUrls: [rpcTarget]\n        }]\n      });\n      super.addChain(chainConfig);\n    } catch (error) {\n      log.error(error);\n      throw error;\n    }\n  }\n\n  async lookupNetwork(connector) {\n    if (!connector.connected) throw WalletLoginError.notConnectedError(\"Wallet connect connector is not connected\");\n    if (!this.provider) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const {\n      chainId\n    } = this.config.chainConfig;\n    const connectedHexChainId = isHexStrict(connector.chainId.toString()) ? connector.chainId : \"0x\".concat(connector.chainId.toString(16));\n    if (chainId !== connectedHexChainId) throw WalletInitializationError.rpcConnectionError(\"Invalid network, net_version is: \".concat(connectedHexChainId, \", expected: \").concat(chainId));\n    this.provider.emit(\"connect\", {\n      chainId\n    });\n    this.provider.emit(\"chainChanged\", this.state.chainId);\n    return connectedHexChainId;\n  }\n\n  async setupEngine(connector) {\n    const providerHandlers = getProviderHandlers$1({\n      connector\n    });\n    this.update({\n      accounts: connector.accounts || []\n    });\n    const ethMiddleware = createEthMiddleware(providerHandlers);\n    const engine = new JRPCEngine();\n    const {\n      networkMiddleware\n    } = createJsonRpcClient(this.config.chainConfig);\n    engine.push(ethMiddleware);\n    engine.push(networkMiddleware);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    if (!this.config.skipLookupNetwork) await this.lookupNetwork(connector);\n  }\n\n  async onConnectorStateUpdate(connector) {\n    connector.on(\"session_update\", async (error, payload) => {\n      if (!this.provider) throw WalletLoginError.notConnectedError(\"Wallet connect connector is not connected\");\n\n      if (error) {\n        this.provider.emit(\"error\", error);\n        return;\n      }\n\n      const {\n        accounts,\n        chainId: connectedChainId,\n        rpcUrl\n      } = payload.params[0]; // Check if accounts changed and trigger event\n\n      if (accounts !== null && accounts !== void 0 && accounts.length && this.state.accounts[0] !== accounts[0]) {\n        this.update({\n          accounts\n        }); // await this.setupEngine(connector);\n\n        this.provider.emit(\"accountsChanged\", accounts);\n      }\n\n      const connectedHexChainId = \"0x\".concat(connectedChainId.toString(16)); // Check if chainId changed and trigger event\n\n      if (connectedChainId && this.state.chainId !== connectedHexChainId) {\n        const maybeConfig = getChainConfig(CHAIN_NAMESPACES.EIP155, connectedChainId) || {}; // Handle rpcUrl update\n\n        this.configure({\n          chainConfig: _objectSpread$4(_objectSpread$4({}, maybeConfig), {}, {\n            chainId: connectedHexChainId,\n            rpcTarget: rpcUrl,\n            chainNamespace: CHAIN_NAMESPACES.EIP155\n          })\n        });\n        await this.setupEngine(connector);\n      }\n    });\n  }\n\n}\n\n_defineProperty(WalletConnectProvider, \"getProviderInstance\", async params => {\n  const providerFactory = new WalletConnectProvider({\n    config: {\n      chainConfig: params.chainConfig,\n      skipLookupNetwork: params.skipLookupNetwork\n    }\n  });\n  await providerFactory.setupProvider(params.connector);\n  return providerFactory;\n});\n\nconst BIG_NUMBER_WEI_MULTIPLIER = new BigNumber(\"1e18\");\nconst BIG_NUMBER_GWEI_MULTIPLIER = new BigNumber(\"1e9\");\nconst BIG_NUMBER_ETH_MULTIPLIER = new BigNumber(\"1\"); // Setter Maps\n\nconst toBigNumber = {\n  hex: n => typeof n === \"string\" ? new BigNumber(stripHexPrefix(n), 16) : new BigNumber(n, 16),\n  dec: n => new BigNumber(n, 10)\n};\nconst toNormalizedDenomination = {\n  WEI: bigNumber => bigNumber.div(BIG_NUMBER_WEI_MULTIPLIER),\n  GWEI: bigNumber => bigNumber.div(BIG_NUMBER_GWEI_MULTIPLIER),\n  ETH: bigNumber => bigNumber.div(BIG_NUMBER_ETH_MULTIPLIER)\n};\nconst toSpecifiedDenomination = {\n  WEI: bigNumber => bigNumber.times(BIG_NUMBER_WEI_MULTIPLIER).dp(0, BigNumber.ROUND_HALF_UP),\n  GWEI: bigNumber => bigNumber.times(BIG_NUMBER_GWEI_MULTIPLIER).dp(9, BigNumber.ROUND_HALF_UP),\n  ETH: bigNumber => bigNumber.times(BIG_NUMBER_ETH_MULTIPLIER).dp(9, BigNumber.ROUND_HALF_UP)\n};\nconst baseChange = {\n  hex: n => n.toString(16),\n  dec: n => new BigNumber(n).toString(10)\n};\n\nconst converter = params => {\n  const {\n    value,\n    fromNumericBase,\n    fromDenomination,\n    toNumericBase,\n    toDenomination,\n    numberOfDecimals\n  } = params;\n  let convertedValue = toBigNumber[fromNumericBase](value);\n\n  if (fromDenomination) {\n    convertedValue = toNormalizedDenomination[fromDenomination](convertedValue);\n  }\n\n  if (toDenomination) {\n    convertedValue = toSpecifiedDenomination[toDenomination](convertedValue);\n  }\n\n  if (numberOfDecimals) {\n    convertedValue = convertedValue.dp(numberOfDecimals, BigNumber.ROUND_HALF_DOWN);\n  }\n\n  if (toNumericBase) {\n    convertedValue = baseChange[toNumericBase](convertedValue);\n  }\n\n  return convertedValue;\n};\n\nconst conversionUtil = (value, _ref) => {\n  let {\n    fromNumericBase = \"hex\",\n    toNumericBase,\n    fromDenomination,\n    toDenomination,\n    numberOfDecimals\n  } = _ref;\n  return converter({\n    fromNumericBase,\n    toNumericBase,\n    fromDenomination,\n    toDenomination,\n    numberOfDecimals,\n    value: value || \"0\"\n  });\n};\n\nfunction decGWEIToHexWEI(decGWEI) {\n  return conversionUtil(decGWEI, {\n    fromNumericBase: \"dec\",\n    toNumericBase: \"hex\",\n    fromDenomination: \"GWEI\",\n    toDenomination: \"WEI\"\n  });\n}\n\nfunction hexWEIToDecGWEI(decGWEI) {\n  return conversionUtil(decGWEI, {\n    fromNumericBase: \"hex\",\n    toNumericBase: \"dec\",\n    fromDenomination: \"WEI\",\n    toDenomination: \"GWEI\"\n  });\n}\n\nfunction ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$3(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction normalizeGWEIDecimalNumbers(n) {\n  const numberAsWEIHex = decGWEIToHexWEI(n);\n  const numberAsGWEI = hexWEIToDecGWEI(numberAsWEIHex);\n  return numberAsGWEI;\n}\nasync function fetchEip1159GasEstimates(url) {\n  const estimates = await get(url);\n\n  const normalizedEstimates = _objectSpread$3(_objectSpread$3({}, estimates), {}, {\n    estimatedBaseFee: normalizeGWEIDecimalNumbers(estimates.estimatedBaseFee),\n    low: _objectSpread$3(_objectSpread$3({}, estimates.low), {}, {\n      suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(estimates.low.suggestedMaxPriorityFeePerGas),\n      suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(estimates.low.suggestedMaxFeePerGas)\n    }),\n    medium: _objectSpread$3(_objectSpread$3({}, estimates.medium), {}, {\n      suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(estimates.medium.suggestedMaxPriorityFeePerGas),\n      suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(estimates.medium.suggestedMaxFeePerGas)\n    }),\n    high: _objectSpread$3(_objectSpread$3({}, estimates.high), {}, {\n      suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(estimates.high.suggestedMaxPriorityFeePerGas),\n      suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(estimates.high.suggestedMaxFeePerGas)\n    })\n  });\n\n  return normalizedEstimates;\n}\n/**\n * Hit the legacy MetaSwaps gasPrices estimate api and return the low, medium\n * high values from that API.\n */\n\nasync function fetchLegacyGasPriceEstimates(url) {\n  const result = await get(url, {\n    referrer: url,\n    referrerPolicy: \"no-referrer-when-downgrade\",\n    method: \"GET\",\n    mode: \"cors\"\n  });\n  return {\n    low: result.SafeGasPrice,\n    medium: result.ProposeGasPrice,\n    high: result.FastGasPrice\n  };\n}\nconst validateTypedMessageParams = (parameters, activeChainId) => {\n  var _data$domain;\n\n  try {\n    assert.ok(parameters && typeof parameters === \"object\", \"Params must be an object.\");\n    assert.ok(\"data\" in parameters, 'Params must include a \"data\" field.');\n    assert.ok(\"from\" in parameters, 'Params must include a \"from\" field.');\n    assert.ok(typeof parameters.from === \"string\" && isValidAddress(parameters.from), '\"from\" field must be a valid, lowercase, hexadecimal Ethereum address string.');\n    let data = null;\n    let chainId = null;\n\n    switch (parameters.version) {\n      case SignTypedDataVersion.V1:\n        if (typeof parameters.data === \"string\") {\n          assert.doesNotThrow(() => {\n            data = JSON.parse(parameters.data);\n          }, '\"data\" must be a valid JSON string.');\n        } else {\n          // for backward compatiblity we validate for both string and object type.\n          data = parameters.data;\n        }\n\n        assert.ok(Array.isArray(data), \"params.data must be an array.\");\n        assert.doesNotThrow(() => {\n          typedSignatureHash(data);\n        }, \"Signing data must be valid EIP-712 typed data.\");\n        break;\n\n      case SignTypedDataVersion.V3:\n      case SignTypedDataVersion.V4:\n        if (typeof parameters.data === \"string\") {\n          assert.doesNotThrow(() => {\n            data = JSON.parse(parameters.data);\n          }, '\"data\" must be a valid JSON string.');\n        } else {\n          // for backward compatiblity we validate for both string and object type.\n          data = parameters.data;\n        }\n\n        assert.ok(data.primaryType in data.types, \"Primary type of \\\"\".concat(data.primaryType, \"\\\" has no type definition.\"));\n        const validation = jsonschema.validate(data, TYPED_MESSAGE_SCHEMA.properties);\n        assert.strictEqual(validation.errors.length, 0, \"Signing data must conform to EIP-712 schema. See https://git.io/fNtcx.\");\n        chainId = (_data$domain = data.domain) === null || _data$domain === void 0 ? void 0 : _data$domain.chainId;\n\n        if (chainId) {\n          assert.ok(!Number.isNaN(activeChainId), \"Cannot sign messages for chainId \\\"\".concat(chainId, \"\\\", because Web3Auth is switching networks.\"));\n\n          if (typeof chainId === \"string\") {\n            chainId = Number.parseInt(chainId, isHexStrict(chainId) ? 16 : 10);\n          }\n\n          assert.strictEqual(chainId, activeChainId, \"Provided chainId \\\"\".concat(chainId, \"\\\" must match the active chainId \\\"\").concat(activeChainId, \"\\\"\"));\n        }\n\n        break;\n\n      default:\n        assert.fail(\"Unknown typed data version \\\"\".concat(parameters.version, \"\\\"\"));\n    }\n  } catch (error) {\n    throw ethErrors.rpc.invalidInput({\n      message: error === null || error === void 0 ? void 0 : error.message\n    });\n  }\n};\n\nfunction ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nasync function signTx(txParams, privKey, txFormatter) {\n  const finalTxParams = await txFormatter.formatTransaction(txParams);\n  const common = await txFormatter.getCommonConfiguration();\n  const unsignedEthTx = TransactionFactory.fromTxData(finalTxParams, {\n    common\n  });\n  const signedTx = unsignedEthTx.sign(Buffer.from(privKey, \"hex\")).serialize();\n  return signedTx;\n}\n\nfunction getProviderHandlers(_ref) {\n  let {\n    txFormatter,\n    privKey,\n    getProviderEngineProxy\n  } = _ref;\n  return {\n    getAccounts: async _ => [\"0x\".concat(privateToAddress(Buffer.from(privKey, \"hex\")).toString(\"hex\"))],\n    getPrivateKey: async _ => privKey,\n    processTransaction: async (txParams, _) => {\n      const providerEngineProxy = getProviderEngineProxy();\n      if (!providerEngineProxy) throw ethErrors.provider.custom({\n        message: \"Provider is not initialized\",\n        code: 4902\n      });\n      const signedTx = await signTx(txParams, privKey, txFormatter);\n      const txHash = await providerEngineProxy.request({\n        method: \"eth_sendRawTransaction\",\n        params: [\"0x\".concat(signedTx.toString(\"hex\"))]\n      });\n      return txHash;\n    },\n    processSignTransaction: async (txParams, _) => {\n      const providerEngineProxy = getProviderEngineProxy();\n      if (!providerEngineProxy) throw ethErrors.provider.custom({\n        message: \"Provider is not initialized\",\n        code: 4902\n      });\n      const signedTx = await signTx(txParams, privKey, txFormatter);\n      return \"0x\".concat(signedTx.toString(\"hex\"));\n    },\n    processEthSignMessage: async (msgParams, _) => {\n      const rawMessageSig = signMessage(privKey, msgParams.data);\n      return rawMessageSig;\n    },\n    processPersonalMessage: async (msgParams, _) => {\n      const privKeyBuffer = Buffer.from(privKey, \"hex\");\n      const sig = personalSign({\n        privateKey: privKeyBuffer,\n        data: msgParams.data\n      });\n      return sig;\n    },\n    processTypedMessage: async (msgParams, _) => {\n      log.debug(\"processTypedMessage\", msgParams);\n      const privKeyBuffer = Buffer.from(privKey, \"hex\");\n      const providerEngineProxy = getProviderEngineProxy();\n      if (!providerEngineProxy) throw ethErrors.provider.custom({\n        message: \"Provider is not initialized\",\n        code: 4902\n      });\n      const chainId = await providerEngineProxy.request({\n        method: \"eth_chainId\"\n      });\n      const finalChainId = Number.parseInt(chainId, isHexStrict(chainId) ? 16 : 10);\n\n      const params = _objectSpread$2(_objectSpread$2({}, msgParams), {}, {\n        version: SignTypedDataVersion.V1\n      });\n\n      validateTypedMessageParams(params, finalChainId);\n      const data = typeof params.data === \"string\" ? JSON.parse(params.data) : params.data;\n      const sig = signTypedData({\n        privateKey: privKeyBuffer,\n        data,\n        version: SignTypedDataVersion.V1\n      });\n      return sig;\n    },\n    processTypedMessageV3: async (msgParams, _) => {\n      log.debug(\"processTypedMessageV3\", msgParams);\n      const privKeyBuffer = Buffer.from(privKey, \"hex\");\n      const providerEngineProxy = getProviderEngineProxy();\n      if (!providerEngineProxy) throw ethErrors.provider.custom({\n        message: \"Provider is not initialized\",\n        code: 4902\n      });\n      const chainId = await providerEngineProxy.request({\n        method: \"eth_chainId\"\n      });\n      const finalChainId = Number.parseInt(chainId, isHexStrict(chainId) ? 16 : 10);\n      validateTypedMessageParams(msgParams, finalChainId);\n      const data = typeof msgParams.data === \"string\" ? JSON.parse(msgParams.data) : msgParams.data;\n      const sig = signTypedData({\n        privateKey: privKeyBuffer,\n        data,\n        version: SignTypedDataVersion.V3\n      });\n      return sig;\n    },\n    processTypedMessageV4: async (msgParams, _) => {\n      log.debug(\"processTypedMessageV4\", msgParams);\n      const privKeyBuffer = Buffer.from(privKey, \"hex\");\n      const providerEngineProxy = getProviderEngineProxy();\n      if (!providerEngineProxy) throw ethErrors.provider.custom({\n        message: \"Provider is not initialized\",\n        code: 4902\n      });\n      const chainId = await providerEngineProxy.request({\n        method: \"eth_chainId\"\n      });\n      const finalChainId = Number.parseInt(chainId, isHexStrict(chainId) ? 16 : 10);\n      validateTypedMessageParams(msgParams, finalChainId);\n      const data = typeof msgParams.data === \"string\" ? JSON.parse(msgParams.data) : msgParams.data;\n      const sig = signTypedData({\n        privateKey: privKeyBuffer,\n        data,\n        version: SignTypedDataVersion.V4\n      });\n      return sig;\n    },\n    processEncryptionPublicKey: async (address, _) => {\n      log.info(\"processEncryptionPublicKey\", address);\n      return getEncryptionPublicKey(privKey);\n    },\n    processDecryptMessage: (msgParams, _) => {\n      log.info(\"processDecryptMessage\", msgParams);\n      const stripped = stripHexPrefix(msgParams.data);\n      const buff = Buffer.from(stripped, \"hex\");\n      const decrypted = decrypt({\n        encryptedData: JSON.parse(buff.toString(\"utf8\")),\n        privateKey: privKey\n      });\n      return decrypted;\n    }\n  };\n}\n\nfunction bnLessThan(a, b) {\n  if (a === null || a === undefined || b === null || b === undefined) {\n    return null;\n  }\n\n  return new BigNumber$1(a, 10).lt(b, 10);\n}\nfunction bnToHex(inputBn) {\n  return addHexPrefix(inputBn.toString(16));\n}\nfunction hexToBn(inputHex) {\n  if (BN.isBN(inputHex)) return inputHex;\n  return new BN(stripHexPrefix(inputHex), 16);\n}\nfunction BnMultiplyByFraction(targetBN, numerator, denominator) {\n  const numberBN = new BN(numerator);\n  const denomBN = new BN(denominator);\n  return targetBN.mul(numberBN).div(denomBN);\n}\n\nconst LegacyGasAPIEndpoint = \"https://gas-api.metaswap.codefi.network/networks/<chain_id>/gasPrices\";\nconst EIP1559APIEndpoint = \"https://gas-api.metaswap.codefi.network/networks/<chain_id>/suggestedGasFees\";\nconst TRANSACTION_ENVELOPE_TYPES = {\n  LEGACY: \"0x0\",\n  ACCESS_LIST: \"0x1\",\n  FEE_MARKET: \"0x2\"\n};\nconst TRANSACTION_TYPES = {\n  SENT_ETHER: \"sentEther\",\n  CONTRACT_INTERACTION: \"contractInteraction\",\n  DEPLOY_CONTRACT: \"contractDeployment\",\n  STANDARD_TRANSACTION: \"transaction\"\n};\nconst GAS_ESTIMATE_TYPES = {\n  FEE_MARKET: \"fee-market\",\n  LEGACY: \"legacy\",\n  ETH_GASPRICE: \"eth_gasPrice\",\n  NONE: \"none\"\n};\n\nfunction ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass TransactionFormatter {\n  constructor(_ref) {\n    let {\n      getProviderEngineProxy\n    } = _ref;\n\n    _defineProperty(this, \"chainConfig\", null);\n\n    _defineProperty(this, \"getProviderEngineProxy\", void 0);\n\n    _defineProperty(this, \"isEIP1559Compatible\", false);\n\n    this.getProviderEngineProxy = getProviderEngineProxy;\n  }\n\n  get providerProxy() {\n    return this.getProviderEngineProxy();\n  }\n\n  async init() {\n    this.chainConfig = await this.providerProxy.request({\n      method: \"eth_provider_config\",\n      params: []\n    });\n    this.isEIP1559Compatible = await this.getEIP1559Compatibility();\n  }\n\n  async getCommonConfiguration() {\n    if (!this.chainConfig) throw new Error(\"Chain config not initialized\");\n    const {\n      displayName: name,\n      chainId\n    } = this.chainConfig;\n    const hardfork = this.isEIP1559Compatible ? Hardfork.London : Hardfork.Berlin;\n    const customChainParams = {\n      name,\n      chainId: chainId === \"loading\" ? 0 : Number.parseInt(chainId, 16),\n      networkId: chainId === \"loading\" ? 0 : Number.parseInt(chainId, 16),\n      defaultHardfork: hardfork\n    };\n    return Common.custom(customChainParams);\n  }\n\n  async formatTransaction(txParams) {\n    if (!this.chainConfig) throw new Error(\"Chain config not initialized\");\n\n    const clonedTxParams = _objectSpread$1({}, txParams);\n\n    if (clonedTxParams.nonce === undefined) clonedTxParams.nonce = await this.providerProxy.request({\n      method: \"eth_getTransactionCount\",\n      params: [txParams.from, \"latest\"]\n    });\n\n    if (!this.isEIP1559Compatible && clonedTxParams.gasPrice) {\n      if (clonedTxParams.maxFeePerGas) delete clonedTxParams.maxFeePerGas;\n      if (clonedTxParams.maxPriorityFeePerGas) delete clonedTxParams.maxPriorityFeePerGas; // if gas is not provided explicitly, estimate it.\n\n      if (!clonedTxParams.gas) {\n        const defaultGasLimit = await this.getDefaultGasLimit(clonedTxParams);\n\n        if (defaultGasLimit) {\n          clonedTxParams.gasLimit = defaultGasLimit;\n        }\n      } else {\n        clonedTxParams.gasLimit = clonedTxParams.gas;\n      }\n\n      return clonedTxParams;\n    }\n\n    if (!clonedTxParams.gas) {\n      const defaultGasLimit = await this.getDefaultGasLimit(clonedTxParams);\n\n      if (defaultGasLimit) {\n        clonedTxParams.gasLimit = defaultGasLimit;\n      }\n    } else {\n      clonedTxParams.gasLimit = clonedTxParams.gas;\n    }\n\n    const {\n      gasPrice: defaultGasPrice,\n      maxFeePerGas: defaultMaxFeePerGas,\n      maxPriorityFeePerGas: defaultMaxPriorityFeePerGas\n    } = await this.getDefaultGasFees(clonedTxParams);\n\n    if (this.isEIP1559Compatible) {\n      // If the dapp has suggested a gas price, but no maxFeePerGas or maxPriorityFeePerGas\n      //  then we set maxFeePerGas and maxPriorityFeePerGas to the suggested gasPrice.\n      if (clonedTxParams.gasPrice && !clonedTxParams.maxFeePerGas && !clonedTxParams.maxPriorityFeePerGas) {\n        clonedTxParams.maxFeePerGas = clonedTxParams.gasPrice;\n        clonedTxParams.maxPriorityFeePerGas = bnLessThan(typeof defaultMaxPriorityFeePerGas === \"string\" ? stripHexPrefix(defaultMaxPriorityFeePerGas) : defaultMaxPriorityFeePerGas, typeof clonedTxParams.gasPrice === \"string\" ? stripHexPrefix(clonedTxParams.gasPrice) : clonedTxParams.gasPrice) ? defaultMaxPriorityFeePerGas : clonedTxParams.gasPrice;\n      } else {\n        if (defaultMaxFeePerGas && !clonedTxParams.maxFeePerGas) {\n          // If the dapp has not set the gasPrice or the maxFeePerGas, then we set maxFeePerGas\n          // with the one returned by the gasFeeController, if that is available.\n          clonedTxParams.maxFeePerGas = defaultMaxFeePerGas;\n        }\n\n        if (defaultMaxPriorityFeePerGas && !clonedTxParams.maxPriorityFeePerGas) {\n          // If the dapp has not set the gasPrice or the maxPriorityFeePerGas, then we set maxPriorityFeePerGas\n          // with the one returned by the gasFeeController, if that is available.\n          clonedTxParams.maxPriorityFeePerGas = defaultMaxPriorityFeePerGas;\n        }\n\n        if (defaultGasPrice && !clonedTxParams.maxFeePerGas) {\n          // If the dapp has not set the gasPrice or the maxFeePerGas, and no maxFeePerGas is available\n          // then we set maxFeePerGas to the defaultGasPrice, assuming it is\n          // available.\n          clonedTxParams.maxFeePerGas = defaultGasPrice;\n        }\n\n        if (clonedTxParams.maxFeePerGas && !clonedTxParams.maxPriorityFeePerGas) {\n          // If the dapp has not set the gasPrice or the maxPriorityFeePerGas, and no maxPriorityFeePerGas is\n          // available  then we set maxPriorityFeePerGas to\n          // clonedTxParams.maxFeePerGas, which will either be the gasPrice from the controller, the maxFeePerGas\n          // set by the dapp, or the maxFeePerGas from the controller.\n          clonedTxParams.maxPriorityFeePerGas = clonedTxParams.maxFeePerGas;\n        }\n      } // We remove the gasPrice param entirely when on an eip1559 compatible network\n\n\n      delete clonedTxParams.gasPrice;\n    } else {\n      // We ensure that maxFeePerGas and maxPriorityFeePerGas are not in the transaction params\n      // when not on a EIP1559 compatible network\n      delete clonedTxParams.maxPriorityFeePerGas;\n      delete clonedTxParams.maxFeePerGas;\n    } // If we have gotten to this point, and none of gasPrice, maxPriorityFeePerGas or maxFeePerGas are\n    // set on txParams, it means that either we are on a non-EIP1559 network and the dapp didn't suggest\n    // a gas price, or we are on an EIP1559 network, and none of gasPrice, maxPriorityFeePerGas or maxFeePerGas\n    // were available from either the dapp or the network.\n\n\n    if (defaultGasPrice && !clonedTxParams.gasPrice && !clonedTxParams.maxPriorityFeePerGas && !clonedTxParams.maxFeePerGas) {\n      clonedTxParams.gasPrice = defaultGasPrice;\n    }\n\n    clonedTxParams.type = this.isEIP1559Compatible ? TRANSACTION_ENVELOPE_TYPES.FEE_MARKET : TRANSACTION_ENVELOPE_TYPES.LEGACY;\n    clonedTxParams.chainId = this.chainConfig.chainId;\n    return clonedTxParams;\n  }\n\n  async fetchEthGasPriceEstimate() {\n    const gasPrice = await this.providerProxy.request({\n      method: \"eth_gasPrice\",\n      params: []\n    });\n    return {\n      gasPrice: hexWEIToDecGWEI(gasPrice).toString()\n    };\n  }\n\n  async getEIP1559Compatibility() {\n    const latestBlock = await this.providerProxy.request({\n      method: \"eth_getBlockByNumber\",\n      params: [\"latest\", false]\n    });\n    const supportsEIP1559 = latestBlock && latestBlock.baseFeePerGas !== undefined;\n    return !!supportsEIP1559;\n  }\n\n  async fetchGasFeeEstimateData() {\n    if (!this.chainConfig) throw new Error(\"Chain config not initialized\");\n    const isLegacyGasAPICompatible = this.chainConfig.chainId === \"0x1\";\n    const chainId = Number.parseInt(this.chainConfig.chainId, 16);\n    let gasData;\n\n    try {\n      if (this.isEIP1559Compatible) {\n        // TODO: kovan is not working due to a bug in metamask api\n        const estimates = await fetchEip1159GasEstimates(EIP1559APIEndpoint.replace(\"<chain_id>\", \"\".concat(chainId)));\n        gasData = {\n          gasFeeEstimates: estimates,\n          gasEstimateType: GAS_ESTIMATE_TYPES.FEE_MARKET\n        };\n      } else if (isLegacyGasAPICompatible) {\n        const estimates = await fetchLegacyGasPriceEstimates(LegacyGasAPIEndpoint.replace(\"<chain_id>\", \"\".concat(chainId)));\n        gasData = {\n          gasFeeEstimates: estimates,\n          gasEstimateType: GAS_ESTIMATE_TYPES.LEGACY\n        };\n      } else {\n        throw new Error(\"Main gas fee/price estimation failed. Use fallback\");\n      }\n    } catch (e) {\n      try {\n        const estimates = await this.fetchEthGasPriceEstimate();\n        gasData = {\n          gasFeeEstimates: estimates,\n          gasEstimateType: GAS_ESTIMATE_TYPES.ETH_GASPRICE\n        };\n      } catch (error) {\n        throw new Error(\"Gas fee/price estimation failed. Message: \".concat(error.message));\n      }\n    }\n\n    return gasData;\n  }\n\n  async getDefaultGasFees(txParams) {\n    if (!this.isEIP1559Compatible && txParams.gasPrice || this.isEIP1559Compatible && txParams.maxFeePerGas && txParams.maxPriorityFeePerGas) {\n      return {};\n    }\n\n    try {\n      const {\n        gasFeeEstimates,\n        gasEstimateType\n      } = await this.fetchGasFeeEstimateData();\n\n      if (this.isEIP1559Compatible && gasEstimateType === GAS_ESTIMATE_TYPES.FEE_MARKET) {\n        const {\n          medium: {\n            suggestedMaxPriorityFeePerGas,\n            suggestedMaxFeePerGas\n          } = {}\n        } = gasFeeEstimates;\n\n        if (suggestedMaxPriorityFeePerGas && suggestedMaxFeePerGas) {\n          return {\n            maxFeePerGas: addHexPrefix(decGWEIToHexWEI(suggestedMaxFeePerGas)),\n            maxPriorityFeePerGas: addHexPrefix(decGWEIToHexWEI(suggestedMaxPriorityFeePerGas))\n          };\n        }\n      } else if (gasEstimateType === GAS_ESTIMATE_TYPES.LEGACY) {\n        // The LEGACY type includes low, medium and high estimates of\n        // gas price values.\n        return {\n          gasPrice: addHexPrefix(decGWEIToHexWEI(gasFeeEstimates.medium))\n        };\n      } else if (gasEstimateType === GAS_ESTIMATE_TYPES.ETH_GASPRICE) {\n        // The ETH_GASPRICE type just includes a single gas price property,\n        // which we can assume was retrieved from eth_gasPrice\n        return {\n          gasPrice: addHexPrefix(decGWEIToHexWEI(gasFeeEstimates.gasPrice))\n        };\n      }\n    } catch (error) {\n      log.error(error);\n    }\n\n    const {\n      gasPrice\n    } = await this.fetchEthGasPriceEstimate();\n    return {\n      gasPrice: addHexPrefix(decGWEIToHexWEI(gasPrice))\n    };\n  }\n\n  async estimateTxGas(txMeta) {\n    const txParams = _objectSpread$1({}, txMeta); // `eth_estimateGas` can fail if the user has insufficient balance for the\n    // value being sent, or for the gas cost. We don't want to check their\n    // balance here, we just want the gas estimate. The gas price is removed\n    // to skip those balance checks. We check balance elsewhere. We also delete\n    // maxFeePerGas and maxPriorityFeePerGas to support EIP-1559 txs.\n\n\n    delete txParams.gasPrice;\n    delete txParams.maxFeePerGas;\n    delete txParams.maxPriorityFeePerGas;\n    const gas = await this.providerProxy.request({\n      method: \"eth_estimateGas\",\n      params: [txParams]\n    });\n    return gas;\n  }\n\n  async analyzeGasUsage(txMeta) {\n    const block = await this.providerProxy.request({\n      method: \"eth_getBlockByNumber\",\n      params: [\"latest\", false]\n    }); // fallback to block gasLimit\n\n    const blockGasLimitBN = hexToBn(block.gasLimit);\n    const saferGasLimitBN = BnMultiplyByFraction(blockGasLimitBN, 19, 20);\n    let estimatedGasHex = bnToHex(saferGasLimitBN);\n\n    try {\n      estimatedGasHex = await this.estimateTxGas(txMeta);\n    } catch (error) {\n      log.warn(error);\n    }\n\n    return {\n      blockGasLimit: block.gasLimit,\n      estimatedGasHex\n    };\n  }\n\n  addGasBuffer(initialGasLimitHex, blockGasLimitHex) {\n    let multiplier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1.5;\n    const initialGasLimitBn = hexToBn(initialGasLimitHex);\n    const blockGasLimitBn = hexToBn(blockGasLimitHex);\n    const upperGasLimitBn = blockGasLimitBn.muln(0.9);\n    const bufferedGasLimitBn = initialGasLimitBn.muln(multiplier); // if initialGasLimit is above blockGasLimit, dont modify it\n\n    if (initialGasLimitBn.gt(upperGasLimitBn)) return bnToHex(initialGasLimitBn); // if bufferedGasLimit is below blockGasLimit, use bufferedGasLimit\n\n    if (bufferedGasLimitBn.lt(upperGasLimitBn)) return bnToHex(bufferedGasLimitBn); // otherwise use blockGasLimit\n\n    return bnToHex(upperGasLimitBn);\n  }\n\n  async determineTransactionCategory(txParameters) {\n    const {\n      data,\n      to\n    } = txParameters;\n    let code = \"\";\n    let txCategory;\n\n    if (data && !to) {\n      txCategory = TRANSACTION_TYPES.DEPLOY_CONTRACT;\n    } else {\n      try {\n        code = await this.providerProxy.request({\n          method: \"eth_getCode\",\n          params: [to, \"latest\"]\n        });\n      } catch (error) {\n        log.warn(error);\n      }\n\n      const codeIsEmpty = !code || code === \"0x\" || code === \"0x0\";\n      txCategory = codeIsEmpty ? TRANSACTION_TYPES.SENT_ETHER : TRANSACTION_TYPES.CONTRACT_INTERACTION;\n    }\n\n    return {\n      transactionCategory: txCategory,\n      code\n    };\n  }\n\n  async getDefaultGasLimit(txParams) {\n    const {\n      transactionCategory\n    } = await this.determineTransactionCategory(_objectSpread$1({}, txParams));\n\n    if (txParams.gas) {\n      return txParams.gas;\n    }\n\n    if (txParams.to && transactionCategory === TRANSACTION_TYPES.SENT_ETHER) {\n      // if there's data in the params, but there's no contract code, it's not a valid transaction\n      if (txParams.data) {\n        throw Error(\"TxGasUtil - Trying to call a function on a non-contract address\");\n      }\n\n      const TWENTY_ONE_THOUSAND = 21000; // This is a standard ether simple send, gas requirement is exactly 21k\n\n      return addHexPrefix(TWENTY_ONE_THOUSAND.toString(16));\n    }\n\n    const {\n      blockGasLimit,\n      estimatedGasHex\n    } = await this.analyzeGasUsage(txParams); // add additional gas buffer to our estimation for safety\n\n    const gasLimit = this.addGasBuffer(addHexPrefix(estimatedGasHex), blockGasLimit);\n    return gasLimit;\n  }\n\n}\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass EthereumPrivateKeyProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread(_objectSpread({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.EIP155\n        })\n      },\n      state\n    });\n  }\n\n  async enable() {\n    if (!this.state.privateKey) throw ethErrors.provider.custom({\n      message: \"Private key is not found in state, plz pass it in constructor state param\",\n      code: 4902\n    });\n    await this.setupProvider(this.state.privateKey);\n    return this._providerEngineProxy.request({\n      method: \"eth_accounts\"\n    });\n  }\n\n  async setupProvider(privKey) {\n    const txFormatter = new TransactionFormatter({\n      getProviderEngineProxy: this.getProviderEngineProxy.bind(this)\n    });\n    const providerHandlers = getProviderHandlers({\n      txFormatter,\n      privKey,\n      getProviderEngineProxy: this.getProviderEngineProxy.bind(this)\n    });\n    const ethMiddleware = createEthMiddleware(providerHandlers);\n    const chainSwitchMiddleware = this.getChainSwitchMiddleware();\n    const engine = new JRPCEngine(); // Not a partial anymore because of checks in ctor\n\n    const {\n      networkMiddleware\n    } = createJsonRpcClient(this.config.chainConfig);\n    engine.push(ethMiddleware);\n    engine.push(chainSwitchMiddleware);\n    engine.push(this.getAccountMiddleware());\n    engine.push(networkMiddleware);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await txFormatter.init();\n    await this.lookupNetwork();\n  }\n\n  async updateAccount(params) {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const existingKey = await this._providerEngineProxy.request({\n      method: \"eth_private_key\"\n    });\n\n    if (existingKey !== params.privateKey) {\n      await this.setupProvider(params.privateKey);\n\n      this._providerEngineProxy.emit(\"accountsChanged\", {\n        accounts: await this._providerEngineProxy.request({\n          method: \"eth_accounts\"\n        })\n      });\n    }\n  }\n\n  async switchChain(params) {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const chainConfig = this.getChainConfig(params.chainId);\n    this.update({\n      chainId: \"loading\"\n    });\n    this.configure({\n      chainConfig\n    });\n    const privKey = await this._providerEngineProxy.request({\n      method: \"eth_private_key\"\n    });\n    await this.setupProvider(privKey);\n  }\n\n  async lookupNetwork() {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const {\n      chainId\n    } = this.config.chainConfig;\n    if (!chainId) throw ethErrors.rpc.invalidParams(\"chainId is required while lookupNetwork\");\n    const network = await this._providerEngineProxy.request({\n      method: \"net_version\",\n      params: []\n    });\n    if (parseInt(chainId, 16) !== parseInt(network, 10)) throw ethErrors.provider.chainDisconnected(\"Invalid network, net_version is: \".concat(network));\n\n    if (this.state.chainId !== chainId) {\n      this._providerEngineProxy.emit(\"chainChanged\", chainId);\n\n      this._providerEngineProxy.emit(\"connect\", {\n        chainId\n      });\n    }\n\n    this.update({\n      chainId\n    });\n    return network;\n  }\n\n  getChainSwitchMiddleware() {\n    const chainSwitchHandlers = {\n      addChain: async params => {\n        const {\n          chainId,\n          chainName,\n          rpcUrls,\n          blockExplorerUrls,\n          nativeCurrency\n        } = params;\n        this.addChain({\n          chainNamespace: \"eip155\",\n          chainId,\n          ticker: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.symbol) || \"ETH\",\n          tickerName: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.name) || \"Ether\",\n          displayName: chainName,\n          rpcTarget: rpcUrls[0],\n          blockExplorer: (blockExplorerUrls === null || blockExplorerUrls === void 0 ? void 0 : blockExplorerUrls[0]) || \"\"\n        });\n      },\n      switchChain: async params => {\n        const {\n          chainId\n        } = params;\n        await this.switchChain({\n          chainId\n        });\n      }\n    };\n    const chainSwitchMiddleware = createChainSwitchMiddleware(chainSwitchHandlers);\n    return chainSwitchMiddleware;\n  }\n\n  getAccountMiddleware() {\n    const accountHandlers = {\n      updatePrivatekey: async params => {\n        const {\n          privateKey\n        } = params;\n        await this.updateAccount({\n          privateKey\n        });\n      }\n    };\n    return createAccountMiddleware(accountHandlers);\n  }\n\n}\n\n_defineProperty(EthereumPrivateKeyProvider, \"getProviderInstance\", async params => {\n  const providerFactory = new EthereumPrivateKeyProvider({\n    config: {\n      chainConfig: params.chainConfig\n    }\n  });\n  await providerFactory.setupProvider(params.privKey);\n  return providerFactory;\n});\n\nexport { EthereumPrivateKeyProvider, TransactionFormatter, WalletConnectProvider, getProviderHandlers };\n//# sourceMappingURL=ethereumProvider.esm.js.map\n",null,null,null,null,null,null,null,null,null,null,null,"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { BaseController, createEventEmitterProxy, providerFromEngine } from '@toruslabs/base-controllers';\nimport { WalletInitializationError } from '@web3auth/base';\nimport { ethErrors } from 'eth-rpc-errors';\nimport { JRPCEngine, createScaffoldMiddleware, createAsyncMiddleware } from '@toruslabs/openlogin-jrpc';\nimport getCreateRandomId from 'json-rpc-random-id';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass BaseProvider extends BaseController {\n  // should be Assigned in setupProvider\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config,\n      state\n    });\n\n    _defineProperty(this, \"_providerEngineProxy\", null);\n\n    if (!config.chainConfig) throw WalletInitializationError.invalidProviderConfigError(\"Please provide chainConfig\");\n    if (!config.chainConfig.chainId) throw WalletInitializationError.invalidProviderConfigError(\"Please provide chainId inside chainConfig\");\n    if (!config.chainConfig.rpcTarget) throw WalletInitializationError.invalidProviderConfigError(\"Please provide rpcTarget inside chainConfig\");\n    this.defaultState = {\n      chainId: \"loading\"\n    };\n    this.defaultConfig = {\n      chainConfig: config.chainConfig,\n      networks: {\n        [config.chainConfig.chainId]: config.chainConfig\n      }\n    };\n    super.initialize();\n  }\n\n  get provider() {\n    return this._providerEngineProxy;\n  }\n\n  set provider(_) {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  addChain(chainConfig) {\n    if (!chainConfig.chainId) throw ethErrors.rpc.invalidParams(\"chainId is required\");\n    if (!chainConfig.rpcTarget) throw ethErrors.rpc.invalidParams(\"chainId is required\");\n    this.configure({\n      networks: _objectSpread(_objectSpread({}, this.config.networks), {}, {\n        [chainConfig.chainId]: chainConfig\n      })\n    });\n  }\n\n  getChainConfig(chainId) {\n    var _this$config$networks;\n\n    const chainConfig = (_this$config$networks = this.config.networks) === null || _this$config$networks === void 0 ? void 0 : _this$config$networks[chainId];\n    if (!chainConfig) throw ethErrors.rpc.invalidRequest(\"Chain \".concat(chainId, \" is not supported, please add chainConfig for it\"));\n    return chainConfig;\n  }\n\n  getProviderEngineProxy() {\n    return this._providerEngineProxy;\n  }\n\n  updateProviderEngineProxy(providerEngineProxy) {\n    if (this._providerEngineProxy) {\n      this._providerEngineProxy.setTarget(providerEngineProxy);\n    } else {\n      this._providerEngineProxy = createEventEmitterProxy(providerEngineProxy);\n    }\n  }\n\n}\n\nclass CommonPrivateKeyProvider {\n  constructor() {\n    _defineProperty(this, \"_providerEngineProxy\", null);\n  }\n\n  get provider() {\n    return this._providerEngineProxy;\n  }\n\n  set provider(_) {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  addChain(_) {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  async setupProvider(privKey) {\n    const privKeyMiddleware = this.getPrivKeyMiddleware(privKey);\n    const engine = new JRPCEngine();\n    engine.push(privKeyMiddleware);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n  }\n\n  async switchChain(_) {\n    return Promise.resolve();\n  }\n\n  getProviderEngineProxy() {\n    return this._providerEngineProxy;\n  }\n\n  updateProviderEngineProxy(providerEngineProxy) {\n    if (this._providerEngineProxy) {\n      this._providerEngineProxy.setTarget(providerEngineProxy);\n    } else {\n      this._providerEngineProxy = createEventEmitterProxy(providerEngineProxy);\n    }\n  }\n\n  getPrivKeyMiddleware(privKey) {\n    const middleware = {\n      getPrivatekey: async () => {\n        return privKey;\n      }\n    };\n    return this.createPrivKeyMiddleware(middleware);\n  }\n\n  createPrivKeyMiddleware(_ref) {\n    let {\n      getPrivatekey\n    } = _ref;\n\n    async function getPrivatekeyHandler(_, res) {\n      res.result = await getPrivatekey();\n    }\n\n    return createScaffoldMiddleware({\n      private_key: createAsyncMiddleware(getPrivatekeyHandler)\n    });\n  }\n\n}\n\n_defineProperty(CommonPrivateKeyProvider, \"getProviderInstance\", async params => {\n  const providerFactory = new CommonPrivateKeyProvider();\n  await providerFactory.setupProvider(params.privKey);\n  return providerFactory;\n});\n\nconst createRandomId = getCreateRandomId();\n\nexport { BaseProvider, CommonPrivateKeyProvider, createRandomId };\n//# sourceMappingURL=baseProvider.esm.js.map\n",null,null,"export const ERROR_SESSION_CONNECTED = \"Session currently connected\";\nexport const ERROR_SESSION_DISCONNECTED = \"Session currently disconnected\";\nexport const ERROR_SESSION_REJECTED = \"Session Rejected\";\nexport const ERROR_MISSING_JSON_RPC = \"Missing JSON RPC response\";\nexport const ERROR_MISSING_RESULT = `JSON-RPC success response must include \"result\" field`;\nexport const ERROR_MISSING_ERROR = `JSON-RPC error response must include \"error\" field`;\nexport const ERROR_MISSING_METHOD = `JSON RPC request must have valid \"method\" value`;\nexport const ERROR_MISSING_ID = `JSON RPC request must have valid \"id\" value`;\nexport const ERROR_MISSING_REQUIRED = \"Missing one of the required parameters: bridge / uri / session\";\nexport const ERROR_INVALID_RESPONSE = \"JSON RPC response format is invalid\";\nexport const ERROR_INVALID_URI = \"URI format is invalid\";\nexport const ERROR_QRCODE_MODAL_NOT_PROVIDED = \"QRCode Modal not provided\";\nexport const ERROR_QRCODE_MODAL_USER_CLOSED = \"User close QRCode Modal\";\n//# sourceMappingURL=errors.js.map","import { isJsonRpcRequest, isJsonRpcResponseSuccess, isJsonRpcResponseError, isInternalEvent, isReservedEvent, } from \"@walletconnect/utils\";\nclass EventManager {\n    constructor() {\n        this._eventEmitters = [];\n    }\n    subscribe(eventEmitter) {\n        this._eventEmitters.push(eventEmitter);\n    }\n    unsubscribe(event) {\n        this._eventEmitters = this._eventEmitters.filter(x => x.event !== event);\n    }\n    trigger(payload) {\n        let eventEmitters = [];\n        let event;\n        if (isJsonRpcRequest(payload)) {\n            event = payload.method;\n        }\n        else if (isJsonRpcResponseSuccess(payload) || isJsonRpcResponseError(payload)) {\n            event = `response:${payload.id}`;\n        }\n        else if (isInternalEvent(payload)) {\n            event = payload.event;\n        }\n        else {\n            event = \"\";\n        }\n        if (event) {\n            eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === event);\n        }\n        if ((!eventEmitters || !eventEmitters.length) &&\n            !isReservedEvent(event) &&\n            !isInternalEvent(event)) {\n            eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === \"call_request\");\n        }\n        eventEmitters.forEach((eventEmitter) => {\n            if (isJsonRpcResponseError(payload)) {\n                const error = new Error(payload.error.message);\n                eventEmitter.callback(error, null);\n            }\n            else {\n                eventEmitter.callback(null, payload);\n            }\n        });\n    }\n}\nexport default EventManager;\n//# sourceMappingURL=events.js.map","import { isWalletConnectSession, getLocal, setLocal, removeLocal } from \"@walletconnect/utils\";\nclass SessionStorage {\n    constructor(storageId = \"walletconnect\") {\n        this.storageId = storageId;\n    }\n    getSession() {\n        let session = null;\n        const json = getLocal(this.storageId);\n        if (json && isWalletConnectSession(json)) {\n            session = json;\n        }\n        return session;\n    }\n    setSession(session) {\n        setLocal(this.storageId, session);\n        return session;\n    }\n    removeSession() {\n        removeLocal(this.storageId);\n    }\n}\nexport default SessionStorage;\n//# sourceMappingURL=storage.js.map","const domain = \"walletconnect.org\";\nconst alphanumerical = \"abcdefghijklmnopqrstuvwxyz0123456789\";\nconst bridges = alphanumerical.split(\"\").map(char => `https://${char}.bridge.walletconnect.org`);\nexport function extractHostname(url) {\n    let hostname = url.indexOf(\"//\") > -1 ? url.split(\"/\")[2] : url.split(\"/\")[0];\n    hostname = hostname.split(\":\")[0];\n    hostname = hostname.split(\"?\")[0];\n    return hostname;\n}\nexport function extractRootDomain(url) {\n    return extractHostname(url)\n        .split(\".\")\n        .slice(-2)\n        .join(\".\");\n}\nexport function randomBridgeIndex() {\n    return Math.floor(Math.random() * bridges.length);\n}\nexport function selectRandomBridgeUrl() {\n    return bridges[randomBridgeIndex()];\n}\nexport function shouldSelectRandomly(url) {\n    return extractRootDomain(url) === domain;\n}\nexport function getBridgeUrl(url) {\n    if (shouldSelectRandomly(url)) {\n        return selectRandomBridgeUrl();\n    }\n    return url;\n}\n//# sourceMappingURL=url.js.map","import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport WalletConnect from '@walletconnect/client';\nimport { CHAIN_NAMESPACES, WALLET_ADAPTERS, ADAPTER_NAMESPACES, ADAPTER_CATEGORY, ADAPTER_STATUS, getChainConfig, ADAPTER_EVENTS, log, WalletInitializationError, Web3AuthError, WalletLoginError } from '@web3auth/base';\nimport { BaseEvmAdapter } from '@web3auth/base-evm-adapter';\nimport { WalletConnectProvider } from '@web3auth/ethereum-provider';\n\nconst WALLET_CONNECT_EXTENSION_ADAPTERS = [{\n  name: \"Rainbow\",\n  chains: [CHAIN_NAMESPACES.EIP155],\n  logo: \"https://images.web3auth.io/login-rainbow.svg\",\n  mobile: {\n    native: \"rainbow:\",\n    universal: \"https://rnbwapp.com\"\n  },\n  desktop: {\n    native: \"\",\n    universal: \"\"\n  }\n}, {\n  name: \"MetaMask\",\n  chains: [CHAIN_NAMESPACES.EIP155],\n  logo: \"https://images.web3auth.io/login-metamask.svg\",\n  mobile: {\n    native: \"metamask:\",\n    universal: \"https://metamask.app.link\"\n  },\n  desktop: {\n    native: \"\",\n    universal: \"\"\n  }\n}];\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nclass WalletConnectV1Adapter extends BaseEvmAdapter {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n\n    _defineProperty(this, \"name\", WALLET_ADAPTERS.WALLET_CONNECT_V1);\n\n    _defineProperty(this, \"adapterNamespace\", ADAPTER_NAMESPACES.EIP155);\n\n    _defineProperty(this, \"currentChainNamespace\", CHAIN_NAMESPACES.EIP155);\n\n    _defineProperty(this, \"type\", ADAPTER_CATEGORY.EXTERNAL);\n\n    _defineProperty(this, \"adapterOptions\", void 0);\n\n    _defineProperty(this, \"status\", ADAPTER_STATUS.NOT_READY);\n\n    _defineProperty(this, \"adapterData\", {\n      uri: \"\",\n      extensionAdapters: WALLET_CONNECT_EXTENSION_ADAPTERS\n    });\n\n    _defineProperty(this, \"connector\", null);\n\n    _defineProperty(this, \"wcProvider\", null);\n\n    _defineProperty(this, \"rehydrated\", false);\n\n    this.adapterOptions = _objectSpread({}, options);\n    this.chainConfig = options.chainConfig || null;\n    this.sessionTime = options.sessionTime || 86400;\n  }\n\n  get connected() {\n    var _this$connector;\n\n    return !!((_this$connector = this.connector) !== null && _this$connector !== void 0 && _this$connector.connected);\n  }\n\n  get provider() {\n    var _this$wcProvider;\n\n    return ((_this$wcProvider = this.wcProvider) === null || _this$wcProvider === void 0 ? void 0 : _this$wcProvider.provider) || null;\n  }\n\n  set provider(_) {\n    throw new Error(\"Not implemented\");\n  }\n\n  async init() {\n    super.checkInitializationRequirements();\n\n    if (!this.chainConfig) {\n      this.chainConfig = getChainConfig(CHAIN_NAMESPACES.EIP155, 1);\n    } // Create a connector\n\n\n    this.connector = this.getWalletConnectInstance();\n    this.wcProvider = new WalletConnectProvider({\n      config: {\n        chainConfig: this.chainConfig\n      },\n      connector: this.connector\n    });\n    this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.WALLET_CONNECT_V1);\n    this.status = ADAPTER_STATUS.READY;\n    log.debug(\"initializing wallet connect v1 adapter\");\n\n    if (this.connector.connected) {\n      this.rehydrated = true;\n      await this.onConnectHandler({\n        accounts: this.connector.accounts,\n        chainId: this.connector.chainId\n      });\n    }\n  }\n\n  async connect() {\n    super.checkConnectionRequirements();\n    if (!this.connector) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n\n    if (this.connected) {\n      await this.onConnectHandler({\n        accounts: this.connector.accounts,\n        chainId: this.connector.chainId\n      });\n      return this.provider;\n    }\n\n    if (this.status !== ADAPTER_STATUS.CONNECTING) {\n      var _this$adapterOptions$;\n\n      // for wallet connect qr code modal we have to create a new connector, coz wallet connect internally does not open\n      // modal again on existing instance if connection is pending.\n      if ((_this$adapterOptions$ = this.adapterOptions.adapterSettings) !== null && _this$adapterOptions$ !== void 0 && _this$adapterOptions$.qrcodeModal) {\n        var _this$adapterOptions$2;\n\n        this.connector = this.getWalletConnectInstance();\n        this.wcProvider = new WalletConnectProvider({\n          config: {\n            chainConfig: this.chainConfig,\n            // network switching can be skipped with custom ui\n            skipLookupNetwork: (_this$adapterOptions$2 = this.adapterOptions.adapterSettings) === null || _this$adapterOptions$2 === void 0 ? void 0 : _this$adapterOptions$2.skipNetworkSwitching\n          },\n          connector: this.connector\n        });\n      }\n\n      await this.createNewSession();\n      this.status = ADAPTER_STATUS.CONNECTING;\n      this.emit(ADAPTER_EVENTS.CONNECTING, {\n        adapter: WALLET_ADAPTERS.WALLET_CONNECT_V1\n      });\n    }\n\n    return new Promise((resolve, reject) => {\n      if (!this.connector) return reject(WalletInitializationError.notReady(\"Wallet adapter is not ready yet\")); // for wallet connect default modal.\n\n      this.connector.on(\"modal_closed\", async () => {\n        this.status = ADAPTER_STATUS.READY;\n        this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.WALLET_CONNECT_V1);\n        return reject(new Error(\"User closed modal\"));\n      });\n\n      try {\n        // Subscribe to session connection\n        this.connector.on(\"connect\", async (error, payload) => {\n          if (error) {\n            this.emit(ADAPTER_EVENTS.ERRORED, error);\n          }\n\n          log.debug(\"connected event emitted by web3auth\");\n          await this.onConnectHandler(payload.params[0]);\n          return resolve(this.provider);\n        });\n      } catch (error) {\n        log.error(\"Wallet connect v1 adapter error while connecting\", error); // ready again to be connected\n\n        this.status = ADAPTER_STATUS.READY;\n        this.rehydrated = true;\n        this.emit(ADAPTER_EVENTS.ERRORED, error);\n        reject(error instanceof Web3AuthError ? error : WalletLoginError.connectionError(\"Failed to login with wallet connect: \".concat((error === null || error === void 0 ? void 0 : error.message) || \"\")));\n      }\n    });\n  }\n\n  setAdapterSettings(options) {\n    if (this.status === ADAPTER_STATUS.READY) return;\n\n    if (options !== null && options !== void 0 && options.sessionTime) {\n      this.sessionTime = options.sessionTime;\n    }\n  }\n\n  async getUserInfo() {\n    if (!this.connected) throw WalletLoginError.notConnectedError(\"Not connected with wallet, Please login/connect first\");\n    return {};\n  }\n\n  async disconnect() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      cleanup: false\n    };\n    const {\n      cleanup\n    } = options;\n    if (!this.connector || !this.connected) throw WalletLoginError.notConnectedError(\"Not connected with wallet\");\n    await super.disconnect();\n    await this.connector.killSession();\n    this.rehydrated = false;\n\n    if (cleanup) {\n      this.connector = null;\n      this.status = ADAPTER_STATUS.NOT_READY;\n      this.wcProvider = null;\n    } else {\n      // ready to connect again\n      this.status = ADAPTER_STATUS.READY;\n    }\n\n    this.emit(ADAPTER_EVENTS.DISCONNECTED);\n  }\n\n  async addChain(chainConfig) {\n    try {\n      var _this$adapterOptions$3;\n\n      if (!this.wcProvider) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n      const networkSwitch = (_this$adapterOptions$3 = this.adapterOptions.adapterSettings) === null || _this$adapterOptions$3 === void 0 ? void 0 : _this$adapterOptions$3.networkSwitchModal;\n\n      if (networkSwitch) {\n        await networkSwitch.addNetwork({\n          chainConfig,\n          appOrigin: window.location.hostname\n        });\n      }\n\n      await this.wcProvider.addChain(chainConfig);\n    } catch (error) {\n      log.error(error);\n    }\n  }\n\n  async switchChain(connectedChainConfig, chainConfig) {\n    var _this$adapterOptions$4;\n\n    if (!this.wcProvider) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n    const networkSwitch = (_this$adapterOptions$4 = this.adapterOptions.adapterSettings) === null || _this$adapterOptions$4 === void 0 ? void 0 : _this$adapterOptions$4.networkSwitchModal;\n\n    if (networkSwitch) {\n      await networkSwitch.switchNetwork({\n        currentChainConfig: chainConfig,\n        newChainConfig: connectedChainConfig,\n        appOrigin: window.location.hostname\n      });\n    }\n\n    await this.wcProvider.switchChain({\n      chainId: chainConfig.chainId,\n      lookup: false,\n      addChain: false\n    });\n  }\n\n  async createNewSession() {\n    var _this$adapterOptions, _this$adapterOptions$5;\n\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      forceNewSession: false\n    };\n    if (!this.connector) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n\n    if (opts.forceNewSession && this.connector.pending) {\n      await this.connector.killSession();\n    } // for wallet connect qr modal\n\n\n    if ((_this$adapterOptions = this.adapterOptions) !== null && _this$adapterOptions !== void 0 && (_this$adapterOptions$5 = _this$adapterOptions.adapterSettings) !== null && _this$adapterOptions$5 !== void 0 && _this$adapterOptions$5.qrcodeModal) {\n      var _this$chainConfig;\n\n      await this.connector.createSession({\n        chainId: parseInt(((_this$chainConfig = this.chainConfig) === null || _this$chainConfig === void 0 ? void 0 : _this$chainConfig.chainId) || \"0x1\", 16)\n      });\n      return;\n    } // for web3auth qr code modal\n\n\n    return new Promise((resolve, reject) => {\n      var _this$chainConfig2;\n\n      if (!this.connector) return reject(WalletInitializationError.notReady(\"Wallet adapter is not ready yet\"));\n      log.debug(\"creating new session for web3auth wallet connect\");\n      this.connector.on(\"display_uri\", async (err, payload) => {\n        var _this$connector2;\n\n        if (err) {\n          this.emit(ADAPTER_EVENTS.ERRORED, WalletLoginError.connectionError(\"Failed to display wallet connect qr code\"));\n          return reject(err);\n        }\n\n        const uri = payload.params[0];\n        this.updateAdapterData({\n          uri,\n          extensionAdapters: WALLET_CONNECT_EXTENSION_ADAPTERS\n        });\n        (_this$connector2 = this.connector) === null || _this$connector2 === void 0 ? void 0 : _this$connector2.off(\"display_uri\");\n        return resolve();\n      });\n      this.connector.createSession({\n        chainId: parseInt(((_this$chainConfig2 = this.chainConfig) === null || _this$chainConfig2 === void 0 ? void 0 : _this$chainConfig2.chainId) || \"0x1\", 16)\n      }).catch(error => {\n        log.error(\"error while creating new wallet connect session\", error);\n        this.emit(ADAPTER_EVENTS.ERRORED, error);\n        return reject(error);\n      });\n    });\n  }\n\n  async onConnectHandler(params) {\n    if (!this.connector || !this.wcProvider) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n    if (!this.chainConfig) throw WalletInitializationError.invalidParams(\"Chain config is not set\");\n    const {\n      chainId\n    } = params;\n    log.debug(\"connected chainId in hex\");\n\n    if (chainId !== parseInt(this.chainConfig.chainId, 16)) {\n      var _this$adapterOptions$6, _this$adapterOptions2, _this$adapterOptions3;\n\n      const connectedChainConfig = getChainConfig(CHAIN_NAMESPACES.EIP155, chainId) || {\n        chainId: \"0x\".concat(chainId.toString(16)),\n        displayName: \"Unknown Network\"\n      };\n      const isCustomUi = (_this$adapterOptions$6 = this.adapterOptions.adapterSettings) === null || _this$adapterOptions$6 === void 0 ? void 0 : _this$adapterOptions$6.qrcodeModal; // skipping network is not allowed in default ui. We are use network switching modal for default ui.\n\n      if (!isCustomUi || isCustomUi && !((_this$adapterOptions2 = this.adapterOptions) !== null && _this$adapterOptions2 !== void 0 && (_this$adapterOptions3 = _this$adapterOptions2.adapterSettings) !== null && _this$adapterOptions3 !== void 0 && _this$adapterOptions3.skipNetworkSwitching)) {\n        try {\n          await this.addChain(this.chainConfig);\n          await this.switchChain(connectedChainConfig, this.chainConfig);\n          this.connector = this.getWalletConnectInstance();\n        } catch (error) {\n          log.error(\"error while chain switching\", error); // we need to create a new session since old session is already used and\n          // user needs to login again with correct chain with new qr code.\n\n          await this.createNewSession({\n            forceNewSession: true\n          });\n          this.emit(ADAPTER_EVENTS.ERRORED, WalletInitializationError.fromCode(5000, \"Not connected to correct network. Expected: \".concat(this.chainConfig.displayName, \", Current: \").concat((connectedChainConfig === null || connectedChainConfig === void 0 ? void 0 : connectedChainConfig.displayName) || chainId, \", Please switch to correct network from wallet\")));\n          this.status = ADAPTER_STATUS.READY;\n          this.rehydrated = true;\n          return;\n        }\n      }\n    }\n\n    await this.wcProvider.setupProvider(this.connector);\n    this.subscribeEvents(this.connector);\n    this.status = ADAPTER_STATUS.CONNECTED;\n    this.emit(ADAPTER_EVENTS.CONNECTED, {\n      adapter: WALLET_ADAPTERS.WALLET_CONNECT_V1,\n      reconnected: this.rehydrated\n    });\n  }\n\n  subscribeEvents(connector) {\n    connector.on(\"session_update\", async error => {\n      if (error) {\n        this.emit(ADAPTER_EVENTS.ERRORED, error);\n      }\n    });\n  }\n\n  getWalletConnectInstance() {\n    const walletConnectOptions = this.adapterOptions.adapterSettings || {};\n    walletConnectOptions.bridge = walletConnectOptions.bridge || \"https://bridge.walletconnect.org\"; // Create a connector\n\n    return new WalletConnect(walletConnectOptions);\n  }\n\n}\n\nexport { WalletConnectV1Adapter };\n//# sourceMappingURL=walletConnectV1Adapter.esm.js.map\n",null],"sourceRoot":""}